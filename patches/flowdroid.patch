diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..864f49a
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,4 @@
+[submodule "DroidBench"]
+	path = DroidBench
+	url = https://github.com/secure-software-engineering/DroidBench.git
+	branch = develop
diff --git a/DroidBench b/DroidBench
new file mode 160000
index 0000000..ddbd50c
--- /dev/null
+++ b/DroidBench
@@ -0,0 +1 @@
+Subproject commit ddbd50c68dde18e1f6b75bfa13c617f986ba9e46
diff --git a/pom.xml b/pom.xml
index 5ab843e..8b038d0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -5,7 +5,7 @@
 	<modelVersion>4.0.0</modelVersion>
 	<groupId>de.fraunhofer.sit.flowdroid</groupId>
 	<artifactId>parent</artifactId>
-	<version>2.7.2-SNAPSHOT</version>
+	<version>2.7.3-SNAPSHOT</version>
 	<name>FlowDroid Parent Module</name>
 	<packaging>pom</packaging>
 
@@ -31,7 +31,7 @@
 			<dependency>
 				<groupId>log4j</groupId>
 				<artifactId>log4j</artifactId>
-				<version>1.2.15</version>
+				<version>1.2.17</version>
 				<scope>test</scope>
 				<exclusions>
 					<exclusion>
diff --git a/soot-infoflow-android/.classpath b/soot-infoflow-android/.classpath
index cbc7d21..c46d458 100644
--- a/soot-infoflow-android/.classpath
+++ b/soot-infoflow-android/.classpath
@@ -1,16 +1,32 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
 		<attributes>
 			<attribute name="maven.pomderived" value="true"/>
 		</attributes>
 	</classpathentry>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="test"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/soot"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/soot-infoflow"/>
-	<classpathentry kind="lib" path="lib/protobuf-java-2.5.0.jar"/>
-	<classpathentry kind="output" path="bin"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" output="build/classes" path="src">
+		<attributes>
+			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" output="build/testclasses" path="test">
+		<attributes>
+			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+			<attribute name="test" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry excluding="**" kind="src" output="build/classes" path="schema">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="output" path="build/classes"/>
 </classpath>
diff --git a/soot-infoflow-android/SourcesAndSinks.txt b/soot-infoflow-android/SourcesAndSinks.txt
index b52cf92..bf15aa1 100644
--- a/soot-infoflow-android/SourcesAndSinks.txt
+++ b/soot-infoflow-android/SourcesAndSinks.txt
@@ -1,3 +1,122 @@
+<javax.servlet.ServletRequest: java.lang.String getParameter(java.lang.String)> -> _SOURCE_
+<javax.persistence.EntityManager: javax.persistence.TypedQuery createQuery(java.lang.String,java.lang.Class)> -> _SINK_
+<javax.servlet.http.HttpServletResponse: void sendRedirect(java.lang.String)> -> _SINK_
+<java.io.File: boolean delete()> -> _SINK_
+
+<org.apache.xalan.xsltc.runtime.BasisLibrary: java.lang.String replace(java.lang.String,java.lang.String,java.lang.String[])> -> _SINK_
+<org.springframework.mock.web.portlet.MockPortletRequest: void setParameters(java.util.Map)> -> _SINK_
+<org.apache.axis2.description.AxisService: void printWSDLError(java.io.OutputStream)> -> _SINK_
+<org.springframework.mock.web.portlet.MockPortletRequest: void setParameter(java.lang.String,java.lang.String)> -> _SINK_
+<org.apache.commons.lang3.text.StrSubstitutor: java.lang.String replace(char[])> -> _SINK_
+<org.apache.xmlrpc.webserver.XmlRpcServletServer: void setResponseHeader(org.apache.xmlrpc.common.ServerStreamConnection,java.lang.String,java.lang.String)> -> _SINK_
+<net.sourceforge.pebble.domain.Comment: void setAuthenticated(boolean)> -> _SINK_
+<java.lang.String: java.lang.String replaceFirst(java.lang.String,java.lang.String)> -> _SINK_
+<org.springframework.web.socket.server.support.WebSocketHttpRequestHandler: void handleRequest(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)> -> _SINK_
+<org.apache.xmlrpc.server.ReflectiveXmlRpcHandler: java.lang.Object execute(org.apache.xmlrpc.XmlRpcRequest)> -> _SINK_
+<com.mysql.jdbc.Statement: java.sql.ResultSet executeQuery(java.lang.String)> -> _SINK_
+<org.springframework.test.context.transaction.TransactionalTestExecutionListener: void runAfterTransactionMethods(org.springframework.test.context.TestContext)> -> _SINK_
+<org.springframework.web.servlet.tags.UrlTag: java.lang.String createUrl)> -> _SINK_
+<org.apache.xmlrpc.webserver.XmlRpcServlet: void log(java.lang.String)> -> _SINK_
+<org.apache.stratos.cli.StratosApplication: int run(java.lang.String[])> -> _SINK_
+<org.owasp.webgoat.session.ParameterParser: void update(javax.servlet.ServletRequest)> -> _SINK_
+<org.apache.commons.lang3.text.StrSubstitutor: java.lang.String replace(java.lang.CharSequence)> -> _SINK_
+<org.apache.xmlrpc.webserver.XmlRpcServletServer: void execute(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)> -> _SINK_
+<org.apache.xmlrpc.webserver.ServletOutputStreamImpl: void write(byte[],int,int)> -> _SINK_
+<org.apache.xmlrpc.webserver.ConnectionServer: void writeResponse(org.apache.xmlrpc.common.XmlRpcStreamRequestConfig,java.io.OutputStream,java.lang.Object)> -> _SINK_
+<org.apache.xmlrpc.webserver.Connection: void writeResponseHeader(org.apache.xmlrpc.webserver.RequestData,int)> -> _SINK_
+<org.apache.bcel.util.JavaWrapper: void runMain(java.lang.String,java.lang.String[])> -> _SINK_
+<org.springframework.format.datetime.joda.PeriodFormatter: java.lang.Object parse(java.lang.String,java.util.Locale)> -> _SINK_
+<org.apache.xerces.impl.xs.models.XSDFACM: void dumpTree(org.apache.xerces.impl.dtd.models.CMNode,int)> -> _SINK_
+<org.springframework.jdbc.core.JdbcTemplate: java.lang.Object query(java.lang.String,org.springframework.jdbc.core.ResultSetExtractor)> -> _SINK_
+<org.owasp.webgoat.session.DatabaseUtilities: java.sql.Connection getHsqldbConnection(java.lang.String,org.owasp.webgoat.session.WebgoatContext)> -> _SINK_
+<org.springframework.jdbc.core.JdbcTemplate: void execute(java.lang.String)> -> _SINK_
+<org.springframework.mock.web.MockBodyContent: void println(java.lang.String)> -> _SINK_
+<org.owasp.webgoat.HammerHead: void log(javax.servlet.http.HttpServletRequest,java.lang.String)> -> _SINK_
+<org.apache.xmlrpc.server.XmlRpcServerWorker: java.lang.Object execute(org.apache.xmlrpc.XmlRpcRequest)> -> _SINK_
+<org.owasp.webgoat.session.LessonSession: void setAuthenticated(boolean)> -> _SINK_
+<org.springframework.orm.hibernate3.support.ClobStringType: int[] sqlTypes)> -> _SINK_
+<org.owasp.webgoat.session.WebSession: void update(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse,java.lang.String)> -> _SINK_
+<org.hibernate.validator.internal.util.ConcurrentReferenceHashMap: boolean replace(java.lang.Object,java.lang.Object,java.lang.Object)> -> _SINK_
+<org.apache.xmlrpc.webserver.WebServer: void setParanoid(boolean)> -> _SINK_
+<com.novell.ldap.rfc2251.RfcFilter: void addSubstring(int,byte[])> -> _SINK_
+<org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession: void handleMessage(org.springframework.web.socket.TextMessage,org.springframework.web.socket.WebSocketSession)> -> _SINK_
+<org.xmldb.api.base.XMLDBException: void printStackTrace(java.io.PrintWriter)> -> _SINK_
+<org.springframework.web.socket.adapter.standard.StandardWebSocketSession: void sendTextMessage(org.springframework.web.socket.TextMessage)> -> _SINK_
+<org.apache.xerces.impl.xpath.regex.REUtil: void dumpString(java.lang.String)> -> _SINK_
+<org.apache.xalan.xsltc.compiler.util.Util: java.lang.String replace(java.lang.String,java.lang.String,java.lang.String[])> -> _SINK_
+<org.apache.http.impl.conn.DefaultClientConnection: void sendRequestHeader(org.apache.http.HttpRequest)> -> _SINK_
+<org.apache.commons.validator.util.ValidatorUtils: java.lang.String replace(java.lang.String,java.lang.String,java.lang.String)> -> _SINK_
+<com.google.json.JsonSanitizer: void replace(int,int,java.lang.String)> -> _SINK_
+<org.owasp.esapi.reference.validation.StringValidationRule: void addBlacklistPattern(java.util.regex.Pattern)> -> _SINK_
+<org.apache.commons.lang3.text.StrSubstitutor: java.lang.String replace(java.lang.CharSequence,int,int)> -> _SINK_
+<java.lang.String: java.lang.String replace(java.lang.CharSequence,java.lang.CharSequence)> -> _SINK_
+<org.hibernate.validator.internal.util.ConcurrentReferenceHashMap: java.lang.Object replace(java.lang.Object,java.lang.Object)> -> _SINK_
+<org.springframework.security.util.FieldUtils: void setProtectedFieldValue(java.lang.String,java.lang.Object,java.lang.Object)> -> _SINK_
+<org.springframework.mock.web.MockBodyContent: void println(char[])> -> _SINK_
+<org.springframework.test.context.junit4.SpringJUnit4ClassRunner: void runChild(org.junit.runners.model.FrameworkMethod,org.junit.runner.notification.RunNotifier)> -> _SINK_
+<org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator: void sendMessage(org.springframework.web.socket.WebSocketMessage)> -> _SINK_
+<org.springframework.orm.hibernate3.TypeDefinitionBean: void setParameters(java.util.Properties)> -> _SINK_
+<org.springframework.format.datetime.joda.DateTimeParser: org.joda.time.DateTime parse(java.lang.String,java.util.Locale)> -> _SINK_
+%<java.lang.String: java.lang.String replaceAll(java.lang.String,java.lang.String)> -> _SINK_
+<org.apache.commons.io.HexDump: void dump(byte[],long,java.io.OutputStream,int)> -> _SINK_
+<org.springframework.mock.web.MockJspWriter: void println(java.lang.String)> -> _SINK_
+<org.apache.xalan.templates.ElemTemplateElement: org.w3c.dom.Node replaceChild(org.w3c.dom.Node,org.w3c.dom.Node)> -> _SINK_
+<org.springframework.web.socket.config.HandlersBeanDefinitionParser: org.springframework.beans.factory.config.BeanDefinition parse(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext)> -> _SINK_
+<com.github.scribejava.core.oauth.OAuth20Service: com.github.scribejava.core.model.OAuth2AccessToken sendAccessTokenRequestSync(com.github.scribejava.core.model.OAuthRequest)> -> _SINK_
+<com.github.scribejava.core.oauth.OAuth20Service: java.util.concurrent.Future sendAccessTokenRequestAsync(com.github.scribejava.core.model.OAuthRequestAsync,com.github.scribejava.core.model.OAuthAsyncRequestCallback)> -> _SINK_
+<org.apache.xmlrpc.client.XmlRpcClient: java.lang.Object execute(java.lang.String,java.lang.Object[])> -> _SINK_
+<java.lang.Runtime: java.lang.Process exec(java.lang.String)> -> _SINK_
+<org.apache.xpath.jaxp.XPathImpl: javax.xml.xpath.XPathExpression compile(java.lang.String)> -> _SINK_
+<org.jsoup.parser.Parser: org.jsoup.nodes.Document parse(java.lang.String,java.lang.String)> -> _SINK_
+<org.jsoup.nodes.Node: org.jsoup.nodes.Node before(java.lang.String)> -> _SINK_
+<org.jsoup.nodes.Node: org.jsoup.nodes.Node after(java.lang.String)> -> _SINK_
+<javax.servlet.http.HttpServletResponseWrapper: void sendRedirect(java.lang.String)> -> _SINK_
+
+<org.springframework.security.config.http.CsrfBeanDefinitionParser: org.springframework.beans.factory.config.BeanDefinition getCsrfLogoutHandler)> -> _SOURCE_
+<org.springframework.security.config.authentication.CachingUserDetailsService: org.springframework.security.core.userdetails.UserDetails loadUserByUsername(java.lang.String)> -> _SOURCE_
+<org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper: org.springframework.security.core.userdetails.UserDetails loadUserDetails(org.springframework.security.core.Authentication)> -> _SOURCE_
+<java.io.File: java.io.File getAbsoluteFile)> -> _SOURCE_
+<org.apache.commons.jxpath.ri.parser.XPathParser: java.lang.String unescape(java.lang.String)> -> _SOURCE_
+<org.springframework.security.config.http.FormLoginBeanDefinitionParser: java.lang.String getLoginPage)> -> _SOURCE_
+<org.apache.xmlrpc.webserver.HttpServletRequestImpl: java.lang.String getRealPath(java.lang.String)> -> _SOURCE_
+<com.google.auth.oauth2.UserCredentials: java.lang.String getClientSecret)> -> _SOURCE_
+<org.springframework.web.servlet.tags.UrlTag: java.lang.String createQueryString(java.util.List,java.util.Set,boolean)> -> _SOURCE_
+<org.springframework.messaging.simp.stomp.StompDecoder: java.lang.String unescape(java.lang.String)> -> _SOURCE_
+<org.springframework.web.servlet.tags.UrlTag: java.lang.String createUrl)> -> _SOURCE_
+<java.io.File: java.io.File getCanonicalFile)> -> _SOURCE_
+<org.apache.commons.jxpath.ri.JXPathContextReferenceImpl: java.lang.Object getValue(java.lang.String)> -> _SOURCE_
+<org.apache.xmlrpc.webserver.RequestData: java.lang.String getMethod)> -> _SOURCE_
+<com.google.auth.oauth2.DefaultCredentialsProvider: com.google.auth.oauth2.GoogleCredentials getDefaultCredentials(com.google.api.client.http.HttpTransport)> -> _SOURCE_
+<org.jsoup.nodes.Entities: java.lang.String unescape(java.lang.String)> -> _SOURCE_
+<org.springframework.util.DefaultPropertiesPersister: java.lang.String unescape(java.lang.String)> -> _SOURCE_
+<org.owasp.webgoat.plugins.Plugin: void loadFiles(java.nio.file.Path)> -> _SOURCE_
+<org.apache.xmlrpc.webserver.HttpServletResponseImpl: java.lang.String getHeader(java.lang.String)> -> _SOURCE_
+<com.google.auth.oauth2.UserAuthorizer: com.google.auth.oauth2.UserCredentials getCredentialsFromCode(java.lang.String,java.net.URI)> -> _SOURCE_
+<org.dmfs.oauth2.client.http.requests.ResourceOwnerPasswordTokenRequest: org.dmfs.httpclient.HttpRequestEntity requestEntity)> -> _SOURCE_
+<org.owasp.webgoat.util.HtmlEncoder: java.lang.String decode(java.lang.String)> -> _SOURCE_
+<javax.naming.ldap.Rdn: java.lang.Object unescapeValue(java.lang.String)> -> _SOURCE_
+<org.apache.xmlrpc.webserver.XmlRpcServletServer: org.apache.xmlrpc.common.XmlRpcHttpRequestConfigImpl getConfig(javax.servlet.http.HttpServletRequest)> -> _SOURCE_
+<org.apache.xmlrpc.webserver.HttpServletRequestImpl: void parsePostData(java.util.Map,java.io.InputStream,java.lang.String)> -> _SOURCE_
+<org.springframework.security.concurrent.DelegatingSecurityContextExecutorService: java.util.concurrent.ExecutorService getDelegate)> -> _SOURCE_
+<org.springframework.security.config.annotation.web.builders.HttpSecurity: org.springframework.security.config.'annotation'.web.configurers.HeadersConfigurer headers)> -> _SOURCE_
+<org.springframework.web.servlet.tags.EscapeBodyTag: java.lang.String readBodyContent)> -> _SOURCE_
+<org.springframework.web.util.UrlPathHelper: java.lang.String decodeRequestString(javax.servlet.http.HttpServletRequest,java.lang.String)> -> _SOURCE_
+<org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder: org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder requestAttr(java.lang.String,java.lang.Object)> -> _SOURCE_
+<com.google.auth.oauth2.UserAuthorizer: com.google.auth.oauth2.UserCredentials getCredentials(java.lang.String)> -> _SOURCE_
+<org.springframework.web.socket.sockjs.transport.handler.JsonpReceivingTransportHandler: java.lang.String[] readMessages(org.springframework.http.server.ServerHttpRequest)> -> _SOURCE_
+<com.google.auth.oauth2.DefaultCredentialsProvider: com.google.auth.oauth2.GoogleCredentials getDefaultCredentialsUnsynchronized(com.google.api.client.http.HttpTransport)> -> _SOURCE_
+<org.springframework.security.config.http.FormLoginBeanDefinitionParser: java.lang.String getLoginProcessingUrl)> -> _SOURCE_
+<org.apache.xmlrpc.webserver.HttpServletRequestImpl: java.lang.String readLine(byte[])> -> _SOURCE_
+<org.springframework.security.config.http.LogoutBeanDefinitionParser: org.springframework.beans.factory.config.BeanDefinition getLogoutRequestMatcher(java.lang.String)> -> _SOURCE_
+<org.springframework.security.config.annotation.web.configurers.LogoutConfigurer: java.util.List getLogoutHandlers)> -> _SOURCE_
+<org.apache.xmlrpc.webserver.RequestData: java.lang.String getHttpVersion)> -> _SOURCE_
+<com.novell.ldap.rfc2251.RfcFilter: byte[] unescapeString(java.lang.String)> -> _SOURCE_
+<org.springframework.web.socket.config.HandlersBeanDefinitionParser: org.springframework.beans.factory.config.BeanDefinition parse(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext)> -> _SOURCE_
+<com.google.auth.oauth2.DefaultCredentialsProvider: java.io.File getWellKnownCredentialsFile)> -> _SOURCE_
+<org.apache.xmlrpc.webserver.HttpServletRequestImpl: void parseParameters)> -> _SOURCE_
+<org.jsoup.parser.Parser: org.jsoup.nodes.Document parse(java.lang.String,java.lang.String)> -> _SOURCE_
+<javax.servlet.ServletRequestWrapper: java.lang.String getParameter(java.lang.String)> -> _SOURCE_
+
 <org.apache.http.HttpResponse: org.apache.http.HttpEntity getEntity()> -> _SOURCE_
 <org.apache.http.util.EntityUtils: java.lang.String toString(org.apache.http.HttpEntity)> -> _SOURCE_
 <org.apache.http.HttpResponse: org.apache.http.StatusLine getStatusLine()> -> _SOURCE_
@@ -332,10 +451,10 @@
 <android.content.ContentResolver: android.net.Uri insert(android.net.Uri,android.content.ContentValues)> -> _SINK_
 <android.content.ContentResolver: int delete(android.net.Uri,java.lang.String,java.lang.String[])> -> _SINK_
 <android.content.ContentResolver: int update(android.net.Uri,android.content.ContentValues,java.lang.String,java.lang.String[])> -> _SINK_
-<android.content.ContentResolver: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)> -> _SINK_
-<android.content.ContentResolver: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,android.os.CancellationSignal)> -> _SINK_
-
-
+%<android.content.ContentResolver: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)> -> _SINK_
+%<android.content.ContentResolver: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,android.os.CancellationSignal)> -> _SINK_
+%<android.content.ContentResolver: android.database.Cursor query(android.net.Uri,java.lang.String[],android.os.Bundle,android.os.CancellationSignal)> -> _SOURCE_
+% looks weird, check which ContentResolver query APIs should be sources/sinks
 
 % <android.app.Activity: android.view.View findViewById(int)> -> _SOURCE_
 <android.database.Cursor: java.lang.String getString(int)> -> _SOURCE_
diff --git a/soot-infoflow-android/pom.xml b/soot-infoflow-android/pom.xml
index 371f1f7..54363a6 100644
--- a/soot-infoflow-android/pom.xml
+++ b/soot-infoflow-android/pom.xml
@@ -5,13 +5,38 @@
 	<groupId>de.tud.sse</groupId>
 	<artifactId>soot-infoflow-android</artifactId>
 	<name>soot-infoflow-android</name>
-	<version>2.7.2-SNAPSHOT</version>
+	<version>2.7.3-SNAPSHOT</version>
 	<description>Android-specific components of FlowDroid</description>
+    <url>https://github.com/secure-software-engineering/FlowDroid</url>
+
 	<properties>
-		<maven.compiler.source>1.7</maven.compiler.source>
-		<maven.compiler.target>1.7</maven.compiler.target>
+		<maven.compiler.source>1.8</maven.compiler.source>
+		<maven.compiler.target>1.8</maven.compiler.target>
 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 	</properties>
+
+    <organization>
+        <name>Fraunhofer SIT</name>
+        <url>https://www.sit.fraunhofer.de/</url>
+    </organization>
+
+    <licenses>
+        <license>
+            <name>GNU LESSER GENERAL PUBLIC LICENSE 2.1</name>
+            <url>https://www.gnu.org/licenses/lgpl-2.1.txt</url>
+            <distribution>repo</distribution>
+        </license>
+    </licenses>
+
+    <developers>
+        <developer>
+            <name>Steven Arzt</name>
+            <email>steven.arzt@sit.fraunhofer.de</email>
+            <organization>Fraunhofer SIT</organization>
+            <organizationUrl>https://www.sit.fraunhofer.de/en/</organizationUrl>
+        </developer>
+    </developers>
+
 	<build>
 		<finalName>soot-infoflow-android-classes</finalName>
 		<sourceDirectory>src</sourceDirectory>
@@ -27,7 +52,7 @@
 			<plugin>
 				<groupId>org.apache.maven.plugins</groupId>
 				<artifactId>maven-surefire-plugin</artifactId>
-				<version>2.17</version>
+				<version>2.22.2</version>
 			</plugin>
 			<plugin>
 				<groupId>org.apache.maven.plugins</groupId>
@@ -71,6 +96,16 @@
 					</execution>
 				</executions>
 			</plugin>
+			<plugin>
+				<artifactId>maven-assembly-plugin</artifactId>
+				<configuration>
+					<descriptorRefs>
+						<descriptorRef>jar-with-dependencies</descriptorRef>
+					</descriptorRefs>
+					<finalName>soot-infoflow-android-trunk</finalName>
+					<appendAssemblyId>false</appendAssemblyId>
+				</configuration>
+			</plugin>
 		</plugins>
 		
 		<resources>
@@ -93,18 +128,18 @@
 		<dependency>
 			<groupId>de.tud.sse</groupId>
 			<artifactId>soot-infoflow</artifactId>
-			<version>2.7.2-SNAPSHOT</version>
-		</dependency>
-		<dependency>
-			<groupId>de.upb.cs.swt</groupId>
-			<artifactId>heros</artifactId>
-			<version>1.1.0</version>
-		</dependency>
-		<dependency>
-			<groupId>ca.mcgill.sable</groupId>
-			<artifactId>soot</artifactId>
-			<version>3.3.0</version>
+			<version>2.7.3-SNAPSHOT</version>
 		</dependency>
+<!--		<dependency>-->
+<!--			<groupId>de.upb.cs.swt</groupId>-->
+<!--			<artifactId>heros</artifactId>-->
+<!--			<version>1.1.0</version>-->
+<!--		</dependency>-->
+<!--		<dependency>-->
+<!--			<groupId>ca.mcgill.sable</groupId>-->
+<!--			<artifactId>soot</artifactId>-->
+<!--			<version>3.3.0</version>-->
+<!--		</dependency>-->
 		<dependency>
 			<groupId>junit</groupId>
 			<artifactId>junit</artifactId>
@@ -120,7 +155,7 @@
 		<dependency>
 			<groupId>de.upb.cs.swt</groupId>
 			<artifactId>axml</artifactId>
-			<version>2.0.0-SNAPSHOT</version>
+			<version>2.0.0</version>
 		</dependency>
 		<dependency>
 			<groupId>ca.mcgill.sable</groupId>
@@ -131,7 +166,7 @@
 		<dependency>
 			<groupId>com.google.protobuf</groupId>
 			<artifactId>protobuf-java</artifactId>
-			<version>2.5.0</version>
+			<version>3.4.0</version>
 		</dependency>
 	</dependencies>
 	
diff --git a/soot-infoflow-android/schema/SourcesAndSinks.xsd b/soot-infoflow-android/schema/SourcesAndSinks.xsd
index 2289f9b..42d13cd 100644
--- a/soot-infoflow-android/schema/SourcesAndSinks.xsd
+++ b/soot-infoflow-android/schema/SourcesAndSinks.xsd
@@ -79,6 +79,7 @@
     </xs:sequence>
     <xs:attribute name="isSource" type="xs:boolean" default="false"/>
     <xs:attribute name="isSink" type="xs:boolean" default="false"/>
+    <xs:attribute name="description" type="xs:string" use="optional" />
 </xs:complexType>
 
 <xs:complexType name="pathElementType">
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/InfoflowAndroidConfiguration.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/InfoflowAndroidConfiguration.java
index d4a58e0..6e14034 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/InfoflowAndroidConfiguration.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/InfoflowAndroidConfiguration.java
@@ -504,190 +504,24 @@ public class InfoflowAndroidConfiguration extends InfoflowConfiguration {
 
 	}
 
-	/**
-	 * The default mode how the filter shall treat source or sink categories that
-	 * have not been configured explicitly
-	 * 
-	 * @author Steven Arzt
-	 *
-	 */
-	public static enum SourceSinkFilterMode {
-		/**
-		 * Include all categories that have not been excluded explicitly
-		 */
-		UseAllButExcluded,
-
-		/**
-		 * Only include those categories that have been included explicitly and ignore
-		 * all others
-		 */
-		UseOnlyIncluded
-	}
-
-	/**
-	 * The modes (included or excludes) that a category can have for the data flow
-	 * analysis
-	 * 
-	 * @author Steven Arzt
-	 *
-	 */
-	public static enum CategoryMode {
-		/**
-		 * The sources and sinks from the current category shall be included in the data
-		 * flow analysis
-		 */
-		Include,
-
-		/**
-		 * The sources and sinks from the current category shall be excluded from the
-		 * data flow analysis
-		 */
-		Exclude
-	}
-
 	/**
 	 * The configuration for the source and sink manager
 	 * 
 	 * @author Steven Arzt
 	 *
 	 */
-	public static class SourceSinkConfiguration {
-
-		private CallbackSourceMode callbackSourceMode = CallbackSourceMode.SourceListOnly;
-		private boolean enableLifecycleSources = false;
-		private LayoutMatchingMode layoutMatchingMode = LayoutMatchingMode.MatchSensitiveOnly;
-
-		private SourceSinkFilterMode sourceFilterMode = SourceSinkFilterMode.UseAllButExcluded;
-		private SourceSinkFilterMode sinkFilterMode = SourceSinkFilterMode.UseAllButExcluded;
+	public static class SourceSinkConfiguration extends InfoflowConfiguration.SourceSinkConfiguration {
 
 		private Map<CategoryDefinition, CategoryMode> sourceCategories = new HashMap<>();
 		private Map<CategoryDefinition, CategoryMode> sinkCategories = new HashMap<>();
 
-		/**
-		 * Copies the settings of the given configuration into this configuration object
-		 * 
-		 * @param iccConfig The other configuration object
-		 */
 		public void merge(SourceSinkConfiguration ssConfig) {
-			this.callbackSourceMode = ssConfig.callbackSourceMode;
-			this.enableLifecycleSources = ssConfig.enableLifecycleSources;
-			this.layoutMatchingMode = ssConfig.layoutMatchingMode;
-
-			this.sourceFilterMode = ssConfig.sourceFilterMode;
-			this.sinkFilterMode = ssConfig.sinkFilterMode;
+			super.merge(ssConfig);
 
 			this.sourceCategories.putAll(ssConfig.sourceCategories);
 			this.sinkCategories.putAll(ssConfig.sinkCategories);
 		}
 
-		/**
-		 * Sets under which circumstances the parameters of callback methods shall be
-		 * treated as sources.
-		 * 
-		 * @param callbackSourceMode The strategy for deciding whether a certain
-		 *                           callback parameter is a data flow source or not
-		 */
-		public void setCallbackSourceMode(CallbackSourceMode callbackSourceMode) {
-			this.callbackSourceMode = callbackSourceMode;
-		}
-
-		/**
-		 * Sets under which circumstances the parameters of callback methods shall be
-		 * treated as sources.
-		 * 
-		 * @return The strategy for deciding whether a certain callback parameter is a
-		 *         data flow source or not
-		 */
-		public CallbackSourceMode getCallbackSourceMode() {
-			return this.callbackSourceMode;
-		}
-
-		/**
-		 * Sets whether the parameters of lifecycle methods shall be considered as
-		 * sources
-		 * 
-		 * @param enableLifecycleSoures True if the parameters of lifecycle methods
-		 *                              shall be considered as sources, otherwise false
-		 */
-		public void setEnableLifecycleSources(boolean enableLifecycleSources) {
-			this.enableLifecycleSources = enableLifecycleSources;
-		}
-
-		/**
-		 * Gets whether the parameters of lifecycle methods shall be considered as
-		 * sources
-		 * 
-		 * @return True if the parameters of lifecycle methods shall be considered as
-		 *         sources, otherwise false
-		 */
-		public boolean getEnableLifecycleSources() {
-			return this.enableLifecycleSources;
-		}
-
-		/**
-		 * Sets the mode to be used when deciding whether a UI control is a source or
-		 * not
-		 * 
-		 * @param mode The mode to be used for classifying UI controls as sources
-		 */
-		public void setLayoutMatchingMode(LayoutMatchingMode mode) {
-			this.layoutMatchingMode = mode;
-		}
-
-		/**
-		 * Gets the mode to be used when deciding whether a UI control is a source or
-		 * not
-		 * 
-		 * @return The mode to be used for classifying UI controls as sources
-		 */
-		public LayoutMatchingMode getLayoutMatchingMode() {
-			return this.layoutMatchingMode;
-		}
-
-		/**
-		 * Gets the default mode for handling sources that have not been configured
-		 * explicitly
-		 * 
-		 * @return The default mode for handling sources that have not been configured
-		 *         explicitly
-		 */
-		public SourceSinkFilterMode getSourceFilterMode() {
-			return sourceFilterMode;
-		}
-
-		/**
-		 * Sets the default mode for handling sources that have not been configured
-		 * explicitly
-		 * 
-		 * @param sourceFilterMode The default mode for handling sources that have not
-		 *                         been configured explicitly
-		 */
-		public void setSourceFilterMode(SourceSinkFilterMode sourceFilterMode) {
-			this.sourceFilterMode = sourceFilterMode;
-		}
-
-		/**
-		 * Gets the default mode for handling sinks that have not been configured
-		 * explicitly
-		 * 
-		 * @return The default mode for handling sinks that have not been configured
-		 *         explicitly
-		 */
-		public SourceSinkFilterMode getSinkFilterMode() {
-			return sinkFilterMode;
-		}
-
-		/**
-		 * Sets the default mode for handling sinks that have not been configured
-		 * explicitly
-		 * 
-		 * @param sourceFilterMode The default mode for handling sinks that have not
-		 *                         been configured explicitly
-		 */
-		public void setSinkFilterMode(SourceSinkFilterMode sinkFilterMode) {
-			this.sinkFilterMode = sinkFilterMode;
-		}
-
 		/**
 		 * Gets the explicitly-configured source categories
 		 * 
@@ -756,13 +590,9 @@ public class InfoflowAndroidConfiguration extends InfoflowConfiguration {
 		public int hashCode() {
 			final int prime = 31;
 			int result = 1;
-			result = prime * result + ((callbackSourceMode == null) ? 0 : callbackSourceMode.hashCode());
-			result = prime * result + (enableLifecycleSources ? 1231 : 1237);
-			result = prime * result + ((layoutMatchingMode == null) ? 0 : layoutMatchingMode.hashCode());
+			result = prime * super.hashCode();
 			result = prime * result + ((sinkCategories == null) ? 0 : sinkCategories.hashCode());
-			result = prime * result + ((sinkFilterMode == null) ? 0 : sinkFilterMode.hashCode());
 			result = prime * result + ((sourceCategories == null) ? 0 : sourceCategories.hashCode());
-			result = prime * result + ((sourceFilterMode == null) ? 0 : sourceFilterMode.hashCode());
 			return result;
 		}
 
@@ -775,26 +605,19 @@ public class InfoflowAndroidConfiguration extends InfoflowConfiguration {
 			if (getClass() != obj.getClass())
 				return false;
 			SourceSinkConfiguration other = (SourceSinkConfiguration) obj;
-			if (callbackSourceMode != other.callbackSourceMode)
-				return false;
-			if (enableLifecycleSources != other.enableLifecycleSources)
-				return false;
-			if (layoutMatchingMode != other.layoutMatchingMode)
+			if (!super.equals(obj))
 				return false;
 			if (sinkCategories == null) {
 				if (other.sinkCategories != null)
 					return false;
 			} else if (!sinkCategories.equals(other.sinkCategories))
 				return false;
-			if (sinkFilterMode != other.sinkFilterMode)
-				return false;
 			if (sourceCategories == null) {
 				if (other.sourceCategories != null)
 					return false;
 			} else if (!sourceCategories.equals(other.sourceCategories))
 				return false;
-			if (sourceFilterMode != other.sourceFilterMode)
-				return false;
+
 			return true;
 		}
 
@@ -814,51 +637,6 @@ public class InfoflowAndroidConfiguration extends InfoflowConfiguration {
 		Fast
 	}
 
-	/**
-	 * Methods for deciding whether a parameter of a system callback is to be
-	 * treated as a source or not
-	 * 
-	 * @author Steven Arzt
-	 *
-	 */
-	public static enum CallbackSourceMode {
-		/**
-		 * Callback parameters are never treated as sources
-		 */
-		NoParametersAsSources,
-		/**
-		 * All callback parameters are sources
-		 */
-		AllParametersAsSources,
-		/**
-		 * Only parameters from callback methods explicitly defined as sources are
-		 * treated as sources
-		 */
-		SourceListOnly
-	}
-
-	/**
-	 * Possible modes for matching layout components as data flow sources
-	 * 
-	 * @author Steven Arzt
-	 */
-	public static enum LayoutMatchingMode {
-		/**
-		 * Do not use Android layout components as sources
-		 */
-		NoMatch,
-
-		/**
-		 * Use all layout components as sources
-		 */
-		MatchAll,
-
-		/**
-		 * Only use sensitive layout components (e.g. password fields) as sources
-		 */
-		MatchSensitiveOnly
-	}
-
 	/**
 	 * Enumeration containing the different ways in which Soot can be used
 	 * 
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/SetupApplication.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/SetupApplication.java
index 9e47b65..bada2b9 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/SetupApplication.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/SetupApplication.java
@@ -46,8 +46,8 @@ import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CallbackConfigu
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.IccConfiguration;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.SootIntegrationMode;
 import soot.jimple.infoflow.android.callbacks.AbstractCallbackAnalyzer;
-import soot.jimple.infoflow.android.callbacks.CallbackDefinition;
-import soot.jimple.infoflow.android.callbacks.CallbackDefinition.CallbackType;
+import soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition;
+import soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition.CallbackType;
 import soot.jimple.infoflow.android.callbacks.DefaultCallbackAnalyzer;
 import soot.jimple.infoflow.android.callbacks.FastCallbackAnalyzer;
 import soot.jimple.infoflow.android.callbacks.filters.AlienFragmentFilter;
@@ -61,7 +61,6 @@ import soot.jimple.infoflow.android.data.parsers.PermissionMethodParser;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointCreator;
 import soot.jimple.infoflow.android.entryPointCreators.components.ComponentEntryPointCollection;
 import soot.jimple.infoflow.android.iccta.IccInstrumenter;
-import soot.jimple.infoflow.android.iccta.IccResults;
 import soot.jimple.infoflow.android.manifest.ProcessManifest;
 import soot.jimple.infoflow.android.resources.ARSCFileParser;
 import soot.jimple.infoflow.android.resources.ARSCFileParser.AbstractResource;
@@ -92,9 +91,9 @@ import soot.jimple.infoflow.rifl.RIFLSourceSinkDefinitionProvider;
 import soot.jimple.infoflow.solver.cfg.IInfoflowCFG;
 import soot.jimple.infoflow.solver.memory.IMemoryManager;
 import soot.jimple.infoflow.solver.memory.IMemoryManagerFactory;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinitionProvider;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.manager.ISourceSinkManager;
 import soot.jimple.infoflow.taintWrappers.ITaintPropagationWrapper;
 import soot.jimple.infoflow.taintWrappers.ITaintWrapperDataFlowAnalysis;
@@ -109,7 +108,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 	private final Logger logger = LoggerFactory.getLogger(getClass());
 
 	protected ISourceSinkDefinitionProvider sourceSinkProvider;
-	protected MultiMap<SootClass, CallbackDefinition> callbackMethods = new HashMultiMap<>();
+	protected MultiMap<SootClass, AndroidCallbackDefinition> callbackMethods = new HashMultiMap<>();
 	protected MultiMap<SootClass, SootClass> fragmentClasses = new HashMultiMap<>();
 
 	protected InfoflowAndroidConfiguration config = new InfoflowAndroidConfiguration();
@@ -287,7 +286,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 	 * 
 	 * @return The set of sinks loaded into FlowDroid
 	 */
-	public Set<SourceSinkDefinition> getSinks() {
+	public Set<? extends ISourceSinkDefinition> getSinks() {
 		return this.sourceSinkProvider == null ? null : this.sourceSinkProvider.getSinks();
 	}
 
@@ -311,7 +310,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 			return;
 		}
 		logger.info("Sinks:");
-		for (SourceSinkDefinition am : getSinks()) {
+		for (ISourceSinkDefinition am : getSinks()) {
 			logger.info(String.format("- %s", am.toString()));
 		}
 		logger.info("End of Sinks");
@@ -323,7 +322,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 	 * 
 	 * @return The set of sources loaded into FlowDroid
 	 */
-	public Set<SourceSinkDefinition> getSources() {
+	public Set<? extends ISourceSinkDefinition> getSources() {
 		return this.sourceSinkProvider == null ? null : this.sourceSinkProvider.getSources();
 	}
 
@@ -347,7 +346,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 			return;
 		}
 		logger.info("Sources:");
-		for (SourceSinkDefinition am : getSources()) {
+		for (ISourceSinkDefinition am : getSources()) {
 			logger.info(String.format("- %s", am.toString()));
 		}
 		logger.info("End of Sources");
@@ -410,11 +409,21 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 	 *                                be read.
 	 */
 	protected void parseAppResources() throws IOException, XmlPullParserException {
-		final String targetAPK = config.getAnalysisFileConfig().getTargetAPKFile();
+		final File targetAPK = new File(config.getAnalysisFileConfig().getTargetAPKFile());
+		if (!targetAPK.exists())
+			throw new RuntimeException(
+					String.format("Target APK file %s does not exist", targetAPK.getCanonicalPath()));
+
+		// Parse the resource file
+		long beforeARSC = System.nanoTime();
+		this.resources = new ARSCFileParser();
+		this.resources.parse(targetAPK.getAbsolutePath());
+		logger.info("ARSC file parsing took " + (System.nanoTime() - beforeARSC) / 1E9 + " seconds");
 
 		// To look for callbacks, we need to start somewhere. We use the Android
 		// lifecycle methods for this purpose.
-		this.manifest = new ProcessManifest(targetAPK);
+		this.manifest = new ProcessManifest(targetAPK, resources);
+		SystemClassHandler.v().setExcludeSystemComponents(config.getIgnoreFlowsInSystemPackages());
 		Set<String> entryPoints = manifest.getEntryPointClasses();
 		this.entrypoints = new HashSet<>(entryPoints.size());
 		for (String className : entryPoints) {
@@ -422,12 +431,6 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 			if (sc != null)
 				this.entrypoints.add(sc);
 		}
-
-		// Parse the resource file
-		long beforeARSC = System.nanoTime();
-		this.resources = new ARSCFileParser();
-		this.resources.parse(targetAPK);
-		logger.info("ARSC file parsing took " + (System.nanoTime() - beforeARSC) / 1E9 + " seconds");
 	}
 
 	/**
@@ -489,7 +492,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 
 		if (this.sourceSinkProvider != null) {
 			// Get the callbacks for the current entry point
-			Set<CallbackDefinition> callbacks;
+			Set<AndroidCallbackDefinition> callbacks;
 			if (entryPoint == null)
 				callbacks = this.callbackMethods.values();
 			else
@@ -518,7 +521,8 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 	 * @param callbacks The callbacks that have been collected so far
 	 * @return The new source sink manager
 	 */
-	protected ISourceSinkManager createSourceSinkManager(LayoutFileParser lfp, Set<CallbackDefinition> callbacks) {
+	protected ISourceSinkManager createSourceSinkManager(LayoutFileParser lfp,
+			Set<AndroidCallbackDefinition> callbacks) {
 		AccessPathBasedSourceSinkManager sourceSinkManager = new AccessPathBasedSourceSinkManager(
 				this.sourceSinkProvider.getSources(), this.sourceSinkProvider.getSinks(), callbacks, config,
 				lfp == null ? null : lfp.getUserControlsByID());
@@ -741,8 +745,9 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 		// the host activity
 		AlienFragmentFilter fragmentFilter = new AlienFragmentFilter(invertMap(fragmentClasses));
 		fragmentFilter.reset();
-		for (Iterator<Pair<SootClass, CallbackDefinition>> cbIt = this.callbackMethods.iterator(); cbIt.hasNext();) {
-			Pair<SootClass, CallbackDefinition> pair = cbIt.next();
+		for (Iterator<Pair<SootClass, AndroidCallbackDefinition>> cbIt = this.callbackMethods.iterator(); cbIt
+				.hasNext();) {
+			Pair<SootClass, AndroidCallbackDefinition> pair = cbIt.next();
 
 			// Check whether the filter accepts the given mapping
 			if (!fragmentFilter.accepts(pair.getO1(), pair.getO2().getTargetMethod()))
@@ -882,8 +887,8 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 							while (true) {
 								SootMethod callbackMethod = currentClass.getMethodUnsafe(subSig);
 								if (callbackMethod != null) {
-									if (this.callbackMethods.put(callbackClass,
-											new CallbackDefinition(callbackMethod, smViewOnClick, CallbackType.Widget)))
+									if (this.callbackMethods.put(callbackClass, new AndroidCallbackDefinition(
+											callbackMethod, smViewOnClick, CallbackType.Widget)))
 										hasNewCallback = true;
 									break;
 								}
@@ -912,7 +917,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 					Set<AndroidLayoutControl> controls = lfp.getUserControls().get(layoutFileName);
 					if (controls != null) {
 						for (AndroidLayoutControl lc : controls) {
-							if (!SystemClassHandler.isClassInSystemPackage(lc.getViewClass().getName()))
+							if (!SystemClassHandler.v().isClassInSystemPackage(lc.getViewClass().getName()))
 								registerCallbackMethodsForView(callbackClass, lc);
 						}
 					}
@@ -987,7 +992,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 	 */
 	private void registerCallbackMethodsForView(SootClass callbackClass, AndroidLayoutControl lc) {
 		// Ignore system classes
-		if (SystemClassHandler.isClassInSystemPackage(callbackClass.getName()))
+		if (SystemClassHandler.v().isClassInSystemPackage(callbackClass.getName()))
 			return;
 
 		// Get common Android classes
@@ -1018,7 +1023,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 				if (parentMethod != null)
 					// This is a real callback method
 					this.callbackMethods.put(callbackClass,
-							new CallbackDefinition(sm, parentMethod, CallbackType.Widget));
+							new AndroidCallbackDefinition(sm, parentMethod, CallbackType.Widget));
 			}
 		}
 	}
@@ -1102,12 +1107,16 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 		else
 			Options.v().set_android_jars(androidJar);
 		Options.v().set_src_prec(Options.src_prec_apk_class_jimple);
-		Options.v().set_keep_line_number(false);
 		Options.v().set_keep_offset(false);
+		Options.v().set_keep_line_number(config.getEnableLineNumbers());
 		Options.v().set_throw_analysis(Options.throw_analysis_dalvik);
 		Options.v().set_process_multiple_dex(config.getMergeDexFiles());
 		Options.v().set_ignore_resolution_errors(true);
 
+		// Set soot phase option if original names should be used
+		if (config.getEnableOriginalNames())
+			Options.v().setPhaseOption("jb", "use-original-names:true");
+
 		// Set the Soot configuration options. Note that this will needs to be
 		// done before we compute the classpath.
 		if (sootConfig != null)
@@ -1127,10 +1136,14 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 		// Patch the callgraph to support additional edges. We do this now,
 		// because during callback discovery, the context-insensitive callgraph
 		// algorithm would flood us with invalid edges.
-		LibraryClassPatcher patcher = new LibraryClassPatcher();
+		LibraryClassPatcher patcher = getLibraryClassPatcher();
 		patcher.patchLibraries();
 	}
 
+	protected LibraryClassPatcher getLibraryClassPatcher() {
+		return new LibraryClassPatcher();
+	}
+
 	/**
 	 * Configures the callgraph options for Soot according to FlowDroid's settings
 	 */
@@ -1184,7 +1197,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 	 * @author Steven Arzt
 	 *
 	 */
-	protected static class InPlaceInfoflow extends Infoflow implements IInPlaceInfoflow {
+	protected class InPlaceInfoflow extends Infoflow implements IInPlaceInfoflow {
 
 		/**
 		 * Creates a new instance of the Infoflow class for analyzing Android APK files.
@@ -1215,6 +1228,12 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 			super.runAnalysis(sourcesSinks);
 		}
 
+		@Override
+		protected boolean isUserCodeClass(String className) {
+			String packageName = manifest.getPackageName() + ".";
+			return super.isUserCodeClass(className) || className.startsWith(packageName);
+		}
+
 	}
 
 	/**
@@ -1256,8 +1275,8 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 	 */
 	public InfoflowResults runInfoflow(Set<AndroidMethod> sources, Set<AndroidMethod> sinks)
 			throws IOException, XmlPullParserException {
-		final Set<SourceSinkDefinition> sourceDefs = new HashSet<>(sources.size());
-		final Set<SourceSinkDefinition> sinkDefs = new HashSet<>(sinks.size());
+		final Set<ISourceSinkDefinition> sourceDefs = new HashSet<>(sources.size());
+		final Set<ISourceSinkDefinition> sinkDefs = new HashSet<>(sinks.size());
 
 		for (AndroidMethod am : sources)
 			sourceDefs.add(new MethodSourceSinkDefinition(am));
@@ -1267,18 +1286,18 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 		ISourceSinkDefinitionProvider parser = new ISourceSinkDefinitionProvider() {
 
 			@Override
-			public Set<SourceSinkDefinition> getSources() {
+			public Set<ISourceSinkDefinition> getSources() {
 				return sourceDefs;
 			}
 
 			@Override
-			public Set<SourceSinkDefinition> getSinks() {
+			public Set<ISourceSinkDefinition> getSinks() {
 				return sinkDefs;
 			}
 
 			@Override
-			public Set<SourceSinkDefinition> getAllMethods() {
-				Set<SourceSinkDefinition> sourcesSinks = new HashSet<>(sourceDefs.size() + sinkDefs.size());
+			public Set<ISourceSinkDefinition> getAllMethods() {
+				Set<ISourceSinkDefinition> sourcesSinks = new HashSet<>(sourceDefs.size() + sinkDefs.size());
 				sourcesSinks.addAll(sourceDefs);
 				sourcesSinks.addAll(sinkDefs);
 				return sourcesSinks;
@@ -1370,8 +1389,8 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 		try {
 			parseAppResources();
 		} catch (IOException | XmlPullParserException e) {
-			logger.error("Callgraph construction failed", e);
-			throw new RuntimeException("Callgraph construction failed", e);
+			logger.error("Parse app resource failed", e);
+			throw new RuntimeException("Parse app resource failed", e);
 		}
 
 		MultiRunResultAggregator resultAggregator = new MultiRunResultAggregator();
@@ -1434,8 +1453,8 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 		logger.info(
 				String.format("Collecting callbacks and building a callgraph took %d seconds", (int) callbackDuration));
 
-		final Set<SourceSinkDefinition> sources = getSources();
-		final Set<SourceSinkDefinition> sinks = getSinks();
+		final Set<? extends ISourceSinkDefinition> sources = getSources();
+		final Set<? extends ISourceSinkDefinition> sinks = getSinks();
 		final String apkFileLocation = config.getAnalysisFileConfig().getTargetAPKFile();
 		if (config.getOneComponentAtATime())
 			logger.info("Running data flow analysis on {} (component {}/{}: {}) with {} sources and {} sinks...",
@@ -1478,6 +1497,8 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 			InfoflowResults lastResults = resultAggregator.getLastResults();
 			if (lastResults != null) {
 				InfoflowPerformanceData perfData = lastResults.getPerformanceData();
+				if (perfData == null)
+					lastResults.setPerformanceData(perfData = new InfoflowPerformanceData());
 				perfData.setCallgraphConstructionSeconds((int) callbackDuration);
 				perfData.setTotalRuntimeSeconds((int) Math.round((System.nanoTime() - beforeEntryPoint) / 1E9));
 			}
@@ -1498,7 +1519,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 	 * @param results The data flow results to write out
 	 * @param cfg     The control flow graph to use for writing out the results
 	 */
-	private void serializeResults(InfoflowResults results, IInfoflowCFG cfg) {
+	protected void serializeResults(InfoflowResults results, IInfoflowCFG cfg) {
 		String resultsFile = config.getAnalysisFileConfig().getOutputFile();
 		if (resultsFile != null && !resultsFile.isEmpty()) {
 			InfoflowResultsSerializer serializer = new InfoflowResultsSerializer(cfg, config);
@@ -1565,8 +1586,10 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 			public InfoflowResults onResultsAvailable(InfoflowResults results, IInfoflowCFG cfg) {
 				// Purify the ICC results if requested
 				final IccConfiguration iccConfig = config.getIccConfig();
-				if (iccConfig.isIccResultsPurifyEnabled())
-					results = IccResults.clean(cfg, results);
+				if (iccConfig.isIccResultsPurifyEnabled()) {
+					// no-op at the moment. We used to have a purifier here, but it didn't make
+					// any sense. Removed it for the better.
+				}
 
 				return results;
 			}
@@ -1604,7 +1627,7 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 		// If we we already have an entry point creator, we make sure to clean up our
 		// leftovers from previous runs
 		if (entryPointCreator == null)
-			entryPointCreator = new AndroidEntryPointCreator(manifest, components);
+			entryPointCreator = createEntryPointCreator(components);
 		else {
 			entryPointCreator.removeGeneratedMethods(false);
 			entryPointCreator.reset();
@@ -1614,17 +1637,17 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 		if (component == null) {
 			// Get all callbacks for all components
 			for (SootClass sc : this.callbackMethods.keySet()) {
-				Set<CallbackDefinition> callbackDefs = this.callbackMethods.get(sc);
+				Set<AndroidCallbackDefinition> callbackDefs = this.callbackMethods.get(sc);
 				if (callbackDefs != null)
-					for (CallbackDefinition cd : callbackDefs)
+					for (AndroidCallbackDefinition cd : callbackDefs)
 						callbackMethodSigs.put(sc, cd.getTargetMethod());
 			}
 		} else {
 			// Get the callbacks for the current component only
 			for (SootClass sc : components) {
-				Set<CallbackDefinition> callbackDefs = this.callbackMethods.get(sc);
+				Set<AndroidCallbackDefinition> callbackDefs = this.callbackMethods.get(sc);
 				if (callbackDefs != null)
-					for (CallbackDefinition cd : callbackDefs)
+					for (AndroidCallbackDefinition cd : callbackDefs)
 						callbackMethodSigs.put(sc, cd.getTargetMethod());
 			}
 		}
@@ -1634,6 +1657,17 @@ public class SetupApplication implements ITaintWrapperDataFlowAnalysis {
 		return entryPointCreator;
 	}
 
+	/**
+	 * Creates a new instance of the entry point creator
+	 * 
+	 * @param components The components for which the entry point creator shallk be
+	 *                   responsible
+	 * @return The new instance of the entry point creator
+	 */
+	protected AndroidEntryPointCreator createEntryPointCreator(Set<SootClass> components) {
+		return new AndroidEntryPointCreator(manifest, components);
+	}
+
 	/**
 	 * Gets the components to analyze. If the given component is not null, we assume
 	 * that only this component and the application class (if any) shall be
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/axml/ApkHandler.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/axml/ApkHandler.java
index 9c84625..53ad857 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/axml/ApkHandler.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/axml/ApkHandler.java
@@ -25,7 +25,7 @@ import com.google.common.io.Files;
  * 
  * @author Stefan Haas, Mario Schlipf
  */
-public class ApkHandler {
+public class ApkHandler implements AutoCloseable {
 
 	private final Logger logger = LoggerFactory.getLogger(getClass());
 
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/AbstractCallbackAnalyzer.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/AbstractCallbackAnalyzer.java
index 9b4a286..cca35bb 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/AbstractCallbackAnalyzer.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/AbstractCallbackAnalyzer.java
@@ -4,7 +4,7 @@
  * are made available under the terms of the GNU Lesser Public License v2.1
  * which accompanies this distribution, and is available at
  * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
- * 
+ *
  * Contributors: Christian Fritz, Steven Arzt, Siegfried Rasthofer, Eric
  * Bodden, and others.
  ******************************************************************************/
@@ -48,7 +48,7 @@ import soot.jimple.ReturnStmt;
 import soot.jimple.ReturnVoidStmt;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
-import soot.jimple.infoflow.android.callbacks.CallbackDefinition.CallbackType;
+import soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition.CallbackType;
 import soot.jimple.infoflow.android.callbacks.filters.ICallbackFilter;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointConstants;
 import soot.jimple.infoflow.android.source.parsers.xml.ResourceUtils;
@@ -64,7 +64,7 @@ import soot.util.MultiMap;
 /**
  * Analyzes the classes in the APK file to find custom implementations of the
  * well-known Android callback and handler interfaces.
- * 
+ *
  * @author Steven Arzt
  *
  */
@@ -96,7 +96,7 @@ public abstract class AbstractCallbackAnalyzer {
 	protected final Set<SootClass> entryPointClasses;
 	protected final Set<String> androidCallbacks;
 
-	protected final MultiMap<SootClass, CallbackDefinition> callbackMethods = new HashMultiMap<>();
+	protected final MultiMap<SootClass, AndroidCallbackDefinition> callbackMethods = new HashMultiMap<>();
 	protected final MultiMap<SootClass, Integer> layoutClasses = new HashMultiMap<>();
 	protected final Set<SootClass> dynamicManifestComponents = new HashSet<>();
 	protected final MultiMap<SootClass, SootClass> fragmentClasses = new HashMultiMap<>();
@@ -137,7 +137,7 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Loads the set of interfaces that are used to implement Android callback
 	 * handlers from a file on disk
-	 * 
+	 *
 	 * @param androidCallbackFile The file from which to load the callback
 	 *                            definitions
 	 * @return A set containing the names of the interfaces that are used to
@@ -158,7 +158,7 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Loads the set of interfaces that are used to implement Android callback
 	 * handlers from a file on disk
-	 * 
+	 *
 	 * @param reader A file reader
 	 * @return A set containing the names of the interfaces that are used to
 	 *         implement Android callback handlers
@@ -190,14 +190,14 @@ public abstract class AbstractCallbackAnalyzer {
 
 	/**
 	 * Analyzes the given method and looks for callback registrations
-	 * 
+	 *
 	 * @param lifecycleElement The lifecycle element (activity, etc.) with which to
 	 *                         associate the found callbacks
 	 * @param method           The method in which to look for callbacks
 	 */
 	protected void analyzeMethodForCallbackRegistrations(SootClass lifecycleElement, SootMethod method) {
 		// Do not analyze system classes
-		if (SystemClassHandler.isClassInSystemPackage(method.getDeclaringClass().getName()))
+		if (SystemClassHandler.v().isClassInSystemPackage(method.getDeclaringClass().getName()))
 			return;
 		if (!method.isConcrete())
 			return;
@@ -212,6 +212,8 @@ public abstract class AbstractCallbackAnalyzer {
 
 				final SootMethodRef mref = iinv.getMethodRef();
 				for (int i = 0; i < iinv.getArgCount(); i++) {
+                    if (i >= mref.getParameterTypes().size()) // workaround to bypass wrong code translation e.g. onDismiss()(null)
+						break;
 					final Type type = mref.getParameterType(i);
 					if (!(type instanceof RefType))
 						continue;
@@ -221,9 +223,9 @@ public abstract class AbstractCallbackAnalyzer {
 
 						// This call must be to a system API in order to
 						// register an OS-level callback
-						if (!SystemClassHandler.isClassInSystemPackage(iinv.getMethod().getDeclaringClass().getName()))
+						if (!SystemClassHandler.v()
+								.isClassInSystemPackage(iinv.getMethod().getDeclaringClass().getName()))
 							continue;
-
 						// We have a formal parameter type that corresponds to one of the Android
 						// callback interfaces. Look for definitions of the parameter to estimate the
 						// actual type.
@@ -242,7 +244,7 @@ public abstract class AbstractCallbackAnalyzer {
 								}
 
 								SootClass targetClass = baseType.getSootClass();
-								if (!SystemClassHandler.isClassInSystemPackage(targetClass.getName()))
+								if (!SystemClassHandler.v().isClassInSystemPackage(targetClass.getName()))
 									callbackClasses.add(targetClass);
 							}
 
@@ -261,7 +263,7 @@ public abstract class AbstractCallbackAnalyzer {
 								}
 
 								SootClass targetClass = baseType.getSootClass();
-								if (!SystemClassHandler.isClassInSystemPackage(targetClass.getName()))
+								if (!SystemClassHandler.v().isClassInSystemPackage(targetClass.getName()))
 									callbackClasses.add(targetClass);
 							}
 						}
@@ -278,7 +280,7 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Checks whether all filters accept the association between the callback class
 	 * and its parent component
-	 * 
+	 *
 	 * @param lifecycleElement The hosting component's class
 	 * @param targetClass      The class implementing the callbacks
 	 * @return True if all filters accept the given component-callback mapping,
@@ -294,7 +296,7 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Checks whether all filters accept the association between the callback method
 	 * and its parent component
-	 * 
+	 *
 	 * @param lifecycleElement The hosting component's class
 	 * @param targetMethod     The method implementing the callback
 	 * @return True if all filters accept the given component-callback mapping,
@@ -310,12 +312,12 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Checks whether the given method dynamically registers a new broadcast
 	 * receiver
-	 * 
+	 *
 	 * @param method The method to check
 	 */
 	protected void analyzeMethodForDynamicBroadcastReceiver(SootMethod method) {
 		// Do not analyze system classes
-		if (SystemClassHandler.isClassInSystemPackage(method.getDeclaringClass().getName()))
+		if (SystemClassHandler.v().isClassInSystemPackage(method.getDeclaringClass().getName()))
 			return;
 		if (!method.isConcrete() || !method.hasActiveBody())
 			return;
@@ -332,7 +334,7 @@ public abstract class AbstractCallbackAnalyzer {
 					Value br = iexpr.getArg(0);
 					if (br.getType() instanceof RefType) {
 						RefType rt = (RefType) br.getType();
-						if (!SystemClassHandler.isClassInSystemPackage(rt.getSootClass().getName()))
+						if (!SystemClassHandler.v().isClassInSystemPackage(rt.getSootClass().getName()))
 							dynamicManifestComponents.add(rt.getSootClass());
 					}
 				}
@@ -343,12 +345,12 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Checks whether the given method dynamically registers a new service
 	 * connection
-	 * 
+	 *
 	 * @param method The method to check
 	 */
 	protected void analyzeMethodForServiceConnection(SootMethod method) {
 		// Do not analyze system classes
-		if (SystemClassHandler.isClassInSystemPackage(method.getDeclaringClass().getName()))
+		if (SystemClassHandler.v().isClassInSystemPackage(method.getDeclaringClass().getName()))
 			return;
 		if (!method.isConcrete() || !method.hasActiveBody())
 			return;
@@ -367,7 +369,7 @@ public abstract class AbstractCallbackAnalyzer {
 						for (Type tp : pts.possibleTypes()) {
 							if (tp instanceof RefType) {
 								RefType rt = (RefType) tp;
-								if (!SystemClassHandler.isClassInSystemPackage(rt.getSootClass().getName()))
+								if (!SystemClassHandler.v().isClassInSystemPackage(rt.getSootClass().getName()))
 									dynamicManifestComponents.add(rt.getSootClass());
 							}
 						}
@@ -376,7 +378,7 @@ public abstract class AbstractCallbackAnalyzer {
 					// Just to be sure, also add the declared type
 					if (br.getType() instanceof RefType) {
 						RefType rt = (RefType) br.getType();
-						if (!SystemClassHandler.isClassInSystemPackage(rt.getSootClass().getName()))
+						if (!SystemClassHandler.v().isClassInSystemPackage(rt.getSootClass().getName()))
 							dynamicManifestComponents.add(rt.getSootClass());
 					}
 				}
@@ -387,7 +389,7 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Checks whether the given method executes a fragment transaction that creates
 	 * new fragment
-	 * 
+	 *
 	 * @author Goran Piskachev
 	 * @param method The method to check
 	 */
@@ -467,10 +469,10 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Check whether a method registers a FragmentStatePagerAdapter to a ViewPager.
 	 * This pattern is very common for tabbed apps.
-	 * 
+	 *
 	 * @param clazz
 	 * @param method
-	 * 
+	 *
 	 * @author Julius Naeumann
 	 */
 	protected void analyzeMethodForViewPagers(SootClass clazz, SootMethod method) {
@@ -534,9 +536,10 @@ public abstract class AbstractCallbackAnalyzer {
 				if (getItemUnit instanceof ReturnStmt) {
 					ReturnStmt rs = (ReturnStmt) getItemUnit;
 					Value rv = rs.getOp();
-
-					checkAndAddFragment(method.getDeclaringClass(), ((RefType) rv.getType()).getSootClass());
-
+					Type type = rv.getType();
+					if (type instanceof RefType) {
+						checkAndAddFragment(method.getDeclaringClass(), ((RefType) type).getSootClass());
+					}
 				}
 			}
 		}
@@ -545,7 +548,7 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Gets whether the call in the given statement can end up in the respective
 	 * method inherited from one of the given classes.
-	 * 
+	 *
 	 * @param stmt       The statement containing the call sites
 	 * @param classNames The base classes in which the call can potentially end up
 	 * @return True if the given call can end up in a method inherited from one of
@@ -577,7 +580,7 @@ public abstract class AbstractCallbackAnalyzer {
 
 	/**
 	 * Checks whether this invocation calls Android's Activity.setContentView method
-	 * 
+	 *
 	 * @param inv The invocaton to check
 	 * @return True if this invocation calls setContentView, otherwise false
 	 */
@@ -605,7 +608,7 @@ public abstract class AbstractCallbackAnalyzer {
 
 	/**
 	 * Checks whether this invocation calls Android's LayoutInflater.inflate method
-	 * 
+	 *
 	 * @param inv The invocaton to check
 	 * @return True if this invocation calls inflate, otherwise false
 	 */
@@ -636,7 +639,8 @@ public abstract class AbstractCallbackAnalyzer {
 			return;
 
 		// Do not start the search in system classes
-		if (config.getIgnoreFlowsInSystemPackages() && SystemClassHandler.isClassInSystemPackage(sootClass.getName()))
+		if (config.getIgnoreFlowsInSystemPackages()
+				&& SystemClassHandler.v().isClassInSystemPackage(sootClass.getName()))
 			return;
 
 		// There are also some classes that implement interesting callback
@@ -645,7 +649,7 @@ public abstract class AbstractCallbackAnalyzer {
 		// Android OS class, we treat it as a potential callback.
 		Map<String, SootMethod> systemMethods = new HashMap<>(10000);
 		for (SootClass parentClass : Scene.v().getActiveHierarchy().getSuperclassesOf(sootClass)) {
-			if (SystemClassHandler.isClassInSystemPackage(parentClass.getName()))
+			if (SystemClassHandler.v().isClassInSystemPackage(parentClass.getName()))
 				for (SootMethod sm : parentClass.getMethods())
 					if (!sm.isConstructor())
 						systemMethods.put(sm.getSubSignature(), sm);
@@ -654,7 +658,7 @@ public abstract class AbstractCallbackAnalyzer {
 		// Iterate over all user-implemented methods. If they are inherited
 		// from a system class, they are callback candidates.
 		for (SootClass parentClass : Scene.v().getActiveHierarchy().getSubclassesOfIncluding(sootClass)) {
-			if (SystemClassHandler.isClassInSystemPackage(parentClass.getName()))
+			if (SystemClassHandler.v().isClassInSystemPackage(parentClass.getName()))
 				continue;
 			for (SootMethod method : parentClass.getMethods()) {
 				if (!method.hasTag(SimulatedCodeElementTag.TAG_NAME)) {
@@ -677,16 +681,16 @@ public abstract class AbstractCallbackAnalyzer {
 		return null;
 	}
 
-	private void analyzeClassInterfaceCallbacks(SootClass baseClass, SootClass sootClass, SootClass lifecycleElement) {
+	protected void analyzeClassInterfaceCallbacks(SootClass baseClass, SootClass sootClass, SootClass lifecycleElement) {
 		// We cannot create instances of abstract classes anyway, so there is no
 		// reason to look for interface implementations
 		if (!baseClass.isConcrete())
 			return;
 
 		// Do not analyze system classes
-		if (SystemClassHandler.isClassInSystemPackage(baseClass.getName()))
+		if (SystemClassHandler.v().isClassInSystemPackage(baseClass.getName()))
 			return;
-		if (SystemClassHandler.isClassInSystemPackage(sootClass.getName()))
+		if (SystemClassHandler.v().isClassInSystemPackage(sootClass.getName()))
 			return;
 
 		// Check the filters
@@ -703,21 +707,36 @@ public abstract class AbstractCallbackAnalyzer {
 
 		// Do we implement one of the well-known interfaces?
 		for (SootClass i : collectAllInterfaces(sootClass)) {
-			if (androidCallbacks.contains(i.getName())) {
-				CallbackType callbackType = isUICallback(i) ? CallbackType.Widget : CallbackType.Default;
+			this.checkAndAddCallback(i, baseClass, lifecycleElement);
+		}
+		for (SootClass c : collectAllSuperClasses(sootClass)) {
+			this.checkAndAddCallback(c, baseClass, lifecycleElement);
+		}
+	}
 
-				for (SootMethod sm : i.getMethods()) {
-					SootMethod callbackImplementation = getMethodFromHierarchyEx(baseClass, sm.getSubSignature());
-					if (callbackImplementation != null)
-						checkAndAddMethod(callbackImplementation, sm, lifecycleElement, callbackType);
-				}
+	/**
+	 * Checks if the given class/interface appears in android Callbacks. If yes, add
+	 * callback method to the list of callback methods
+	 *
+	 * @param sc               the class/interface to check for existence in
+	 *                         AndroidCallbacks
+	 * @param baseClass        the class implementing/extending sc
+	 * @param lifecycleElement the component to which the callback method belongs
+	 */
+	private void checkAndAddCallback(SootClass sc, SootClass baseClass, SootClass lifecycleElement) {
+		if (androidCallbacks.contains(sc.getName())) {
+			CallbackType callbackType = isUICallback(sc) ? CallbackType.Widget : CallbackType.Default;
+			for (SootMethod sm : sc.getMethods()) {
+				SootMethod callbackImplementation = getMethodFromHierarchyEx(baseClass, sm.getSubSignature());
+				if (callbackImplementation != null)
+					checkAndAddMethod(callbackImplementation, sm, lifecycleElement, callbackType);
 			}
 		}
 	}
 
 	/**
 	 * Gets whether the given callback interface or class represents a UI callback
-	 * 
+	 *
 	 * @param i The callback interface or class to check
 	 * @return True if the given callback interface or class represents a UI
 	 *         callback, otherwise false
@@ -730,7 +749,7 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Checks whether the given Soot method comes from a system class. If not, it is
 	 * added to the list of callback methods.
-	 * 
+	 *
 	 * @param method         The method to check and add
 	 * @param parentMethod   The original method in the Android framework that
 	 *                       declared the callback. This can, for example, be the
@@ -744,7 +763,7 @@ public abstract class AbstractCallbackAnalyzer {
 	protected boolean checkAndAddMethod(SootMethod method, SootMethod parentMethod, SootClass lifecycleClass,
 			CallbackType callbackType) {
 		// Do not call system methods
-		if (SystemClassHandler.isClassInSystemPackage(method.getDeclaringClass().getName()))
+		if (SystemClassHandler.v().isClassInSystemPackage(method.getDeclaringClass().getName()))
 			return false;
 
 		// Skip empty methods
@@ -761,12 +780,12 @@ public abstract class AbstractCallbackAnalyzer {
 		if (!filterAccepts(lifecycleClass, method))
 			return false;
 
-		return this.callbackMethods.put(lifecycleClass, new CallbackDefinition(method, parentMethod, callbackType));
+		return this.callbackMethods.put(lifecycleClass, new AndroidCallbackDefinition(method, parentMethod, callbackType));
 	}
 
 	/**
 	 * Registers a fragment that belongs to a given component
-	 * 
+	 *
 	 * @param componentClass The component (usually an activity) to which the
 	 *                       fragment belongs
 	 * @param fragmentClass  The fragment class
@@ -789,7 +808,16 @@ public abstract class AbstractCallbackAnalyzer {
 		return interfaces;
 	}
 
-	public MultiMap<SootClass, CallbackDefinition> getCallbackMethods() {
+	private Set<SootClass> collectAllSuperClasses(SootClass sootClass) {
+		Set<SootClass> classes = new HashSet<SootClass>();
+		if (sootClass.hasSuperclass()) {
+			classes.add(sootClass.getSuperclass());
+			classes.addAll(collectAllSuperClasses(sootClass.getSuperclass()));
+		}
+		return classes;
+	}
+
+	public MultiMap<SootClass, AndroidCallbackDefinition> getCallbackMethods() {
 		return this.callbackMethods;
 	}
 
@@ -808,7 +836,7 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Adds a new filter that checks every callback before it is associated with the
 	 * respective host component
-	 * 
+	 *
 	 * @param filter The filter to add
 	 */
 	public void addCallbackFilter(ICallbackFilter filter) {
@@ -818,7 +846,7 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Excludes an entry point from all further processing. No more callbacks will
 	 * be collected for the given entry point
-	 * 
+	 *
 	 * @param entryPoint The entry point to exclude
 	 */
 	public void excludeEntryPoint(SootClass entryPoint) {
@@ -827,7 +855,7 @@ public abstract class AbstractCallbackAnalyzer {
 
 	/**
 	 * Checks whether the given class is an excluded entry point
-	 * 
+	 *
 	 * @param entryPoint The entry point to check
 	 * @return True if the given class is an excluded entry point, otherwise false
 	 */
@@ -838,7 +866,7 @@ public abstract class AbstractCallbackAnalyzer {
 	/**
 	 * Sets the provider that shall be used for obtaining constant values during the
 	 * callback analysis
-	 * 
+	 *
 	 * @param valueProvider The value provider to use
 	 */
 	public void setValueProvider(IValueProvider valueProvider) {
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/CallbackDefinition.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/AndroidCallbackDefinition.java
similarity index 65%
rename from soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/CallbackDefinition.java
rename to soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/AndroidCallbackDefinition.java
index 581e76f..d3a76f9 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/CallbackDefinition.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/AndroidCallbackDefinition.java
@@ -1,6 +1,7 @@
 package soot.jimple.infoflow.android.callbacks;
 
 import soot.SootMethod;
+import soot.jimple.infoflow.callbacks.CallbackDefinition;
 
 /**
  * Data class that represents a single Android callback
@@ -8,8 +9,8 @@ import soot.SootMethod;
  * @author Steven Arzt
  *
  */
-public class CallbackDefinition {
-	
+public class AndroidCallbackDefinition extends CallbackDefinition {
+
 	/**
 	 * Enumeration containing the possible types of callbacks
 	 * 
@@ -21,50 +22,31 @@ public class CallbackDefinition {
 		 * The callback is on a UI control, e.g., a button click handler
 		 */
 		Widget,
-		
+
 		/**
 		 * The callback is a normal method without special properties
 		 */
 		Default
 	}
-	
-	private final SootMethod targetMethod;
-	private final SootMethod parentMethod;
+
 	private final CallbackType callbackType;
-	
+
 	/**
-	 * Creates a new instance of the {@link CallbackDefinition} class
+	 * Creates a new instance of the {@link AndroidCallbackDefinition} class
+	 * 
 	 * @param targetMethod The callback method
-	 * @param parentMethod The parent method in the Android framework, e.g.,
-	 * in the callback interface method
+	 * @param parentMethod The parent method in the Android framework, e.g., in the
+	 *                     callback interface method
 	 * @param callbackType The type of callback, e.g., UI callback
 	 */
-	public CallbackDefinition(SootMethod targetMethod, SootMethod parentMethod, CallbackType callbackType) {
-		this.targetMethod = targetMethod;
-		this.parentMethod = parentMethod;
+	public AndroidCallbackDefinition(SootMethod targetMethod, SootMethod parentMethod, CallbackType callbackType) {
+		super(targetMethod, parentMethod);
 		this.callbackType = callbackType;
 	}
-	
-	/**
-	 * Gets the callback method represented by this data object
-	 * @return The callback method represented by this data object
-	 */
-	public SootMethod getTargetMethod() {
-		return this.targetMethod;
-	}
-	
-	/**
-	 * Gets the parent method in the Android framework that causes the target
-	 * method to be a callback. The parent is usually the method in the
-	 * framework's callback interface.
-	 * @return The parent method in the Android framework
-	 */
-	public SootMethod getParentMethod() {
-		return this.parentMethod;
-	}
-	
+
 	/**
 	 * Gets the type of callback, e.g., UI callback
+	 * 
 	 * @return The type of callback, e.g., UI callback
 	 */
 	public CallbackType getCallbackType() {
@@ -89,7 +71,7 @@ public class CallbackDefinition {
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		CallbackDefinition other = (CallbackDefinition) obj;
+		AndroidCallbackDefinition other = (AndroidCallbackDefinition) obj;
 		if (callbackType != other.callbackType)
 			return false;
 		if (targetMethod == null) {
@@ -104,10 +86,10 @@ public class CallbackDefinition {
 			return false;
 		return true;
 	}
-	
+
 	@Override
 	public String toString() {
 		return targetMethod.toString();
 	}
-	
+
 }
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/ComponentReachableMethods.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/ComponentReachableMethods.java
index 25ea6b2..a76c296 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/ComponentReachableMethods.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/ComponentReachableMethods.java
@@ -46,14 +46,12 @@ public class ComponentReachableMethods {
 	/**
 	 * Creates a new instance of the {@link MyReachableMethods} class
 	 * 
-	 * @param config
-	 *            The configuration of the data flow solver
-	 * @param originalComponent
-	 *            The original component or which we are looking for callback
-	 *            registrations. This information is used to more precisely model
-	 *            calls to abstract methods.
-	 * @param entryPoints
-	 *            The entry points from which to find the reachable methods
+	 * @param config            The configuration of the data flow solver
+	 * @param originalComponent The original component or which we are looking for
+	 *                          callback registrations. This information is used to
+	 *                          more precisely model calls to abstract methods.
+	 * @param entryPoints       The entry points from which to find the reachable
+	 *                          methods
 	 */
 	public ComponentReachableMethods(InfoflowAndroidConfiguration config, SootClass originalComponent,
 			Collection<MethodOrMethodContext> entryPoints) {
@@ -70,7 +68,7 @@ public class ComponentReachableMethods {
 
 	private void addMethod(MethodOrMethodContext m) {
 		// Filter out methods in system classes
-		if (!SystemClassHandler.isClassInSystemPackage(m.method().getDeclaringClass().getName())) {
+		if (!SystemClassHandler.v().isClassInSystemPackage(m.method().getDeclaringClass().getName())) {
 			if (set.add(m)) {
 				reachables.add(m);
 			}
@@ -109,7 +107,7 @@ public class ComponentReachableMethods {
 							// We do not expect callback registrations in
 							// any
 							// calls to system classes
-							if (SystemClassHandler.isClassInSystemPackage(refMethod.getDeclaringClass().getName()))
+							if (SystemClassHandler.v().isClassInSystemPackage(refMethod.getDeclaringClass().getName()))
 								return false;
 						}
 					} else if (config.getCallbackConfig().getFilterThreadCallbacks()) {
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/DefaultCallbackAnalyzer.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/DefaultCallbackAnalyzer.java
index a5aca30..37e126e 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/DefaultCallbackAnalyzer.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/callbacks/DefaultCallbackAnalyzer.java
@@ -22,7 +22,7 @@ import soot.Value;
 import soot.jimple.InvokeExpr;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
-import soot.jimple.infoflow.android.callbacks.CallbackDefinition.CallbackType;
+import soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition.CallbackType;
 import soot.jimple.infoflow.android.callbacks.filters.ICallbackFilter;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointConstants;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointUtils;
@@ -103,6 +103,7 @@ public class DefaultCallbackAnalyzer extends AbstractCallbackAnalyzer implements
 
 						// Check for method overrides
 						analyzeMethodOverrideCallbacks(sc);
+						analyzeClassInterfaceCallbacks(sc, sc, sc);
 					}
 					logger.info("Callback analysis done.");
 				} else {
@@ -131,6 +132,7 @@ public class DefaultCallbackAnalyzer extends AbstractCallbackAnalyzer implements
 
 						// Check for method overrides. The whole class might be new.
 						analyzeMethodOverrideCallbacks(componentClass);
+						analyzeClassInterfaceCallbacks(componentClass, componentClass, componentClass);
 
 						// Collect all methods that we need to analyze
 						List<MethodOrMethodContext> entryClasses = new ArrayList<>(callbacks.size());
@@ -203,7 +205,7 @@ public class DefaultCallbackAnalyzer extends AbstractCallbackAnalyzer implements
 			for (String sig : methods) {
 				SootMethod sm = currentClass.getMethodUnsafe(sig);
 				if (sm != null)
-					if (!SystemClassHandler.isClassInSystemPackage(sm.getDeclaringClass().getName()))
+					if (!SystemClassHandler.v().isClassInSystemPackage(sm.getDeclaringClass().getName()))
 						lifecycleMethods.add(sm);
 			}
 			currentClass = currentClass.hasSuperclass() ? currentClass.getSuperclass() : null;
@@ -271,7 +273,7 @@ public class DefaultCallbackAnalyzer extends AbstractCallbackAnalyzer implements
 			SootMethod sm = rmIterator.next().method();
 			if (!sm.isConcrete())
 				continue;
-			if (SystemClassHandler.isClassInSystemPackage(sm.getDeclaringClass().getName()))
+			if (SystemClassHandler.v().isClassInSystemPackage(sm.getDeclaringClass().getName()))
 				continue;
 
 			for (Unit u : sm.retrieveActiveBody().getUnits())
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/config/SootConfigForAndroid.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/config/SootConfigForAndroid.java
index d29e469..ea648e8 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/config/SootConfigForAndroid.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/config/SootConfigForAndroid.java
@@ -25,7 +25,7 @@ public class SootConfigForAndroid implements IInfoflowConfig {
 		List<String> excludeList = new LinkedList<String>();
 		excludeList.add("java.*");
 		excludeList.add("sun.*");
-		excludeList.add("android.*");
+		// excludeList.add("android.*"); //XXX: why do we exclude android
 		excludeList.add("org.apache.*");
 		excludeList.add("org.eclipse.*");
 		excludeList.add("soot.*");
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConfigurationParser.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConfigurationParser.java
index a8d9422..6bf4a75 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConfigurationParser.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConfigurationParser.java
@@ -19,20 +19,20 @@ import org.xml.sax.SAXException;
 import org.xml.sax.helpers.DefaultHandler;
 
 import soot.jimple.infoflow.InfoflowConfiguration;
+import soot.jimple.infoflow.InfoflowConfiguration.CallbackSourceMode;
+import soot.jimple.infoflow.InfoflowConfiguration.CategoryMode;
 import soot.jimple.infoflow.InfoflowConfiguration.ImplicitFlowMode;
+import soot.jimple.infoflow.InfoflowConfiguration.LayoutMatchingMode;
 import soot.jimple.infoflow.InfoflowConfiguration.PathConfiguration;
 import soot.jimple.infoflow.InfoflowConfiguration.PathReconstructionMode;
 import soot.jimple.infoflow.InfoflowConfiguration.SolverConfiguration;
+import soot.jimple.infoflow.InfoflowConfiguration.SourceSinkFilterMode;
 import soot.jimple.infoflow.InfoflowConfiguration.StaticFieldTrackingMode;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.AnalysisFileConfiguration;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CallbackConfiguration;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CallbackSourceMode;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CategoryMode;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.IccConfiguration;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.LayoutMatchingMode;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.SourceSinkConfiguration;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.SourceSinkFilterMode;
 import soot.jimple.infoflow.android.data.CategoryDefinition;
 import soot.jimple.infoflow.android.data.CategoryDefinition.CATEGORY;
 import soot.jimple.infoflow.android.source.parsers.xml.ResourceUtils;
@@ -210,6 +210,10 @@ public class XMLConfigurationParser {
 						config.setEnableArrayTracking(Boolean.valueOf(data));
 					else if (currentElement.equals(XMLConstants.TAG_ENABLE_REFLECTION))
 						config.setEnableReflection(Boolean.valueOf(data));
+					else if (currentElement.equals(XMLConstants.TAG_ENABLE_LINENUMBERS))
+						config.setEnableLineNumbers(Boolean.valueOf(data));
+					else if (currentElement.equals(XMLConstants.TAG_ENABLE_ORIGINALNAMES))
+						config.setEnableOriginalNames(Boolean.valueOf(data));
 					else if (currentElement.equals(XMLConstants.TAG_FLOW_SENSITIVE_ALIASING))
 						config.setFlowSensitiveAliasing(Boolean.valueOf(data));
 					else if (currentElement.equals(XMLConstants.TAG_LOG_SOURCES_AND_SINKS))
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConfigurationWriter.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConfigurationWriter.java
index 1a80981..0b5985f 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConfigurationWriter.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConfigurationWriter.java
@@ -19,14 +19,14 @@ import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 
 import soot.jimple.infoflow.InfoflowConfiguration;
+import soot.jimple.infoflow.InfoflowConfiguration.CategoryMode;
 import soot.jimple.infoflow.InfoflowConfiguration.PathConfiguration;
 import soot.jimple.infoflow.InfoflowConfiguration.SolverConfiguration;
+import soot.jimple.infoflow.InfoflowConfiguration.SourceSinkFilterMode;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CallbackConfiguration;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CategoryMode;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.IccConfiguration;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.SourceSinkConfiguration;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.SourceSinkFilterMode;
 import soot.jimple.infoflow.android.data.CategoryDefinition;
 
 /**
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConstants.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConstants.java
index 82f74c8..41b86d3 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConstants.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/config/XMLConstants.java
@@ -46,6 +46,8 @@ class XMLConstants {
 	public static final String TAG_ENABLE_EXCEPTIONS = "enableExceptions";
 	public static final String TAG_ENABLE_ARRAYS = "enableArrays";
 	public static final String TAG_ENABLE_REFLECTION = "enableReflection";
+	public static final String TAG_ENABLE_LINENUMBERS = "enableLineNumbers";
+	public static final String TAG_ENABLE_ORIGINALNAMES = "enableOriginalNames";
 	public static final String TAG_FLOW_SENSITIVE_ALIASING = "flowSensitiveAliasing";
 	public static final String TAG_LOG_SOURCES_AND_SINKS = "logSourcesAndSinks";
 	public static final String TAG_ENABLE_ARRAY_SIZE_TAINTING = "enableArraySizeTainting";
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/CSVPermissionMethodParser.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/CSVPermissionMethodParser.java
index 3200fd0..593fe22 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/CSVPermissionMethodParser.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/CSVPermissionMethodParser.java
@@ -22,9 +22,9 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import soot.jimple.infoflow.android.data.AndroidMethod;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinitionProvider;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 
 /**
@@ -38,9 +38,9 @@ public class CSVPermissionMethodParser implements ISourceSinkDefinitionProvider
 
 	private final Logger logger = LoggerFactory.getLogger(getClass());
 
-	private Set<SourceSinkDefinition> sourceList = null;
-	private Set<SourceSinkDefinition> sinkList = null;
-	private Set<SourceSinkDefinition> neitherList = null;
+	private Set<ISourceSinkDefinition> sourceList = null;
+	private Set<ISourceSinkDefinition> sinkList = null;
+	private Set<ISourceSinkDefinition> neitherList = null;
 
 	private static final int INITIAL_SET_SIZE = 10000;
 
@@ -51,9 +51,9 @@ public class CSVPermissionMethodParser implements ISourceSinkDefinitionProvider
 	}
 
 	public void parse() {
-		sourceList = new HashSet<SourceSinkDefinition>(INITIAL_SET_SIZE);
-		sinkList = new HashSet<SourceSinkDefinition>(INITIAL_SET_SIZE);
-		neitherList = new HashSet<SourceSinkDefinition>(INITIAL_SET_SIZE);
+		sourceList = new HashSet<>(INITIAL_SET_SIZE);
+		sinkList = new HashSet<>(INITIAL_SET_SIZE);
+		neitherList = new HashSet<>(INITIAL_SET_SIZE);
 
 		BufferedReader rdr = null;
 		try {
@@ -130,25 +130,25 @@ public class CSVPermissionMethodParser implements ISourceSinkDefinitionProvider
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSources() {
+	public Set<ISourceSinkDefinition> getSources() {
 		if (sourceList == null || sinkList == null)
 			parse();
 		return this.sourceList;
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSinks() {
+	public Set<ISourceSinkDefinition> getSinks() {
 		if (sourceList == null || sinkList == null)
 			parse();
 		return this.sinkList;
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getAllMethods() {
+	public Set<ISourceSinkDefinition> getAllMethods() {
 		if (sourceList == null || sinkList == null)
 			parse();
 
-		Set<SourceSinkDefinition> sourcesSinks = new HashSet<>(
+		Set<ISourceSinkDefinition> sourcesSinks = new HashSet<>(
 				sourceList.size() + sinkList.size() + neitherList.size());
 		sourcesSinks.addAll(sourceList);
 		sourcesSinks.addAll(sinkList);
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/CategorizedAndroidSourceSinkParser.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/CategorizedAndroidSourceSinkParser.java
index ae7c06b..7194239 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/CategorizedAndroidSourceSinkParser.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/CategorizedAndroidSourceSinkParser.java
@@ -24,8 +24,8 @@ import java.util.regex.Pattern;
 import soot.jimple.infoflow.android.data.AndroidMethod;
 import soot.jimple.infoflow.android.data.CategoryDefinition;
 import soot.jimple.infoflow.android.data.CategoryDefinition.CATEGORY;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 
 /**
@@ -48,8 +48,8 @@ public class CategorizedAndroidSourceSinkParser {
 		this.sourceSinkType = sourceSinkType;
 	}
 
-	public Set<SourceSinkDefinition> parse() throws IOException {
-		Set<SourceSinkDefinition> definitions = new HashSet<>();
+	public Set<ISourceSinkDefinition> parse() throws IOException {
+		Set<ISourceSinkDefinition> definitions = new HashSet<>();
 		CategoryDefinition allCats = new CategoryDefinition(CATEGORY.ALL);
 		boolean loadAllCategories = categories.contains(allCats);
 
@@ -69,7 +69,7 @@ public class CategorizedAndroidSourceSinkParser {
 				if (loadAllCategories || categories.contains(cat)) {
 					AndroidMethod method = parseMethod(m);
 					method.setSourceSinkType(sourceSinkType);
-					SourceSinkDefinition def = new MethodSourceSinkDefinition(method);
+					MethodSourceSinkDefinition def = new MethodSourceSinkDefinition(method);
 					def.setCategory(cat);
 					definitions.add(def);
 				}
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/PScoutPermissionMethodParser.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/PScoutPermissionMethodParser.java
index ef2f908..e5df2c6 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/PScoutPermissionMethodParser.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/PScoutPermissionMethodParser.java
@@ -28,9 +28,9 @@ import soot.jimple.infoflow.android.data.AndroidMethod;
 import soot.jimple.infoflow.android.data.CategoryDefinition;
 import soot.jimple.infoflow.android.data.CategoryDefinition.CATEGORY;
 import soot.jimple.infoflow.data.SootMethodAndClass;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinitionProvider;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 
 /**
@@ -42,9 +42,9 @@ import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 public class PScoutPermissionMethodParser implements ISourceSinkDefinitionProvider {
 	private static final int INITIAL_SET_SIZE = 10000;
 
-	private Set<SourceSinkDefinition> sourceList = null;
-	private Set<SourceSinkDefinition> sinkList = null;
-	private Set<SourceSinkDefinition> neitherList = null;
+	private Set<ISourceSinkDefinition> sourceList = null;
+	private Set<ISourceSinkDefinition> sinkList = null;
+	private Set<ISourceSinkDefinition> neitherList = null;
 
 	private Map<String, CategoryDefinition> categories = new HashMap<>();
 
@@ -104,9 +104,9 @@ public class PScoutPermissionMethodParser implements ISourceSinkDefinitionProvid
 	}
 
 	private void parse() {
-		sourceList = new HashSet<SourceSinkDefinition>(INITIAL_SET_SIZE);
-		sinkList = new HashSet<SourceSinkDefinition>(INITIAL_SET_SIZE);
-		neitherList = new HashSet<SourceSinkDefinition>(INITIAL_SET_SIZE);
+		sourceList = new HashSet<>(INITIAL_SET_SIZE);
+		sinkList = new HashSet<>(INITIAL_SET_SIZE);
+		neitherList = new HashSet<>(INITIAL_SET_SIZE);
 
 		BufferedReader rdr = readFile();
 
@@ -133,10 +133,10 @@ public class PScoutPermissionMethodParser implements ISourceSinkDefinitionProvid
 		}
 	}
 
-	private void addToList(Set<SourceSinkDefinition> sourceList, MethodSourceSinkDefinition def,
+	private void addToList(Set<ISourceSinkDefinition> sourceList, MethodSourceSinkDefinition def,
 			String currentPermission) {
 		if (!sourceList.add(def)) {
-			for (SourceSinkDefinition ssdef : sourceList) {
+			for (ISourceSinkDefinition ssdef : sourceList) {
 				if (ssdef instanceof MethodSourceSinkDefinition) {
 					MethodSourceSinkDefinition mssdef = (MethodSourceSinkDefinition) ssdef;
 					SootMethodAndClass singleMethod = def.getMethod();
@@ -150,14 +150,14 @@ public class PScoutPermissionMethodParser implements ISourceSinkDefinitionProvid
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSources() {
+	public Set<ISourceSinkDefinition> getSources() {
 		if (sourceList == null || sinkList == null)
 			parse();
 		return this.sourceList;
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSinks() {
+	public Set<ISourceSinkDefinition> getSinks() {
 		if (sourceList == null || sinkList == null)
 			parse();
 		return this.sinkList;
@@ -274,11 +274,11 @@ public class PScoutPermissionMethodParser implements ISourceSinkDefinitionProvid
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getAllMethods() {
+	public Set<ISourceSinkDefinition> getAllMethods() {
 		if (sourceList == null || sinkList == null)
 			parse();
 
-		Set<SourceSinkDefinition> sourcesSinks = new HashSet<>(
+		Set<ISourceSinkDefinition> sourcesSinks = new HashSet<>(
 				sourceList.size() + sinkList.size() + neitherList.size());
 		sourcesSinks.addAll(sourceList);
 		sourcesSinks.addAll(sinkList);
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/PermissionMethodParser.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/PermissionMethodParser.java
index 4aa032c..53311aa 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/PermissionMethodParser.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/data/parsers/PermissionMethodParser.java
@@ -29,9 +29,9 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import soot.jimple.infoflow.android.data.AndroidMethod;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinitionProvider;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 
 /**
@@ -44,9 +44,9 @@ public class PermissionMethodParser implements ISourceSinkDefinitionProvider {
 	private final Logger logger = LoggerFactory.getLogger(getClass());
 
 	private Map<String, AndroidMethod> methods = null;
-	private Set<SourceSinkDefinition> sourceList = null;
-	private Set<SourceSinkDefinition> sinkList = null;
-	private Set<SourceSinkDefinition> neitherList = null;
+	private Set<ISourceSinkDefinition> sourceList = null;
+	private Set<ISourceSinkDefinition> sinkList = null;
+	private Set<ISourceSinkDefinition> neitherList = null;
 
 	private static final int INITIAL_SET_SIZE = 10000;
 
@@ -105,14 +105,14 @@ public class PermissionMethodParser implements ISourceSinkDefinitionProvider {
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSources() {
+	public Set<ISourceSinkDefinition> getSources() {
 		if (sourceList == null || sinkList == null)
 			parse();
 		return this.sourceList;
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSinks() {
+	public Set<ISourceSinkDefinition> getSinks() {
 		if (sourceList == null || sinkList == null)
 			parse();
 		return this.sinkList;
@@ -144,7 +144,7 @@ public class PermissionMethodParser implements ISourceSinkDefinitionProvider {
 
 		// Create the source/sink definitions
 		for (AndroidMethod am : methods.values()) {
-			SourceSinkDefinition singleMethod = new MethodSourceSinkDefinition(am);
+			MethodSourceSinkDefinition singleMethod = new MethodSourceSinkDefinition(am);
 
 			if (am.getSourceSinkType().isSource())
 				sourceList.add(singleMethod);
@@ -243,11 +243,11 @@ public class PermissionMethodParser implements ISourceSinkDefinitionProvider {
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getAllMethods() {
+	public Set<ISourceSinkDefinition> getAllMethods() {
 		if (sourceList == null || sinkList == null)
 			parse();
 
-		Set<SourceSinkDefinition> sourcesSinks = new HashSet<>(
+		Set<ISourceSinkDefinition> sourcesSinks = new HashSet<>(
 				sourceList.size() + sinkList.size() + neitherList.size());
 		sourcesSinks.addAll(sourceList);
 		sourcesSinks.addAll(sinkList);
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AbstractAndroidEntryPointCreator.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AbstractAndroidEntryPointCreator.java
index 3f250ff..bf5ccfe 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AbstractAndroidEntryPointCreator.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AbstractAndroidEntryPointCreator.java
@@ -10,6 +10,7 @@ import soot.SootMethod;
 import soot.jimple.Jimple;
 import soot.jimple.NopStmt;
 import soot.jimple.Stmt;
+import soot.jimple.infoflow.android.manifest.ProcessManifest;
 import soot.jimple.infoflow.entryPointCreators.BaseEntryPointCreator;
 import soot.jimple.infoflow.util.SystemClassHandler;
 
@@ -17,6 +18,12 @@ public abstract class AbstractAndroidEntryPointCreator extends BaseEntryPointCre
 
 	protected AndroidEntryPointUtils entryPointUtils = null;
 
+	protected ProcessManifest manifest;
+
+	public AbstractAndroidEntryPointCreator(ProcessManifest manifest) {
+		this.manifest = manifest;
+	}
+
 	@Override
 	public SootMethod createDummyMain() {
 		// Initialize the utility class
@@ -35,6 +42,7 @@ public abstract class AbstractAndroidEntryPointCreator extends BaseEntryPointCre
 			return null;
 
 		SootMethod method = findMethod(currentClass, subsignature);
+
 		if (method == null) {
 			logger.warn("Could not find Android entry point method: {}", subsignature);
 			return null;
@@ -47,14 +55,14 @@ public abstract class AbstractAndroidEntryPointCreator extends BaseEntryPointCre
 
 		// If this method is part of the Android framework, we don't need to
 		// call it
-		if (SystemClassHandler.isClassInSystemPackage(method.getDeclaringClass().getName()))
+		if (SystemClassHandler.v().isClassInSystemPackage(method.getDeclaringClass().getName()))
 			return null;
 
 		assert method.isStatic() || classLocal != null : "Class local was null for non-static method "
 				+ method.getSignature();
 
 		// write Method
-		return buildMethodCall(method, mainMethod.getActiveBody(), classLocal, generator, parentClasses);
+		return buildMethodCall(method, classLocal, parentClasses);
 	}
 
 	protected boolean createPlainMethodCall(Local classLocal, SootMethod currentMethod) {
@@ -66,7 +74,7 @@ public abstract class AbstractAndroidEntryPointCreator extends BaseEntryPointCre
 		NopStmt thenStmt = Jimple.v().newNopStmt();
 		body.getUnits().add(beforeStmt);
 		createIfStmt(thenStmt);
-		buildMethodCall(currentMethod, body, classLocal, generator);
+		buildMethodCall(currentMethod, classLocal);
 
 		body.getUnits().add(thenStmt);
 		createIfStmt(beforeStmt);
@@ -80,8 +88,7 @@ public abstract class AbstractAndroidEntryPointCreator extends BaseEntryPointCre
 	/**
 	 * Creates instance of the given classes
 	 * 
-	 * @param classes
-	 *            The classes of which to create instances
+	 * @param classes The classes of which to create instances
 	 */
 	protected void createClassInstances(Collection<SootClass> classes) {
 		for (SootClass callbackClass : classes) {
@@ -89,7 +96,7 @@ public abstract class AbstractAndroidEntryPointCreator extends BaseEntryPointCre
 			createIfStmt(thenStmt);
 			Local l = localVarsForClasses.get(callbackClass);
 			if (l == null) {
-				l = generateClassConstructor(callbackClass, body);
+				l = generateClassConstructor(callbackClass);
 				if (l != null)
 					localVarsForClasses.put(callbackClass, l);
 			}
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointConstants.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointConstants.java
index 2f36fea..b553c84 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointConstants.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointConstants.java
@@ -32,6 +32,7 @@ public class AndroidEntryPointConstants {
 	public static final String FRAGMENTCLASS = "android.app.Fragment";
 	public static final String SUPPORTFRAGMENTCLASS = "android.support.v4.app.Fragment";
 	public static final String SERVICECONNECTIONINTERFACE = "android.content.ServiceConnection";
+	public static final String MAPACTIVITYCLASS = "com.google.android.maps.MapActivity";
 
 	public static final String APPCOMPATACTIVITYCLASS_V4 = "android.support.v4.app.AppCompatActivity";
 	public static final String APPCOMPATACTIVITYCLASS_V7 = "android.support.v7.app.AppCompatActivity";
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointCreator.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointCreator.java
index 83f6470..db3845f 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointCreator.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointCreator.java
@@ -90,8 +90,6 @@ public class AndroidEntryPointCreator extends AbstractAndroidEntryPointCreator i
 
 	private Collection<SootClass> components;
 
-	private ProcessManifest manifest;
-
 	/**
 	 * Creates a new instance of the {@link AndroidEntryPointCreator} class and
 	 * registers a list of classes to be automatically scanned for Android lifecycle
@@ -101,7 +99,7 @@ public class AndroidEntryPointCreator extends AbstractAndroidEntryPointCreator i
 	 *                   lifecycle methods
 	 */
 	public AndroidEntryPointCreator(ProcessManifest manifest, Collection<SootClass> components) {
-		this.manifest = manifest;
+		super(manifest);
 		this.components = components;
 		this.overwriteDummyMainMethod = true;
 	}
@@ -124,7 +122,7 @@ public class AndroidEntryPointCreator extends AbstractAndroidEntryPointCreator i
 			for (SootClass currentClass : components) {
 				if (entryPointUtils.getComponentType(currentClass) == ComponentType.ContentProvider) {
 					// Create an instance of the content provider
-					Local localVal = generateClassConstructor(currentClass, body);
+					Local localVal = generateClassConstructor(currentClass);
 					if (localVal == null)
 						continue;
 					localVarsForClasses.put(currentClass, localVal);
@@ -150,7 +148,7 @@ public class AndroidEntryPointCreator extends AbstractAndroidEntryPointCreator i
 		// If we have an application, we need to start it in the very beginning
 		if (applicationClass != null) {
 			// Create the application
-			applicationLocal = generateClassConstructor(applicationClass, body);
+			applicationLocal = generateClassConstructor(applicationClass);
 			localVarsForClasses.put(applicationClass, applicationLocal);
 			if (applicationLocal != null) {
 				localVarsForClasses.put(applicationClass, applicationLocal);
@@ -215,7 +213,8 @@ public class AndroidEntryPointCreator extends AbstractAndroidEntryPointCreator i
 		for (SootClass parentActivity : fragmentClasses.keySet()) {
 			Set<SootClass> fragments = fragmentClasses.get(parentActivity);
 			for (SootClass fragment : fragments) {
-				FragmentEntryPointCreator entryPointCreator = new FragmentEntryPointCreator(fragment, applicationClass);
+				FragmentEntryPointCreator entryPointCreator = new FragmentEntryPointCreator(fragment, applicationClass,
+						this.manifest);
 				entryPointCreator.setDummyClassName(mainMethod.getDeclaringClass().getName());
 				entryPointCreator.setCallbacks(callbackFunctions.get(fragment));
 
@@ -250,21 +249,23 @@ public class AndroidEntryPointCreator extends AbstractAndroidEntryPointCreator i
 					}
 				}
 				componentCreator = new ActivityEntryPointCreator(currentClass, applicationClass,
-						activityLifecycleCallbacks, callbackClassToField, curActivityToFragmentMethod);
+						activityLifecycleCallbacks, callbackClassToField, curActivityToFragmentMethod, this.manifest);
 				break;
 			case Service:
 			case GCMBaseIntentService:
 			case GCMListenerService:
-				componentCreator = new ServiceEntryPointCreator(currentClass, applicationClass);
+				componentCreator = new ServiceEntryPointCreator(currentClass, applicationClass, this.manifest);
 				break;
 			case ServiceConnection:
-				componentCreator = new ServiceConnectionEntryPointCreator(currentClass, applicationClass);
+				componentCreator = new ServiceConnectionEntryPointCreator(currentClass, applicationClass,
+						this.manifest);
 				break;
 			case BroadcastReceiver:
-				componentCreator = new BroadcastReceiverEntryPointCreator(currentClass, applicationClass);
+				componentCreator = new BroadcastReceiverEntryPointCreator(currentClass, applicationClass,
+						this.manifest);
 				break;
 			case ContentProvider:
-				componentCreator = new ContentProviderEntryPointCreator(currentClass, applicationClass);
+				componentCreator = new ContentProviderEntryPointCreator(currentClass, applicationClass, this.manifest);
 				break;
 			default:
 				componentCreator = null;
@@ -310,7 +311,7 @@ public class AndroidEntryPointCreator extends AbstractAndroidEntryPointCreator i
 
 		// Optimize and check the generated main method
 		NopEliminator.v().transform(body);
-		eliminateSelfLoops(body);
+		eliminateSelfLoops();
 		eliminateFallthroughIfs(body);
 
 		if (DEBUG || Options.v().validate())
@@ -449,7 +450,7 @@ public class AndroidEntryPointCreator extends AbstractAndroidEntryPointCreator i
 				// of the application class.
 				if (method == null)
 					continue;
-				if (SystemClassHandler.isClassInSystemPackage(method.getDeclaringClass().getName()))
+				if (SystemClassHandler.v().isClassInSystemPackage(method.getDeclaringClass().getName()))
 					continue;
 
 				// Get the local instance of the target class
@@ -463,7 +464,7 @@ public class AndroidEntryPointCreator extends AbstractAndroidEntryPointCreator i
 				// Add a conditional call to the method
 				NopStmt thenStmt = Jimple.v().newNopStmt();
 				createIfStmt(thenStmt);
-				buildMethodCall(method, body, local, generator);
+				buildMethodCall(method, local);
 				body.getUnits().add(thenStmt);
 			}
 	}
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointUtils.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointUtils.java
index 30f4d07..e0145ee 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointUtils.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/AndroidEntryPointUtils.java
@@ -19,6 +19,7 @@ public class AndroidEntryPointUtils {
 
 	private SootClass osClassApplication;
 	private SootClass osClassActivity;
+	private SootClass osClassMapActivity;
 	private SootClass osClassService;
 	private SootClass osClassFragment;
 	private SootClass osClassSupportFragment;
@@ -53,6 +54,7 @@ public class AndroidEntryPointUtils {
 		osClassGCMListenerService = Scene.v().getSootClassUnsafe(AndroidEntryPointConstants.GCMLISTENERSERVICECLASS);
 		osInterfaceServiceConnection = Scene.v()
 				.getSootClassUnsafe(AndroidEntryPointConstants.SERVICECONNECTIONINTERFACE);
+		osClassMapActivity = Scene.v().getSootClassUnsafe(AndroidEntryPointConstants.MAPACTIVITYCLASS);
 	}
 
 	/**
@@ -108,6 +110,10 @@ public class AndroidEntryPointUtils {
 		else if (osInterfaceServiceConnection != null && Scene.v().getOrMakeFastHierarchy()
 				.canStoreType(currentClass.getType(), osInterfaceServiceConnection.getType()))
 			ctype = ComponentType.ServiceConnection;
+		// (10) com.google.android.maps.MapActivity
+		else if (osClassMapActivity != null && Scene.v().getOrMakeFastHierarchy().canStoreType(currentClass.getType(),
+				osClassMapActivity.getType()))
+			ctype = ComponentType.Activity;
 
 		componentTypeCache.put(currentClass, ctype);
 		return ctype;
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/AbstractComponentEntryPointCreator.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/AbstractComponentEntryPointCreator.java
index 6596cd2..f8e96a3 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/AbstractComponentEntryPointCreator.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/AbstractComponentEntryPointCreator.java
@@ -5,22 +5,34 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import soot.Body;
 import soot.Local;
+import soot.PatchingChain;
 import soot.RefType;
 import soot.Scene;
 import soot.SootClass;
 import soot.SootField;
 import soot.SootMethod;
 import soot.Type;
+import soot.Unit;
+import soot.javaToJimple.LocalGenerator;
+import soot.jimple.IdentityStmt;
+import soot.jimple.InvokeExpr;
 import soot.jimple.Jimple;
 import soot.jimple.JimpleBody;
 import soot.jimple.NopStmt;
 import soot.jimple.NullConstant;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.android.entryPointCreators.AbstractAndroidEntryPointCreator;
+import soot.jimple.infoflow.android.manifest.ProcessManifest;
+import soot.jimple.infoflow.entryPointCreators.SimulatedCodeElementTag;
 import soot.jimple.toolkits.scalar.NopEliminator;
 import soot.util.HashMultiMap;
 import soot.util.MultiMap;
@@ -34,6 +46,8 @@ import soot.util.MultiMap;
  */
 public abstract class AbstractComponentEntryPointCreator extends AbstractAndroidEntryPointCreator {
 
+	private final Logger logger = LoggerFactory.getLogger(getClass());
+
 	protected final SootClass component;
 	protected final SootClass applicationClass;
 	protected Set<SootMethod> callbacks = null;
@@ -42,7 +56,11 @@ public abstract class AbstractComponentEntryPointCreator extends AbstractAndroid
 	protected Local intentLocal = null;
 	protected SootField intentField = null;
 
-	public AbstractComponentEntryPointCreator(SootClass component, SootClass applicationClass) {
+	private RefType INTENT_TYPE = RefType.v("android.content.Intent");
+
+	public AbstractComponentEntryPointCreator(SootClass component, SootClass applicationClass,
+			ProcessManifest manifest) {
+		super(manifest);
 		this.component = component;
 		this.applicationClass = applicationClass;
 		this.overwriteDummyMainMethod = true;
@@ -64,6 +82,7 @@ public abstract class AbstractComponentEntryPointCreator extends AbstractAndroid
 
 		// Create the field itself
 		intentField = Scene.v().makeSootField(fieldName, RefType.v("android.content.Intent"), Modifier.PUBLIC);
+		intentField.addTag(SimulatedCodeElementTag.TAG);
 		component.addField(intentField);
 	}
 
@@ -166,7 +185,7 @@ public abstract class AbstractComponentEntryPointCreator extends AbstractAndroid
 			createIfStmt(endClassStmt);
 
 			// Create a new instance of the component
-			thisLocal = generateClassConstructor(component, body);
+			thisLocal = generateClassConstructor(component);
 			if (thisLocal != null) {
 				localVarsForClasses.put(component, thisLocal);
 
@@ -187,9 +206,85 @@ public abstract class AbstractComponentEntryPointCreator extends AbstractAndroid
 				body.getUnits().add(Jimple.v().newReturnStmt(thisLocal));
 		}
 		NopEliminator.v().transform(body);
+
+		instrumentDummyMainMethod();
+
 		return mainMethod;
 	}
 
+	/**
+	 * Transfer Intent for such components that take an Intent as a parameter and do
+	 * not leverage getIntent() method for retrieving the received Intent.
+	 * 
+	 * Code adapted from FlowDroid v2.0.
+	 */
+	protected void instrumentDummyMainMethod() {
+		Body body = mainMethod.getActiveBody();
+
+		PatchingChain<Unit> units = body.getUnits();
+		for (Iterator<Unit> iter = units.snapshotIterator(); iter.hasNext();) {
+			Stmt stmt = (Stmt) iter.next();
+
+			if (stmt instanceof IdentityStmt)
+				continue;
+			if (!stmt.containsInvokeExpr())
+				continue;
+
+			InvokeExpr iexpr = stmt.getInvokeExpr();
+			if (iexpr.getMethodRef().isConstructor())
+				continue;
+
+			List<Type> types = stmt.getInvokeExpr().getMethod().getParameterTypes();
+			for (int i = 0; i < types.size(); i++) {
+				Type type = types.get(i);
+				if (type.equals(INTENT_TYPE)) {
+					try {
+						assignIntent(component, stmt.getInvokeExpr().getMethod(), i);
+					} catch (Exception ex) {
+						logger.error("Assign Intent for " + stmt.getInvokeExpr().getMethod() + " fails.", ex);
+					}
+				}
+			}
+		}
+	}
+
+	/**
+	 * Method used in instrumentDummyMainMethod() to transfer Intent
+	 * 
+	 * Code adapted from FlowDroid v2.0.
+	 */
+	public void assignIntent(SootClass hostComponent, SootMethod method, int indexOfArgs) {
+		if (!method.isStatic()) {
+			Body body = method.retrieveActiveBody();
+
+			PatchingChain<Unit> units = body.getUnits();
+			Local thisLocal = body.getThisLocal();
+			Local intentV = body.getParameterLocal(indexOfArgs);
+
+			for (Iterator<Unit> iter = units.snapshotIterator(); iter.hasNext();) {
+				Stmt stmt = (Stmt) iter.next();
+				// We need to look for the first non-identity statement
+				if (!(stmt instanceof IdentityStmt)) {
+					/*
+					 * Using the component that the dummyMain() belongs to, as in some cases the
+					 * invoked method is only available in its superclass. and its superclass does
+					 * not contain getIntent() and consequently cause an runtime exception of
+					 * couldn't find getIntent().
+					 * 
+					 * RuntimeException: couldn't find method getIntent(*) in
+					 * com.google.android.gcm.GCMBroadcastReceiver
+					 */
+					Unit setIntentU = Jimple.v().newAssignStmt(intentV, Jimple.v().newVirtualInvokeExpr(thisLocal,
+							hostComponent.getMethodByName("getIntent").makeRef()));
+
+					setIntentU.addTag(SimulatedCodeElementTag.TAG);
+					units.insertBefore(setIntentU, stmt);
+					break;
+				}
+			}
+		}
+	}
+
 	/**
 	 * Generates the component-specific portion of the lifecycle
 	 */
@@ -278,8 +373,8 @@ public abstract class AbstractComponentEntryPointCreator extends AbstractAndroid
 				// Jimple statement here
 				Set<Local> tempLocals = new HashSet<>();
 				if (classLocal == null) {
-					classLocal = generateClassConstructor(callbackClass, body, new HashSet<SootClass>(),
-							referenceClasses, tempLocals);
+					classLocal = generateClassConstructor(callbackClass, new HashSet<SootClass>(), referenceClasses,
+							tempLocals);
 					if (classLocal == null)
 						continue;
 				}
@@ -341,7 +436,7 @@ public abstract class AbstractComponentEntryPointCreator extends AbstractAndroid
 			// callback
 			NopStmt thenStmt = Jimple.v().newNopStmt();
 			createIfStmt(thenStmt);
-			buildMethodCall(callbackMethod, body, classLocal, generator, referenceClasses);
+			buildMethodCall(callbackMethod, classLocal, referenceClasses);
 			body.getUnits().add(thenStmt);
 		}
 	}
@@ -366,4 +461,30 @@ public abstract class AbstractComponentEntryPointCreator extends AbstractAndroid
 		return info;
 	}
 
+	/**
+	 * Creates an implementation of getIntent() that returns the intent from our ICC
+	 * model
+	 */
+	protected void createGetIntentMethod() {
+		// We need to create an implementation of "getIntent". If there is already such
+		// an implementation, we don't touch it.
+		if (component.declaresMethod("android.content.Intent getIntent()"))
+			return;
+
+		Type intentType = RefType.v("android.content.Intent");
+		SootMethod sm = Scene.v().makeSootMethod("getIntent", Collections.<Type>emptyList(), intentType,
+				Modifier.PUBLIC);
+		component.addMethod(sm);
+		sm.addTag(SimulatedCodeElementTag.TAG);
+
+		JimpleBody b = Jimple.v().newBody(sm);
+		sm.setActiveBody(b);
+		b.insertIdentityStmts();
+
+		LocalGenerator localGen = new LocalGenerator(b);
+		Local lcIntent = localGen.generateLocal(intentType);
+		b.getUnits().add(Jimple.v().newAssignStmt(lcIntent,
+				Jimple.v().newInstanceFieldRef(b.getThisLocal(), intentField.makeRef())));
+		b.getUnits().add(Jimple.v().newReturnStmt(lcIntent));
+	}
 }
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ActivityEntryPointCreator.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ActivityEntryPointCreator.java
index f24bd66..a910055 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ActivityEntryPointCreator.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ActivityEntryPointCreator.java
@@ -19,12 +19,12 @@ import soot.SootMethod;
 import soot.Type;
 import soot.Value;
 import soot.VoidType;
-import soot.javaToJimple.LocalGenerator;
 import soot.jimple.Jimple;
 import soot.jimple.JimpleBody;
 import soot.jimple.NopStmt;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointConstants;
+import soot.jimple.infoflow.android.manifest.ProcessManifest;
 import soot.jimple.infoflow.cfg.LibraryClassPatcher;
 import soot.jimple.infoflow.entryPointCreators.SimulatedCodeElementTag;
 import soot.util.MultiMap;
@@ -45,8 +45,8 @@ public class ActivityEntryPointCreator extends AbstractComponentEntryPointCreato
 
 	public ActivityEntryPointCreator(SootClass component, SootClass applicationClass,
 			MultiMap<SootClass, String> activityLifecycleCallbacks, Map<SootClass, SootField> callbackClassToField,
-			Map<SootClass, SootMethod> fragmentToMainMethod) {
-		super(component, applicationClass);
+			Map<SootClass, SootMethod> fragmentToMainMethod, ProcessManifest manifest) {
+		super(component, applicationClass, manifest);
 		this.activityLifecycleCallbacks = activityLifecycleCallbacks;
 		this.callbackClassToField = callbackClassToField;
 		this.fragmentToMainMethod = fragmentToMainMethod;
@@ -199,8 +199,7 @@ public class ActivityEntryPointCreator extends AbstractComponentEntryPointCreato
 
 		// 6. onRestart:
 		searchAndBuildMethod(AndroidEntryPointConstants.ACTIVITY_ONRESTART, component, thisLocal);
-		createIfStmt(onStartStmt); // jump to onStart(), fall through to
-									// onDestroy()
+		body.getUnits().add(Jimple.v().newGotoStmt(onStartStmt)); // jump to onStart()
 
 		// 7. onDestroy
 		body.getUnits().add(stopToDestroyStmt);
@@ -223,6 +222,7 @@ public class ActivityEntryPointCreator extends AbstractComponentEntryPointCreato
 
 		// Create the field itself
 		resultIntentField = Scene.v().makeSootField(fieldName, RefType.v("android.content.Intent"), Modifier.PUBLIC);
+		resultIntentField.addTag(SimulatedCodeElementTag.TAG);
 		component.addField(resultIntentField);
 	}
 
@@ -233,33 +233,6 @@ public class ActivityEntryPointCreator extends AbstractComponentEntryPointCreato
 		createSetResultMethod();
 	}
 
-	/**
-	 * Creates an implementation of getIntent() that returns the intent from our ICC
-	 * model
-	 */
-	private void createGetIntentMethod() {
-		// We need to create an implementation of "getIntent". If there is already such
-		// an implementation, we don't touch it.
-		if (component.declaresMethod("android.content.Intent getIntent()"))
-			return;
-
-		Type intentType = RefType.v("android.content.Intent");
-		SootMethod sm = Scene.v().makeSootMethod("getIntent", Collections.<Type>emptyList(), intentType,
-				Modifier.PUBLIC);
-		component.addMethod(sm);
-		sm.addTag(SimulatedCodeElementTag.TAG);
-
-		JimpleBody b = Jimple.v().newBody(sm);
-		sm.setActiveBody(b);
-		b.insertIdentityStmts();
-
-		LocalGenerator localGen = new LocalGenerator(b);
-		Local lcIntent = localGen.generateLocal(intentType);
-		b.getUnits().add(Jimple.v().newAssignStmt(lcIntent,
-				Jimple.v().newInstanceFieldRef(b.getThisLocal(), intentField.makeRef())));
-		b.getUnits().add(Jimple.v().newReturnStmt(lcIntent));
-	}
-
 	/**
 	 * Creates an implementation of setIntent() that writes the given intent into
 	 * the correct field
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/BroadcastReceiverEntryPointCreator.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/BroadcastReceiverEntryPointCreator.java
index 57df1dd..2542a3d 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/BroadcastReceiverEntryPointCreator.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/BroadcastReceiverEntryPointCreator.java
@@ -5,6 +5,7 @@ import soot.jimple.Jimple;
 import soot.jimple.NopStmt;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointConstants;
+import soot.jimple.infoflow.android.manifest.ProcessManifest;
 
 /**
  * Entry point creator for Android broadcast receivers
@@ -14,8 +15,9 @@ import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointConstant
  */
 public class BroadcastReceiverEntryPointCreator extends AbstractComponentEntryPointCreator {
 
-	public BroadcastReceiverEntryPointCreator(SootClass component, SootClass applicationClass) {
-		super(component, applicationClass);
+	public BroadcastReceiverEntryPointCreator(SootClass component, SootClass applicationClass,
+			ProcessManifest manifest) {
+		super(component, applicationClass, manifest);
 	}
 
 	@Override
@@ -34,4 +36,11 @@ public class BroadcastReceiverEntryPointCreator extends AbstractComponentEntryPo
 		createIfStmt(onReceiveStmt);
 	}
 
+	@Override
+	protected void createAdditionalMethods() {
+		super.createAdditionalMethods();
+
+		createGetIntentMethod();
+	}
+
 }
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ContentProviderEntryPointCreator.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ContentProviderEntryPointCreator.java
index 5bcb547..366597f 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ContentProviderEntryPointCreator.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ContentProviderEntryPointCreator.java
@@ -3,6 +3,7 @@ package soot.jimple.infoflow.android.entryPointCreators.components;
 import soot.SootClass;
 import soot.jimple.Jimple;
 import soot.jimple.NopStmt;
+import soot.jimple.infoflow.android.manifest.ProcessManifest;
 
 /**
  * Entry point creator for content providers
@@ -12,8 +13,8 @@ import soot.jimple.NopStmt;
  */
 public class ContentProviderEntryPointCreator extends AbstractComponentEntryPointCreator {
 
-	public ContentProviderEntryPointCreator(SootClass component, SootClass applicationClass) {
-		super(component, applicationClass);
+	public ContentProviderEntryPointCreator(SootClass component, SootClass applicationClass, ProcessManifest manifest) {
+		super(component, applicationClass, manifest);
 	}
 
 	@Override
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/FragmentEntryPointCreator.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/FragmentEntryPointCreator.java
index c6ea12d..fe16397 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/FragmentEntryPointCreator.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/FragmentEntryPointCreator.java
@@ -13,6 +13,7 @@ import soot.jimple.NopStmt;
 import soot.jimple.NullConstant;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointConstants;
+import soot.jimple.infoflow.android.manifest.ProcessManifest;
 
 /**
  * Entry point creator for Android fragments
@@ -22,8 +23,8 @@ import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointConstant
  */
 public class FragmentEntryPointCreator extends AbstractComponentEntryPointCreator {
 
-	public FragmentEntryPointCreator(SootClass component, SootClass applicationClass) {
-		super(component, applicationClass);
+	public FragmentEntryPointCreator(SootClass component, SootClass applicationClass, ProcessManifest manifest) {
+		super(component, applicationClass, manifest);
 	}
 
 	@Override
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ServiceConnectionEntryPointCreator.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ServiceConnectionEntryPointCreator.java
index f8159ca..3287ed9 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ServiceConnectionEntryPointCreator.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ServiceConnectionEntryPointCreator.java
@@ -4,6 +4,7 @@ import soot.SootClass;
 import soot.jimple.Jimple;
 import soot.jimple.NopStmt;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointConstants;
+import soot.jimple.infoflow.android.manifest.ProcessManifest;
 
 /**
  * Entry point creator for Android service connections
@@ -13,8 +14,9 @@ import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointConstant
  */
 public class ServiceConnectionEntryPointCreator extends AbstractComponentEntryPointCreator {
 
-	public ServiceConnectionEntryPointCreator(SootClass component, SootClass applicationClass) {
-		super(component, applicationClass);
+	public ServiceConnectionEntryPointCreator(SootClass component, SootClass applicationClass,
+			ProcessManifest manifest) {
+		super(component, applicationClass, manifest);
 	}
 
 	@Override
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ServiceEntryPointCreator.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ServiceEntryPointCreator.java
index 3f7b9b0..b8056c8 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ServiceEntryPointCreator.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/entryPointCreators/components/ServiceEntryPointCreator.java
@@ -10,12 +10,14 @@ import soot.SootClass;
 import soot.SootField;
 import soot.SootMethod;
 import soot.Type;
+import soot.Unit;
 import soot.jimple.Jimple;
 import soot.jimple.JimpleBody;
 import soot.jimple.NopStmt;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointConstants;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointUtils.ComponentType;
+import soot.jimple.infoflow.android.manifest.ProcessManifest;
 import soot.jimple.infoflow.entryPointCreators.SimulatedCodeElementTag;
 
 /**
@@ -28,8 +30,8 @@ public class ServiceEntryPointCreator extends AbstractComponentEntryPointCreator
 
 	protected SootField binderField = null;
 
-	public ServiceEntryPointCreator(SootClass component, SootClass applicationClass) {
-		super(component, applicationClass);
+	public ServiceEntryPointCreator(SootClass component, SootClass applicationClass, ProcessManifest manifest) {
+		super(component, applicationClass, manifest);
 	}
 
 	@Override
@@ -145,6 +147,8 @@ public class ServiceEntryPointCreator extends AbstractComponentEntryPointCreator
 
 		// We need to instrument the onBind() method to store the binder in the field
 		instrumentOnBind();
+
+		createGetIntentMethod();
 	}
 
 	/**
@@ -183,9 +187,10 @@ public class ServiceEntryPointCreator extends AbstractComponentEntryPointCreator
 			final Local thisLocal = b.getThisLocal();
 			final Local binderLocal = b.getParameterLocal(0);
 
-			b.getUnits().insertAfter(Jimple.v()
-					.newAssignStmt(Jimple.v().newInstanceFieldRef(thisLocal, binderField.makeRef()), binderLocal),
-					firstNonIdentityStmt);
+			final Unit assignStmt = Jimple.v()
+					.newAssignStmt(Jimple.v().newInstanceFieldRef(thisLocal, binderField.makeRef()), binderLocal);
+			assignStmt.addTag(SimulatedCodeElementTag.TAG);
+			b.getUnits().insertAfter(assignStmt, firstNonIdentityStmt);
 		}
 	}
 
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/Ic3ResultLoader.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/Ic3ResultLoader.java
index de17b91..f1b69b7 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/Ic3ResultLoader.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/Ic3ResultLoader.java
@@ -24,8 +24,7 @@ public class Ic3ResultLoader {
 
 	public static App load(String resultConfigPath) {
 		Ic3Data.Application application;
-		try {
-			FileInputStream inputStream = new FileInputStream(resultConfigPath);
+		try (FileInputStream inputStream = new FileInputStream(resultConfigPath)) {
 			if (resultConfigPath.endsWith(".dat")) {
 				application = Application.parseFrom(inputStream);
 			} else {
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccInstrumentDestination.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccInstrumentDestination.java
index 4ec06ac..b941cdf 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccInstrumentDestination.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccInstrumentDestination.java
@@ -22,6 +22,7 @@ import soot.jimple.Jimple;
 import soot.jimple.NullConstant;
 import soot.jimple.ReturnStmt;
 import soot.jimple.Stmt;
+import soot.jimple.infoflow.entryPointCreators.SimulatedCodeElementTag;
 
 /**
  * One ICC Link contain one source component and one destination component. this
@@ -199,6 +200,7 @@ public class IccInstrumentDestination {
 							Value arg0 = stmt.getInvokeExpr().getArg(0);
 							Unit assignUnit = Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(sf.makeRef()),
 									arg0);
+							assignUnit.addTag(SimulatedCodeElementTag.TAG);
 							units.insertBefore(assignUnit, stmt);
 						}
 					}
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccInstrumenter.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccInstrumenter.java
index 68561c6..34a8788 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccInstrumenter.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccInstrumenter.java
@@ -19,6 +19,7 @@ import soot.javaToJimple.LocalGenerator;
 import soot.jimple.Jimple;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.android.entryPointCreators.components.ComponentEntryPointCollection;
+import soot.jimple.infoflow.entryPointCreators.SimulatedCodeElementTag;
 import soot.jimple.infoflow.handlers.PreAnalysisHandler;
 import soot.util.Chain;
 import soot.util.HashMultiMap;
@@ -72,12 +73,7 @@ public class IccInstrumenter implements PreAnalysisHandler {
 		}
 
 		// Remove any potential leftovers from the last last instrumentation
-		for (Body body : instrumentedUnits.keySet()) {
-			for (Unit u : instrumentedUnits.get(body)) {
-				body.getUnits().remove(u);
-			}
-		}
-		instrumentedUnits.clear();
+		undoInstrumentation();
 
 		// Instrument the messenger class
 		instrumentMessenger();
@@ -88,6 +84,18 @@ public class IccInstrumenter implements PreAnalysisHandler {
 		logger.info("[IccTA] ...End ICC Redirection Creation");
 	}
 
+	/**
+	 * Removes all units generated through instrumentation
+	 */
+	protected void undoInstrumentation() {
+		for (Body body : instrumentedUnits.keySet()) {
+			for (Unit u : instrumentedUnits.get(body)) {
+				body.getUnits().remove(u);
+			}
+		}
+		instrumentedUnits.clear();
+	}
+
 	protected void instrumentMessenger() {
 		logger.info("Launching Messenger Transformer...");
 
@@ -121,18 +129,21 @@ public class IccInstrumenter implements PreAnalysisHandler {
 
 									Unit newU = Jimple.v().newAssignStmt(handlerLocal,
 											Jimple.v().newNewExpr(handler.getType()));
+									newU.addTag(SimulatedCodeElementTag.TAG);
 									body.getUnits().insertAfter(newU, stmt);
 									instrumentedUnits.put(body, newU);
 
 									SootMethod initMethod = handler.getMethod("void <init>()");
 									Unit initU = Jimple.v().newInvokeStmt(
 											Jimple.v().newSpecialInvokeExpr(handlerLocal, initMethod.makeRef()));
+									initU.addTag(SimulatedCodeElementTag.TAG);
 									body.getUnits().insertAfter(initU, newU);
 									instrumentedUnits.put(body, initU);
 
 									SootMethod hmMethod = handler.getMethod("void handleMessage(android.os.Message)");
 									Unit callHMU = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(
 											handlerLocal, hmMethod.makeRef(), stmt.getInvokeExpr().getArg(0)));
+									callHMU.addTag(SimulatedCodeElementTag.TAG);
 									body.getUnits().insertAfter(callHMU, initU);
 									instrumentedUnits.put(body, callHMU);
 								}
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccRedirectionCreator.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccRedirectionCreator.java
index 8b634f4..f8bb5ec 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccRedirectionCreator.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccRedirectionCreator.java
@@ -13,7 +13,6 @@ import org.slf4j.LoggerFactory;
 import soot.Body;
 import soot.Local;
 import soot.Modifier;
-import soot.NullType;
 import soot.PatchingChain;
 import soot.RefType;
 import soot.Scene;
@@ -36,6 +35,7 @@ import soot.jimple.Stmt;
 import soot.jimple.infoflow.android.entryPointCreators.components.ActivityEntryPointInfo;
 import soot.jimple.infoflow.android.entryPointCreators.components.ComponentEntryPointCollection;
 import soot.jimple.infoflow.android.entryPointCreators.components.ServiceEntryPointInfo;
+import soot.jimple.infoflow.entryPointCreators.SimulatedCodeElementTag;
 import soot.jimple.infoflow.util.SystemClassHandler;
 import soot.tagkit.Tag;
 import soot.util.HashMultiMap;
@@ -73,8 +73,8 @@ public class IccRedirectionCreator {
 	private final RefType INTENT_TYPE = RefType.v("android.content.Intent");
 	private final RefType IBINDER_TYPE = RefType.v("android.os.IBinder");
 
-	private final Map<String, SootMethod> source2RedirectMethod = new HashMap<>();
-	private final MultiMap<Body, Unit> instrumentedUnits = new HashMultiMap<>();
+	protected final Map<String, SootMethod> source2RedirectMethod = new HashMap<>();
+	protected final MultiMap<Body, Unit> instrumentedUnits = new HashMultiMap<>();
 
 	protected final SootClass dummyMainClass;
 	protected final ComponentEntryPointCollection componentToEntryPoint;
@@ -95,7 +95,7 @@ public class IccRedirectionCreator {
 			return;
 
 		// Do not instrument code into system methods
-		if (SystemClassHandler.isClassInSystemPackage(link.getFromSM().getDeclaringClass().getName()))
+		if (SystemClassHandler.v().isClassInSystemPackage(link.getFromSM().getDeclaringClass().getName()))
 			return;
 
 		// 1) generate redirect method
@@ -339,7 +339,7 @@ public class IccRedirectionCreator {
 		paramTypes.add(RefType.v("android.os.IBinder"));
 		SootMethod method = serviceConnection.getMethod("onServiceConnected", paramTypes);
 
-		Local iLocal1 = lg.generateLocal(NullType.v());
+		Local iLocal1 = lg.generateLocal(RefType.v("android.content.ComponentName"));
 		b.getUnits().add(Jimple.v().newAssignStmt(iLocal1, NullConstant.v()));
 
 		List<Value> args = new ArrayList<Value>();
@@ -430,6 +430,10 @@ public class IccRedirectionCreator {
 			args.add(arg1);
 			args.add(arg0);
 		} else {
+			// specially deal with ICC methods with no parameter, i.e., PendingIntent.send()
+			if (fromStmt.getInvokeExpr().getArgCount() == 0) {
+				return;
+			}
 			Value arg0 = fromStmt.getInvokeExpr().getArg(0);
 			args.add(arg0);
 		}
@@ -444,6 +448,7 @@ public class IccRedirectionCreator {
 		final PatchingChain<Unit> units = body.getUnits();
 
 		copyTags(link.getFromU(), redirectCallU);
+		redirectCallU.addTag(SimulatedCodeElementTag.TAG);
 		units.insertAfter(redirectCallU, link.getFromU());
 		instrumentedUnits.put(body, redirectCallU);
 		if (instrumentationCallback != null)
@@ -468,6 +473,7 @@ public class IccRedirectionCreator {
 						List<ValueBox> vbs = stmt.getUseAndDefBoxes();
 						Unit assignU = Jimple.v().newAssignStmt(vbs.get(0).getValue(), vbs.get(1).getValue());
 						copyTags(stmt, assignU);
+						assignU.addTag(SimulatedCodeElementTag.TAG);
 						units.insertAfter(assignU, stmt);
 						instrumentedUnits.put(body, assignU);
 					}
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccResults.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccResults.java
deleted file mode 100644
index 05376ed..0000000
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/iccta/IccResults.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package soot.jimple.infoflow.android.iccta;
-
-import java.util.HashSet;
-import java.util.Set;
-
-import soot.jimple.infoflow.results.InfoflowResults;
-import soot.jimple.infoflow.results.ResultSinkInfo;
-import soot.jimple.infoflow.results.ResultSourceInfo;
-import soot.jimple.infoflow.solver.cfg.IInfoflowCFG;
-
-public class IccResults {
-
-	public static InfoflowResults clean(IInfoflowCFG cfg, InfoflowResults results) {
-		if (null == results) {
-			return results;
-		}
-
-		InfoflowResults cleanResults = new InfoflowResults();
-
-		Set<String> iccSources = new HashSet<String>();
-		Set<String> iccSinks = new HashSet<String>();
-
-		if (!results.isEmpty()) {
-			for (ResultSinkInfo sink : results.getResults().keySet()) {
-				for (ResultSourceInfo source : results.getResults().get(sink)) {
-					String sourceBelongingClass = cfg.getMethodOf(source.getStmt()).getDeclaringClass().getName();
-					String sinkBelongingClass = cfg.getMethodOf(sink.getStmt()).getDeclaringClass().getName();
-
-					if (!sourceBelongingClass.equals(sinkBelongingClass)) {
-						String iccSource = cfg.getMethodOf(source.getStmt()).getSignature() + "/" + source.getStmt();
-						iccSources.add(iccSource);
-
-						String iccSink = cfg.getMethodOf(sink.getStmt()).getSignature() + "/" + sink.getStmt();
-						iccSinks.add(iccSink);
-
-						cleanResults.addResult(sink, source);
-					}
-				}
-			}
-		}
-
-		return cleanResults;
-	}
-
-}
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/manifest/ProcessManifest.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/manifest/ProcessManifest.java
index ca9fce1..af0da31 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/manifest/ProcessManifest.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/manifest/ProcessManifest.java
@@ -20,6 +20,9 @@ import soot.jimple.infoflow.android.axml.AXmlAttribute;
 import soot.jimple.infoflow.android.axml.AXmlHandler;
 import soot.jimple.infoflow.android.axml.AXmlNode;
 import soot.jimple.infoflow.android.axml.ApkHandler;
+import soot.jimple.infoflow.android.resources.ARSCFileParser;
+import soot.jimple.infoflow.android.resources.ARSCFileParser.AbstractResource;
+import soot.jimple.infoflow.android.resources.ARSCFileParser.StringResource;
 import soot.jimple.infoflow.util.SystemClassHandler;
 
 /**
@@ -51,6 +54,7 @@ public class ProcessManifest implements Closeable {
 	 * Handler for android xml files
 	 */
 	protected AXmlHandler axml;
+	protected ARSCFileParser arscParser;
 
 	// android manifest data
 	protected AXmlNode manifest;
@@ -84,11 +88,25 @@ public class ProcessManifest implements Closeable {
 	 * @see {@link ProcessManifest#ProcessManifest(InputStream)}
 	 */
 	public ProcessManifest(File apkFile) throws IOException, XmlPullParserException {
+		this(apkFile, ARSCFileParser.getInstance(apkFile));
+	}
+
+	/**
+	 * Processes an AppManifest which is within the given {@link File}.
+	 *
+	 * @param apkFile    the AppManifest within the given APK will be parsed.
+	 * @param arscParser The parser for the Android resource database
+	 * @throws IOException            if an I/O error occurs.
+	 * @throws XmlPullParserException can occur due to a malformed manifest.
+	 * @see {@link ProcessManifest#ProcessManifest(InputStream)}
+	 */
+	public ProcessManifest(File apkFile, ARSCFileParser arscParser) throws IOException, XmlPullParserException {
 		if (!apkFile.exists())
 			throw new RuntimeException(
 					String.format("The given APK file %s does not exist", apkFile.getCanonicalPath()));
 
 		this.apk = new ApkHandler(apkFile);
+		this.arscParser = arscParser;
 		InputStream is = null;
 		try {
 			is = this.apk.getInputStream("AndroidManifest.xml");
@@ -250,12 +268,13 @@ public class ProcessManifest implements Closeable {
 	}
 
 	private void checkAndAddComponent(Set<String> entryPoints, AXmlNode node) {
+		final String packageName = getPackageName() + ".";
 		AXmlAttribute<?> attrEnabled = node.getAttribute("enabled");
 		if (attrEnabled == null || !attrEnabled.getValue().equals(Boolean.FALSE)) {
 			AXmlAttribute<?> attr = node.getAttribute("name");
 			if (attr != null) {
 				String className = expandClassName((String) attr.getValue());
-				if (!SystemClassHandler.isClassInSystemPackage(className))
+				if (className.startsWith(packageName) || !SystemClassHandler.v().isClassInSystemPackage(className))
 					entryPoints.add(className);
 			} else {
 				// This component does not have a name, so this might be
@@ -269,7 +288,7 @@ public class ProcessManifest implements Closeable {
 							String name = (String) attrValue.getValue();
 							if (isValidComponentName(name)) {
 								String expandedName = expandClassName(name);
-								if (!SystemClassHandler.isClassInSystemPackage(expandedName))
+								if (!SystemClassHandler.v().isClassInSystemPackage(expandedName))
 									entryPoints.add(expandedName);
 							}
 						}
@@ -510,7 +529,21 @@ public class ProcessManifest implements Closeable {
 	 */
 	public String getApplicationName() {
 		AXmlAttribute<?> attr = this.application.getAttribute("name");
-		return attr == null || attr.getValue() == null ? null : expandClassName((String) attr.getValue());
+		if (attr != null) {
+			Object value = attr.getValue();
+			if (value != null) {
+				if (value instanceof String)
+					return expandClassName((String) attr.getValue());
+				else if (value instanceof Integer) {
+					AbstractResource res = arscParser.findResource((Integer) attr.getValue());
+					if (res instanceof StringResource) {
+						StringResource strRes = (StringResource) res;
+						return strRes.getValue();
+					}
+				}
+			}
+		}
+		return null;
 	}
 
 	/**
@@ -668,13 +701,11 @@ public class ProcessManifest implements Closeable {
 					boolean actionFilter = false;
 					boolean categoryFilter = false;
 					for (AXmlNode intentFilter : activityChildren.getChildren()) {
-						if (intentFilter.getTag().equals("action")
-								&& intentFilter.getAttribute("name").getValue().toString()
-										.equals("android.intent.action.MAIN"))
+						if (intentFilter.getTag().equals("action") && intentFilter.getAttribute("name").getValue()
+								.toString().equals("android.intent.action.MAIN"))
 							actionFilter = true;
-						else if (intentFilter.getTag().equals("category")
-								&& intentFilter.getAttribute("name").getValue().toString()
-										.equals("android.intent.category.LAUNCHER"))
+						else if (intentFilter.getTag().equals("category") && intentFilter.getAttribute("name")
+								.getValue().toString().equals("android.intent.category.LAUNCHER"))
 							categoryFilter = true;
 					}
 
@@ -687,4 +718,5 @@ public class ProcessManifest implements Closeable {
 
 		return allLaunchableActivities;
 	}
+
 }
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/ARSCFileParser.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/ARSCFileParser.java
index 9e96930..96cd474 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/ARSCFileParser.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/ARSCFileParser.java
@@ -10,6 +10,7 @@
  ******************************************************************************/
 package soot.jimple.infoflow.android.resources;
 
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.math.BigInteger;
@@ -21,10 +22,13 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import soot.jimple.infoflow.android.axml.ApkHandler;
+
 /**
  * Parser for reading out the contents of Android's resource.arsc file.
  * Structure declarations and comments taken from the Android source code and
@@ -269,6 +273,25 @@ public class ARSCFileParser extends AbstractResourceParser {
 			return null;
 		}
 
+		/**
+		 * Adds all contents of the given package to this data object
+		 * 
+		 * @param other The other package that shall be integrated into this one
+		 */
+		private void addAll(ResPackage other) {
+			for (ResType tp : other.types) {
+				ResType existingType = getType(tp.id, tp.typeName);
+				if (existingType == null)
+					types.add(tp);
+				else
+					existingType.addAll(tp);
+			}
+		}
+
+		public ResType getType(int id, String typeName) {
+			return types.stream().filter(t -> t.id == id && t.typeName.equals(typeName)).findFirst().orElse(null);
+		}
+
 		@Override
 		public int hashCode() {
 			final int prime = 31;
@@ -318,6 +341,32 @@ public class ARSCFileParser extends AbstractResourceParser {
 			return this.typeName;
 		}
 
+		/**
+		 * Adds all data from the given type into this type
+		 * 
+		 * @param tp The type from which to add all data into this type
+		 */
+		private void addAll(ResType tp) {
+			for (ResConfig config : tp.configurations) {
+				ResConfig existingConfig = getConfiguration(config.getConfig());
+				if (existingConfig == null)
+					configurations.add(config);
+				else
+					existingConfig.addAll(config);
+			}
+		}
+
+		/**
+		 * Gets the configuration object for the given settings
+		 * 
+		 * @param config The settings to look for
+		 * @return The configuration object that is associated with the given settings,
+		 *         or <code>null</code> if no such configuration object exists
+		 */
+		public ResConfig getConfiguration(ResTable_Config config) {
+			return configurations.stream().filter(c -> c.config.equals(config)).findFirst().orElse(null);
+		}
+
 		public List<ResConfig> getConfigurations() {
 			return this.configurations;
 		}
@@ -338,6 +387,16 @@ public class ARSCFileParser extends AbstractResourceParser {
 			return resources.values();
 		}
 
+		/**
+		 * Gets the names of all resources defined for this resource type
+		 * 
+		 * @return The names of all resources in the current type
+		 */
+		public Collection<String> getAllResourceNames() {
+			return this.configurations.stream().flatMap(c -> c.getResources().stream()).map(r -> r.getResourceName())
+					.collect(Collectors.toSet());
+		}
+
 		/**
 		 * Gets all resource of the current type that have the given id
 		 * 
@@ -449,6 +508,15 @@ public class ARSCFileParser extends AbstractResourceParser {
 			return config;
 		}
 
+		/**
+		 * Adds all data from the given configuration into this data object
+		 * 
+		 * @param other The configuration object from which to read the data
+		 */
+		private void addAll(ResConfig other) {
+			this.resources.addAll(other.resources);
+		}
+
 		public List<AbstractResource> getResources() {
 			return this.resources;
 		}
@@ -652,6 +720,7 @@ public class ARSCFileParser extends AbstractResourceParser {
 				return false;
 			return true;
 		}
+
 	}
 
 	/**
@@ -813,6 +882,10 @@ public class ARSCFileParser extends AbstractResourceParser {
 			return this.b;
 		}
 
+		public int getARGB() {
+			return (this.a << 24) | (this.r << 16) | (this.g << 8) | b;
+		}
+
 		@Override
 		public String toString() {
 			return String.format("#%02x%02x%02x%02x", a, r, g, b);
@@ -1056,13 +1129,16 @@ public class ARSCFileParser extends AbstractResourceParser {
 	 * Android resource containing complex map data.
 	 */
 	public static class ComplexResource extends AbstractResource {
-		private Map<String, AbstractResource> value;
+		private final String resType;
+		private final Map<String, AbstractResource> value;
 
-		public ComplexResource() {
-			this.value = new HashMap<String, AbstractResource>();
+		public ComplexResource(String resType) {
+			this.resType = resType;
+			this.value = new HashMap<>();
 		}
 
-		public ComplexResource(Map<String, AbstractResource> value) {
+		public ComplexResource(String resType, Map<String, AbstractResource> value) {
+			this.resType = resType;
 			this.value = value;
 		}
 
@@ -1070,6 +1146,10 @@ public class ARSCFileParser extends AbstractResourceParser {
 			return this.value;
 		}
 
+		public String getResType() {
+			return resType;
+		}
+
 		@Override
 		public int hashCode() {
 			final int prime = 31;
@@ -2171,7 +2251,7 @@ public class ARSCFileParser extends AbstractResourceParser {
 							// If this is a simple entry, the data structure is
 							// followed by RES_VALUE
 							if (entry.flagsComplex) {
-								ComplexResource cmpRes = new ComplexResource();
+								ComplexResource cmpRes = new ComplexResource(resType.typeName);
 								res = cmpRes;
 
 								for (int j = 0; j < ((ResTable_Map_Entry) entry).count; j++) {
@@ -2194,43 +2274,35 @@ public class ARSCFileParser extends AbstractResourceParser {
 										// We silently ignore inconsistencies at thze moment
 										if (existingResource instanceof ArrayResource)
 											((ArrayResource) existingResource).add(value);
-									} else
+									} else {
 										cmpRes.value.put(mapName, value);
+									}
 								}
 							} else {
 								Res_Value val = new Res_Value();
 								entryOffset = readValue(val, remainingData, entryOffset);
 								res = parseValue(val);
 								if (res == null) {
-									logger.error(String.format("Could not parse resource %s of type %s, skipping entry",
-											keyStrings.get(entry.key), Integer.toHexString(val.dataType)));
+									logger.error(
+											String.format("Could not parse resource %s of type 0x%x, skipping entry",
+													keyStrings.get(entry.key), val.dataType));
 									continue;
 								}
 							}
 
-							// Create the data object. For finding the correct
-							// ID, we
-							// must check whether the entry is really new - if
-							// so, it
+							// Create the data object. For finding the correct ID, we
+							// must check whether the entry is really new - if so, it
 							// gets a new ID, otherwise, we reuse the old one
-							if (keyStrings.containsKey(entry.key))
+							if (keyStrings.containsKey(entry.key)) {
 								res.resourceName = keyStrings.get(entry.key);
-							else
+							} else {
 								res.resourceName = "<INVALID RESOURCE>";
-
-							if (res.resourceName != null && res.resourceName.length() > 0) {
-								// Some obfuscated resources do only contain an
-								// empty string as resource name
-								// -> We only need to check the name if it is
-								// really present
-								AbstractResource r = resType.getResourceByName(res.resourceName);
-								if (r != null) {
-									res.resourceID = r.resourceID;
-								}
 							}
+
 							if (res.resourceID <= 0) {
 								res.resourceID = (packageTable.id << 24) + (typeTable.id << 16) + resourceIdx;
 							}
+							logger.debug("resource added: {}", res);
 							config.resources.add(res);
 							resourceIdx++;
 						}
@@ -2239,17 +2311,16 @@ public class ARSCFileParser extends AbstractResourceParser {
 				}
 
 				// Create the data objects for the types in the package
-				if (logger.isDebugEnabled()) {
+				if (logger.isTraceEnabled()) {
 					for (ResType resType : resPackage.types) {
-						logger.debug(String.format("\t\tType %s (%d), configCount=%d, entryCount=%d", resType.typeName,
+						logger.trace("\t\tType {} ({}), configCount={}, entryCount={}", resType.typeName,
 								resType.id - 1, resType.configurations.size(),
-								resType.configurations.size() > 0 ? resType.configurations.get(0).resources.size()
-										: 0));
+								resType.configurations.size() > 0 ? resType.configurations.get(0).resources.size() : 0);
 						for (ResConfig resConfig : resType.configurations) {
-							logger.debug("\t\t\tconfig");
+							logger.trace("\t\t\tconfig");
 							for (AbstractResource res : resConfig.resources)
-								logger.debug(String.format("\t\t\t\tresource %s: %s",
-										Integer.toHexString(res.resourceID), res.resourceName));
+								logger.trace("\t\t\t\tresource {}: {}", Integer.toHexString(res.resourceID),
+										res.resourceName);
 						}
 					}
 				}
@@ -2332,6 +2403,7 @@ public class ARSCFileParser extends AbstractResourceParser {
 				res = new FractionResource(FractionType.FractionParent, data);
 			break;
 		default:
+			logger.warn(String.format("Unsupported data type: 0x%x", val.dataType));
 			return null;
 		}
 		return res;
@@ -2503,9 +2575,12 @@ public class ARSCFileParser extends AbstractResourceParser {
 		if (remainingSize > 0) {
 			byte[] remainingBytes = new byte[remainingSize];
 			System.arraycopy(data, offset, remainingBytes, 0, remainingSize);
-			if (!(new BigInteger(1, remainingBytes).equals(BigInteger.ZERO))) {
-				logger.warn("Excessive non-null bytes in ResTable_Config ignored");
-				assert false;
+			BigInteger remainingData = new BigInteger(1, remainingBytes);
+			if (!(remainingData.equals(BigInteger.ZERO))) {
+				logger.debug("Excessive {} non-null bytes in ResTable_Config ignored", remainingSize);
+				if (logger.isTraceEnabled()) {
+					logger.trace("remaining data: 0x" + remainingData.toString(16));
+				}
 			}
 			offset += remainingSize;
 		}
@@ -2683,6 +2758,11 @@ public class ARSCFileParser extends AbstractResourceParser {
 		return this.packages;
 	}
 
+	public ResPackage getPackage(int pkgID, String pkgName) {
+		return this.packages.stream().filter(p -> p.packageId == pkgID && p.packageName.equals(pkgName)).findFirst()
+				.orElse(null);
+	}
+
 	/**
 	 * Finds the resource with the given Android resource ID. This method is
 	 * configuration-agnostic and simply returns the first match it finds.
@@ -2813,4 +2893,40 @@ public class ARSCFileParser extends AbstractResourceParser {
 		return resourceList;
 	}
 
+	/**
+	 * Creates a new instance of the {@link ARSCFileParser} class and parses the
+	 * Android resource database in the given APK file
+	 * 
+	 * @param apkFile The APK file in which to parse the resource database
+	 * @return The new {@link ARSCFileParser} instance
+	 * @throws IOException
+	 */
+	public static ARSCFileParser getInstance(File apkFile) throws IOException {
+		ARSCFileParser parser = new ARSCFileParser();
+		try (ApkHandler handler = new ApkHandler(apkFile); InputStream is = handler.getInputStream("resources.arsc")) {
+			parser.parse(is);
+		}
+		return parser;
+	}
+
+	/**
+	 * Adds all resources loaded from another {@link ARSCFileParser} to this data
+	 * object
+	 * 
+	 * @param otherParser The other parser
+	 */
+	public void addAll(ARSCFileParser otherParser) {
+		// Merge the packages
+		for (ResPackage pkg : otherParser.packages) {
+			ResPackage existingPackage = getPackage(pkg.packageId, pkg.packageName);
+			if (existingPackage == null)
+				packages.add(pkg);
+			else
+				existingPackage.addAll(pkg);
+		}
+
+		// Merge the string table
+		stringTable.putAll(otherParser.stringTable);
+	}
+
 }
\ No newline at end of file
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/AbstractResourceParser.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/AbstractResourceParser.java
index d452800..bf6e0ed 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/AbstractResourceParser.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/AbstractResourceParser.java
@@ -33,13 +33,10 @@ public abstract class AbstractResourceParser {
 	 * Opens the given apk file and provides the given handler with a stream for
 	 * accessing the contained resource manifest files
 	 * 
-	 * @param apk
-	 *            The apk file to process
-	 * @param fileNameFilter
-	 *            If this parameter is non-null, only files with a name
-	 *            (excluding extension) in this set will be analyzed.
-	 * @param handler
-	 *            The handler for processing the apk file
+	 * @param apk            The apk file to process
+	 * @param fileNameFilter If this parameter is non-null, only files with a name
+	 *                       (excluding extension) in this set will be analyzed.
+	 * @param handler        The handler for processing the apk file
 	 */
 	protected void handleAndroidResourceFiles(String apk, Set<String> fileNameFilter, IResourceHandler handler) {
 		File apkF = new File(apk);
@@ -47,26 +44,16 @@ public abstract class AbstractResourceParser {
 			throw new RuntimeException("file '" + apk + "' does not exist!");
 
 		try {
-			ZipFile archive = null;
-			try {
-				archive = new ZipFile(apkF);
+			try (ZipFile archive = new ZipFile(apkF)) {
 				Enumeration<?> entries = archive.entries();
 				while (entries.hasMoreElements()) {
 					ZipEntry entry = (ZipEntry) entries.nextElement();
 					String entryName = entry.getName();
 
-					InputStream is = null;
-					try {
-						is = archive.getInputStream(entry);
+					try (InputStream is = archive.getInputStream(entry)) {
 						handler.handleResourceFile(entryName, fileNameFilter, is);
-					} finally {
-						if (is != null)
-							is.close();
 					}
 				}
-			} finally {
-				if (archive != null)
-					archive.close();
 			}
 		} catch (Exception e) {
 			logger.error("Error when looking for XML resource files in apk " + apk, e);
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/LayoutFileParser.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/LayoutFileParser.java
index baf5fd5..769f2e9 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/LayoutFileParser.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/LayoutFileParser.java
@@ -41,13 +41,13 @@ import soot.util.MultiMap;
  */
 public class LayoutFileParser extends AbstractResourceParser {
 
-	private final MultiMap<String, AndroidLayoutControl> userControls = new HashMultiMap<>();
-	private final MultiMap<String, String> callbackMethods = new HashMultiMap<>();
-	private final MultiMap<String, String> includeDependencies = new HashMultiMap<>();
-	private final MultiMap<String, SootClass> fragments = new HashMultiMap<>();
+	protected final MultiMap<String, AndroidLayoutControl> userControls = new HashMultiMap<>();
+	protected final MultiMap<String, String> callbackMethods = new HashMultiMap<>();
+	protected final MultiMap<String, String> includeDependencies = new HashMultiMap<>();
+	protected final MultiMap<String, SootClass> fragments = new HashMultiMap<>();
 
-	private final String packageName;
-	private final ARSCFileParser resParser;
+	protected final String packageName;
+	protected final ARSCFileParser resParser;
 
 	private boolean loadOnlySensitiveControls = false;
 	private SootClass scViewGroup = null;
@@ -196,7 +196,7 @@ public class LayoutFileParser extends AbstractResourceParser {
 				if (!fileName.startsWith("res/layout"))
 					return;
 				if (!fileName.endsWith(".xml")) {
-					logger.warn("Skipping file %s in layout folder...", fileName);
+					logger.warn(String.format("Skipping file %s in layout folder...", fileName));
 					return;
 				}
 
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/controls/EditTextControl.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/controls/EditTextControl.java
index fd9fb31..ecfc16b 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/controls/EditTextControl.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/controls/EditTextControl.java
@@ -10,9 +10,9 @@ import soot.jimple.infoflow.android.axml.AXmlAttribute;
 import soot.jimple.infoflow.android.axml.flags.InputType;
 import soot.jimple.infoflow.sourcesSinks.definitions.AccessPathTuple;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkCategory;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition.CallType;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 
 /**
@@ -22,8 +22,8 @@ import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
  *
  */
 public class EditTextControl extends AndroidLayoutControl {
-	protected final static SourceSinkDefinition UI_PASSWORD_SOURCE_DEF;
-	protected final static SourceSinkDefinition UI_ELEMENT_SOURCE_DEF;
+	protected final static ISourceSinkDefinition UI_PASSWORD_SOURCE_DEF;
+	protected final static ISourceSinkDefinition UI_ELEMENT_SOURCE_DEF;
 
 	static {
 		UI_PASSWORD_SOURCE_DEF = new MethodSourceSinkDefinition(null, null,
@@ -95,8 +95,7 @@ public class EditTextControl extends AndroidLayoutControl {
 	/**
 	 * Sets the type of this input (text, password, etc.)
 	 * 
-	 * @param inputType
-	 *            The input type
+	 * @param inputType The input type
 	 */
 	void setInputType(int inputType) {
 		this.inputType = inputType;
@@ -115,6 +114,7 @@ public class EditTextControl extends AndroidLayoutControl {
 
 	/**
 	 * Returns true if the input satiesfies all specified types
+	 * 
 	 * @see InputType
 	 * @param type the types to check
 	 */
@@ -177,7 +177,7 @@ public class EditTextControl extends AndroidLayoutControl {
 	}
 
 	@Override
-	public SourceSinkDefinition getSourceDefinition() {
+	public ISourceSinkDefinition getSourceDefinition() {
 		return isSensitive() ? UI_PASSWORD_SOURCE_DEF : UI_ELEMENT_SOURCE_DEF;
 	}
 
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/controls/GenericLayoutControl.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/controls/GenericLayoutControl.java
index 1beb26e..7db415d 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/controls/GenericLayoutControl.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/resources/controls/GenericLayoutControl.java
@@ -5,9 +5,9 @@ import java.util.Map;
 
 import soot.SootClass;
 import soot.jimple.infoflow.sourcesSinks.definitions.AccessPathTuple;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition.CallType;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 
 /**
@@ -18,7 +18,7 @@ import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
  */
 public class GenericLayoutControl extends AndroidLayoutControl {
 
-	protected final static SourceSinkDefinition UI_SOURCE_DEF = new MethodSourceSinkDefinition(null, null,
+	protected final static ISourceSinkDefinition UI_SOURCE_DEF = new MethodSourceSinkDefinition(null, null,
 			Collections.singleton(AccessPathTuple.fromPathElements(Collections.singletonList("content"),
 					Collections.singletonList("java.lang.Object"), SourceSinkType.Source)),
 			CallType.MethodCall);
@@ -36,7 +36,7 @@ public class GenericLayoutControl extends AndroidLayoutControl {
 	}
 
 	@Override
-	public SourceSinkDefinition getSourceDefinition() {
+	public ISourceSinkDefinition getSourceDefinition() {
 		return UI_SOURCE_DEF;
 	}
 
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/source/AccessPathBasedSourceSinkManager.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/source/AccessPathBasedSourceSinkManager.java
index 31693da..3f01bf8 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/source/AccessPathBasedSourceSinkManager.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/source/AccessPathBasedSourceSinkManager.java
@@ -1,5 +1,6 @@
 package soot.jimple.infoflow.android.source;
 
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
@@ -14,14 +15,15 @@ import soot.jimple.ParameterRef;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.InfoflowManager;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
-import soot.jimple.infoflow.android.callbacks.CallbackDefinition;
+import soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition;
 import soot.jimple.infoflow.android.resources.controls.AndroidLayoutControl;
 import soot.jimple.infoflow.data.AccessPath;
 import soot.jimple.infoflow.sourcesSinks.definitions.AccessPathTuple;
 import soot.jimple.infoflow.sourcesSinks.definitions.FieldSourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.IAccessPathBasedSourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition.CallType;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.StatementSourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.manager.SinkInfo;
 import soot.jimple.infoflow.sourcesSinks.manager.SourceInfo;
@@ -40,15 +42,12 @@ public class AccessPathBasedSourceSinkManager extends AndroidSourceSinkManager {
 	 * Creates a new instance of the {@link AndroidSourceSinkManager} class with
 	 * either strong or weak matching.
 	 * 
-	 * @param sources
-	 *            The list of source methods
-	 * @param sinks
-	 *            The list of sink methods
-	 * @param config
-	 *            The configuration of the data flow analyzer
+	 * @param sources The list of source methods
+	 * @param sinks   The list of sink methods
+	 * @param config  The configuration of the data flow analyzer
 	 */
-	public AccessPathBasedSourceSinkManager(Set<SourceSinkDefinition> sources, Set<SourceSinkDefinition> sinks,
-			InfoflowAndroidConfiguration config) {
+	public AccessPathBasedSourceSinkManager(Set<? extends ISourceSinkDefinition> sources,
+			Set<? extends ISourceSinkDefinition> sinks, InfoflowAndroidConfiguration config) {
 		super(sources, sinks, config);
 	}
 
@@ -57,36 +56,40 @@ public class AccessPathBasedSourceSinkManager extends AndroidSourceSinkManager {
 	 * strong matching, i.e. the methods in the code must exactly match those in the
 	 * list.
 	 * 
-	 * @param sources
-	 *            The list of source methods
-	 * @param sinks
-	 *            The list of sink methods
-	 * @param callbackMethods
-	 *            The list of callback methods whose parameters are sources through
-	 *            which the application receives data from the operating system
-	 * @param config
-	 *            The configuration of the data flow analyzer
-	 * @param layoutControls
-	 *            A map from reference identifiers to the respective Android layout
-	 *            controls
+	 * @param sources         The list of source methods
+	 * @param sinks           The list of sink methods
+	 * @param callbackMethods The list of callback methods whose parameters are
+	 *                        sources through which the application receives data
+	 *                        from the operating system
+	 * @param config          The configuration of the data flow analyzer
+	 * @param layoutControls  A map from reference identifiers to the respective
+	 *                        Android layout controls
 	 */
-	public AccessPathBasedSourceSinkManager(Set<SourceSinkDefinition> sources, Set<SourceSinkDefinition> sinks,
-			Set<CallbackDefinition> callbackMethods, InfoflowAndroidConfiguration config,
-			Map<Integer, AndroidLayoutControl> layoutControls) {
+	public AccessPathBasedSourceSinkManager(Set<? extends ISourceSinkDefinition> sources,
+			Set<? extends ISourceSinkDefinition> sinks, Set<AndroidCallbackDefinition> callbackMethods,
+			InfoflowAndroidConfiguration config, Map<Integer, AndroidLayoutControl> layoutControls) {
 		super(sources, sinks, callbackMethods, config, layoutControls);
 	}
 
 	@Override
-	protected SourceInfo createSourceInfo(Stmt sCallSite, InfoflowManager manager, SourceSinkDefinition def) {
+	protected SourceInfo createSourceInfo(Stmt sCallSite, InfoflowManager manager, ISourceSinkDefinition def) {
 		// Do we have data at all?
 		if (null == def)
 			return null;
-		if (def.isEmpty())
+
+		// We need to have access path data inside the source/sink definition
+		if (!(def instanceof IAccessPathBasedSourceSinkDefinition))
+			return super.createSourceInfo(sCallSite, manager, def);
+		IAccessPathBasedSourceSinkDefinition apDef = (IAccessPathBasedSourceSinkDefinition) def;
+
+		// If we don't have concrete access paths, we use the default implementation
+		if (apDef.isEmpty())
 			return super.createSourceInfo(sCallSite, manager, def);
 
 		// We have real access path definitions, so we can construct precise
 		// source information objects
 		Set<AccessPath> aps = new HashSet<>();
+		Set<AccessPathTuple> apTuples = new HashSet<>();
 
 		if (def instanceof MethodSourceSinkDefinition) {
 			MethodSourceSinkDefinition methodDef = (MethodSourceSinkDefinition) def;
@@ -98,9 +101,13 @@ public class AccessPathBasedSourceSinkManager extends AndroidSourceSinkManager {
 					IdentityStmt is = (IdentityStmt) sCallSite;
 					if (is.getRightOp() instanceof ParameterRef) {
 						ParameterRef paramRef = (ParameterRef) is.getRightOp();
-						if (methodDef.getParameters() != null && methodDef.getParameters().length > paramRef.getIndex())
-							for (AccessPathTuple apt : methodDef.getParameters()[paramRef.getIndex()])
+						if (methodDef.getParameters() != null
+								&& methodDef.getParameters().length > paramRef.getIndex()) {
+							for (AccessPathTuple apt : methodDef.getParameters()[paramRef.getIndex()]) {
 								aps.add(apt.toAccessPath(is.getLeftOp(), manager, false));
+								apTuples.add(apt);
+							}
+						}
 					}
 				}
 				break;
@@ -109,27 +116,38 @@ public class AccessPathBasedSourceSinkManager extends AndroidSourceSinkManager {
 				if (sCallSite instanceof InvokeStmt && sCallSite.getInvokeExpr() instanceof InstanceInvokeExpr
 						&& methodDef.getBaseObjects() != null) {
 					Value baseVal = ((InstanceInvokeExpr) sCallSite.getInvokeExpr()).getBase();
-					for (AccessPathTuple apt : methodDef.getBaseObjects())
-						if (apt.getSourceSinkType().isSource())
+					for (AccessPathTuple apt : methodDef.getBaseObjects()) {
+						if (apt.getSourceSinkType().isSource()) {
 							aps.add(apt.toAccessPath(baseVal, manager, true));
+							apTuples.add(apt);
+						}
+					}
 				}
 
 				// Check whether we need to taint the return object
 				if (sCallSite instanceof DefinitionStmt && methodDef.getReturnValues() != null) {
 					Value returnVal = ((DefinitionStmt) sCallSite).getLeftOp();
-					for (AccessPathTuple apt : methodDef.getReturnValues())
-						if (apt.getSourceSinkType().isSource())
+					for (AccessPathTuple apt : methodDef.getReturnValues()) {
+						if (apt.getSourceSinkType().isSource()) {
 							aps.add(apt.toAccessPath(returnVal, manager, false));
+							apTuples.add(apt);
+						}
+					}
 				}
 
 				// Check whether we need to taint parameters
 				if (sCallSite.containsInvokeExpr() && methodDef.getParameters() != null
 						&& methodDef.getParameters().length > 0)
-					for (int i = 0; i < sCallSite.getInvokeExpr().getArgCount(); i++)
-						if (methodDef.getParameters().length > i)
-							for (AccessPathTuple apt : methodDef.getParameters()[i])
-								if (apt.getSourceSinkType().isSource())
+					for (int i = 0; i < sCallSite.getInvokeExpr().getArgCount(); i++) {
+						if (methodDef.getParameters().length > i) {
+							for (AccessPathTuple apt : methodDef.getParameters()[i]) {
+								if (apt.getSourceSinkType().isSource()) {
 									aps.add(apt.toAccessPath(sCallSite.getInvokeExpr().getArg(i), manager, true));
+									apTuples.add(apt);
+								}
+							}
+						}
+					}
 				break;
 			default:
 				return null;
@@ -139,35 +157,46 @@ public class AccessPathBasedSourceSinkManager extends AndroidSourceSinkManager {
 			FieldSourceSinkDefinition fieldDef = (FieldSourceSinkDefinition) def;
 			if (sCallSite instanceof AssignStmt && fieldDef.getAccessPaths() != null) {
 				AssignStmt assignStmt = (AssignStmt) sCallSite;
-				for (AccessPathTuple apt : fieldDef.getAccessPaths())
-					if (apt.getSourceSinkType().isSource())
+				for (AccessPathTuple apt : fieldDef.getAccessPaths()) {
+					if (apt.getSourceSinkType().isSource()) {
 						aps.add(apt.toAccessPath(assignStmt.getLeftOp(), manager, false));
+						apTuples.add(apt);
+					}
+				}
 			}
 		} else if (def instanceof StatementSourceSinkDefinition) {
 			StatementSourceSinkDefinition ssdef = (StatementSourceSinkDefinition) def;
-			for (AccessPathTuple apt : ssdef.getAccessPaths())
-				if (apt.getSourceSinkType().isSource())
+			for (AccessPathTuple apt : ssdef.getAccessPaths()) {
+				if (apt.getSourceSinkType().isSource()) {
 					aps.add(apt.toAccessPath(ssdef.getLocal(), manager, true));
+					apTuples.add(apt);
+				}
+			}
 		}
 
 		// If we don't have any information, we cannot continue
 		if (aps.isEmpty())
 			return null;
 
-		return new SourceInfo(def, aps);
+		return new SourceInfo(apDef.filter(apTuples), aps);
 	}
 
 	@Override
 	public SinkInfo getSinkInfo(Stmt sCallSite, InfoflowManager manager, AccessPath sourceAccessPath) {
-		SourceSinkDefinition def = getSinkDefinition(sCallSite, manager, sourceAccessPath);
+		ISourceSinkDefinition def = getSinkDefinition(sCallSite, manager, sourceAccessPath);
 		if (def == null)
 			return null;
 
+		// We need the access paths
+		if (!(def instanceof IAccessPathBasedSourceSinkDefinition))
+			return super.getSinkInfo(sCallSite, manager, sourceAccessPath);
+		IAccessPathBasedSourceSinkDefinition apDef = (IAccessPathBasedSourceSinkDefinition) def;
+
 		// If we have no precise information, we conservatively assume that
 		// everything is tainted without looking at the access path. Only
 		// exception: separate compilation assumption
-		if (def.isEmpty() && sCallSite.containsInvokeExpr()) {
-			if (SystemClassHandler.isTaintVisible(sourceAccessPath, sCallSite.getInvokeExpr().getMethod()))
+		if (apDef.isEmpty() && sCallSite.containsInvokeExpr()) {
+			if (SystemClassHandler.v().isTaintVisible(sourceAccessPath, sCallSite.getInvokeExpr().getMethod()))
 				return new SinkInfo(def);
 			else
 				return null;
@@ -187,7 +216,7 @@ public class AccessPathBasedSourceSinkManager extends AndroidSourceSinkManager {
 			if (sCallSite.getInvokeExpr() instanceof InstanceInvokeExpr && methodDef.getBaseObjects() != null) {
 				for (AccessPathTuple apt : methodDef.getBaseObjects())
 					if (apt.getSourceSinkType().isSink() && accessPathMatches(sourceAccessPath, apt))
-						return new SinkInfo(def);
+						return new SinkInfo(apDef.filter(Collections.singleton(apt)));
 			}
 
 			// Check whether a parameter matches our definition
@@ -199,7 +228,7 @@ public class AccessPathBasedSourceSinkManager extends AndroidSourceSinkManager {
 						if (methodDef.getParameters().length > i)
 							for (AccessPathTuple apt : methodDef.getParameters()[i])
 								if (apt.getSourceSinkType().isSink() && accessPathMatches(sourceAccessPath, apt))
-									return new SinkInfo(def);
+									return new SinkInfo(apDef.filter(Collections.singleton(apt)));
 					}
 			}
 		} else if (def instanceof FieldSourceSinkDefinition) {
@@ -209,13 +238,13 @@ public class AccessPathBasedSourceSinkManager extends AndroidSourceSinkManager {
 			if (sCallSite instanceof AssignStmt && fieldDef.getAccessPaths() != null) {
 				for (AccessPathTuple apt : fieldDef.getAccessPaths())
 					if (apt.getSourceSinkType().isSink() && accessPathMatches(sourceAccessPath, apt))
-						return new SinkInfo(def);
+						return new SinkInfo(apDef.filter(Collections.singleton(apt)));
 			}
 		} else if (def instanceof StatementSourceSinkDefinition) {
 			StatementSourceSinkDefinition ssdef = (StatementSourceSinkDefinition) def;
 			for (AccessPathTuple apt : ssdef.getAccessPaths())
 				if (apt.getSourceSinkType().isSink() && accessPathMatches(sourceAccessPath, apt))
-					return new SinkInfo(def);
+					return new SinkInfo(apDef.filter(Collections.singleton(apt)));
 		}
 
 		// No matching access path found
@@ -225,10 +254,8 @@ public class AccessPathBasedSourceSinkManager extends AndroidSourceSinkManager {
 	/**
 	 * Checks whether the given access path matches the given definition
 	 * 
-	 * @param sourceAccessPath
-	 *            The access path to check
-	 * @param apt
-	 *            The definition against which to check the access path
+	 * @param sourceAccessPath The access path to check
+	 * @param apt              The definition against which to check the access path
 	 * @return True if the given access path matches the given definition, otherwise
 	 *         false
 	 */
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/source/AndroidSourceSinkManager.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/source/AndroidSourceSinkManager.java
index 18e3f37..d2ff2a3 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/source/AndroidSourceSinkManager.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/source/AndroidSourceSinkManager.java
@@ -10,13 +10,8 @@
  ******************************************************************************/
 package soot.jimple.infoflow.android.source;
 
-import static soot.SootClass.DANGLING;
-
-import java.util.Collection;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
@@ -25,152 +20,65 @@ import java.util.Set;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
-
-import heros.solver.IDESolver;
-import heros.solver.Pair;
 import soot.Local;
 import soot.Scene;
 import soot.SootClass;
 import soot.SootField;
 import soot.SootMethod;
 import soot.Unit;
-import soot.VoidType;
 import soot.jimple.AssignStmt;
-import soot.jimple.DefinitionStmt;
 import soot.jimple.FieldRef;
-import soot.jimple.IdentityStmt;
-import soot.jimple.InstanceInvokeExpr;
 import soot.jimple.IntConstant;
 import soot.jimple.InvokeExpr;
-import soot.jimple.ParameterRef;
-import soot.jimple.ReturnStmt;
 import soot.jimple.Stmt;
 import soot.jimple.StringConstant;
+import soot.jimple.infoflow.InfoflowConfiguration.LayoutMatchingMode;
 import soot.jimple.infoflow.InfoflowManager;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CallbackSourceMode;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.LayoutMatchingMode;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.SourceSinkConfiguration;
-import soot.jimple.infoflow.android.callbacks.CallbackDefinition;
-import soot.jimple.infoflow.android.callbacks.CallbackDefinition.CallbackType;
+import soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition;
+import soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition.CallbackType;
 import soot.jimple.infoflow.android.entryPointCreators.AndroidEntryPointUtils;
 import soot.jimple.infoflow.android.resources.ARSCFileParser;
 import soot.jimple.infoflow.android.resources.ARSCFileParser.AbstractResource;
 import soot.jimple.infoflow.android.resources.ARSCFileParser.ResPackage;
 import soot.jimple.infoflow.android.resources.controls.AndroidLayoutControl;
+import soot.jimple.infoflow.callbacks.CallbackDefinition;
 import soot.jimple.infoflow.data.AccessPath;
-import soot.jimple.infoflow.data.AccessPath.ArrayTaintType;
-import soot.jimple.infoflow.data.SootMethodAndClass;
 import soot.jimple.infoflow.solver.cfg.IInfoflowCFG;
-import soot.jimple.infoflow.sourcesSinks.definitions.AccessPathTuple;
-import soot.jimple.infoflow.sourcesSinks.definitions.FieldSourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition.CallType;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
-import soot.jimple.infoflow.sourcesSinks.definitions.StatementSourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.manager.BaseSourceSinkManager;
 import soot.jimple.infoflow.sourcesSinks.manager.IOneSourceAtATimeManager;
 import soot.jimple.infoflow.sourcesSinks.manager.ISourceSinkManager;
-import soot.jimple.infoflow.sourcesSinks.manager.SinkInfo;
-import soot.jimple.infoflow.sourcesSinks.manager.SourceInfo;
-import soot.jimple.infoflow.util.SystemClassHandler;
-import soot.jimple.infoflow.values.IValueProvider;
-import soot.jimple.infoflow.values.SimpleConstantValueProvider;
 import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
 import soot.jimple.toolkits.scalar.ConstantPropagatorAndFolder;
 import soot.tagkit.IntegerConstantValueTag;
 import soot.tagkit.Tag;
-import soot.util.HashMultiMap;
-import soot.util.MultiMap;
 
 /**
  * SourceManager implementation for AndroidSources
  *
  * @author Steven Arzt
  */
-public class AndroidSourceSinkManager implements ISourceSinkManager, IOneSourceAtATimeManager {
-
-	private final static String GLOBAL_SIG = "--GLOBAL--";
+public class AndroidSourceSinkManager extends BaseSourceSinkManager
+		implements ISourceSinkManager, IOneSourceAtATimeManager {
 
 	private final Logger logger = LoggerFactory.getLogger(getClass());
 
-	/**
-	 * Types of sources supported by this SourceSinkManager
-	 *
-	 * @author Steven Arzt
-	 */
-	public static enum SourceType {
-		/**
-		 * Not a source
-		 */
-		NoSource,
-		/**
-		 * The data is obtained via a method call
-		 */
-		MethodCall,
-		/**
-		 * The data is retrieved through a callback parameter
-		 */
-		Callback,
-		/**
-		 * The data is read from a UI element
-		 */
-		UISource
-	}
-
 	protected final static String Activity_FindViewById = "<android.app.Activity: android.view.View findViewById(int)>";
 	protected final static String View_FindViewById = "<android.view.View: android.view.View findViewById(int)>";
 
 	protected SootMethod smActivityFindViewById;
 	protected SootMethod smViewFindViewById;
 
-	protected MultiMap<String, SourceSinkDefinition> sourceDefs;
-	protected MultiMap<String, SourceSinkDefinition> sinkDefs;
-
-	protected Map<SootMethod, SourceSinkDefinition> sourceMethods;
-	protected Map<Stmt, SourceSinkDefinition> sourceStatements;
-	protected Map<SootMethod, SourceSinkDefinition> sinkMethods;
-	protected Map<SootMethod, SourceSinkDefinition> sinkReturnMethods;
-	protected Map<SootMethod, CallbackDefinition> callbackMethods;
-	protected Map<SootField, SourceSinkDefinition> sourceFields;
-	protected Map<SootField, SourceSinkDefinition> sinkFields;
-	protected Map<Stmt, SourceSinkDefinition> sinkStatements;
-
-	protected final SourceSinkConfiguration sourceSinkConfig;
 	protected final Map<Integer, AndroidLayoutControl> layoutControls;
 	protected List<ARSCFileParser.ResPackage> resourcePackages;
-
 	protected String appPackageName = "";
-	protected final Set<SootMethod> excludedMethods = new HashSet<>();
-
 	protected final Set<SootMethod> analyzedLayoutMethods = new HashSet<SootMethod>();
 	protected SootClass[] iccBaseClasses = null;
 	protected AndroidEntryPointUtils entryPointUtils = new AndroidEntryPointUtils();
 
-	protected boolean oneSourceAtATime = false;
-	protected SourceType osaatType = SourceType.MethodCall;
-	protected Iterator<SootMethod> osaatIterator = null;
-	protected SootMethod currentSource = null;
-	protected IValueProvider valueProvider = new SimpleConstantValueProvider();
-
-	protected final LoadingCache<SootClass, Collection<SootClass>> interfacesOf = IDESolver.DEFAULT_CACHE_BUILDER
-			.build(new CacheLoader<SootClass, Collection<SootClass>>() {
-
-				@Override
-				public Collection<SootClass> load(SootClass sc) throws Exception {
-					Set<SootClass> set = new HashSet<SootClass>(sc.getInterfaceCount());
-					for (SootClass i : sc.getInterfaces()) {
-						set.add(i);
-						set.addAll(interfacesOf.getUnchecked(i));
-					}
-					if (sc.hasSuperclass())
-						set.addAll(interfacesOf.getUnchecked(sc.getSuperclass()));
-					return set;
-				}
-
-			});
-
 	/**
 	 * Creates a new instance of the {@link AndroidSourceSinkManager} class with
 	 * either strong or weak matching.
@@ -179,9 +87,9 @@ public class AndroidSourceSinkManager implements ISourceSinkManager, IOneSourceA
 	 * @param sinks   The list of sink methods
 	 * @param config  The configuration of the data flow analyzer
 	 */
-	public AndroidSourceSinkManager(Set<SourceSinkDefinition> sources, Set<SourceSinkDefinition> sinks,
-			InfoflowAndroidConfiguration config) {
-		this(sources, sinks, Collections.<CallbackDefinition>emptySet(), config, null);
+	public AndroidSourceSinkManager(Set<? extends ISourceSinkDefinition> sources,
+			Set<? extends ISourceSinkDefinition> sinks, InfoflowAndroidConfiguration config) {
+		this(sources, sinks, Collections.<AndroidCallbackDefinition>emptySet(), config, null);
 	}
 
 	/**
@@ -203,535 +111,68 @@ public class AndroidSourceSinkManager implements ISourceSinkManager, IOneSourceA
 	 * @param layoutControls  A map from reference identifiers to the respective
 	 *                        Android layout controls
 	 */
-	public AndroidSourceSinkManager(Set<SourceSinkDefinition> sources, Set<SourceSinkDefinition> sinks,
-			Set<CallbackDefinition> callbackMethods, InfoflowAndroidConfiguration config,
-			Map<Integer, AndroidLayoutControl> layoutControls) {
-		this.sourceSinkConfig = config.getSourceSinkConfig();
-
-		this.sourceDefs = new HashMultiMap<>();
-		for (SourceSinkDefinition am : sources)
-			this.sourceDefs.put(getSignature(am), am);
-
-		this.sinkDefs = new HashMultiMap<>();
-		for (SourceSinkDefinition am : sinks)
-			this.sinkDefs.put(getSignature(am), am);
-
-		this.callbackMethods = new HashMap<>();
-		for (CallbackDefinition cb : callbackMethods)
-			this.callbackMethods.put(cb.getTargetMethod(), cb);
-
+	public AndroidSourceSinkManager(Set<? extends ISourceSinkDefinition> sources,
+			Set<? extends ISourceSinkDefinition> sinks, Set<AndroidCallbackDefinition> callbackMethods,
+			InfoflowAndroidConfiguration config, Map<Integer, AndroidLayoutControl> layoutControls) {
+		super(sources, sinks, callbackMethods, config);
 		this.layoutControls = layoutControls;
-
-		logger.info(String.format("Created a SourceSinkManager with %d sources, %d sinks, and %d callback methods.",
-				this.sourceDefs.size(), this.sinkDefs.size(), this.callbackMethods.size()));
-	}
-
-	/**
-	 * Gets the field or method signature of the given source/sink definition
-	 *
-	 * @param am The source/sink definition for which to get a Soot signature
-	 * @return The Soot signature associated with the given source/sink definition
-	 */
-	private String getSignature(SourceSinkDefinition am) {
-		if (am instanceof MethodSourceSinkDefinition) {
-			MethodSourceSinkDefinition methodSource = (MethodSourceSinkDefinition) am;
-			return methodSource.getMethod().getSignature();
-		} else if (am instanceof FieldSourceSinkDefinition) {
-			FieldSourceSinkDefinition fieldSource = (FieldSourceSinkDefinition) am;
-			return fieldSource.getFieldSignature();
-		} else if (am instanceof StatementSourceSinkDefinition)
-			return GLOBAL_SIG;
-		else
-			throw new RuntimeException(
-					String.format("Invalid type of source/sink definition: %s", am.getClass().getName()));
-	}
-
-	/**
-	 * Gets the sink definition for the given call site and tainted access path
-	 *
-	 * @param sCallSite The call site
-	 * @param manager   The manager object providing access to the configuration and
-	 *                  the interprocedural control flow graph
-	 * @param ap        The incoming tainted access path
-	 * @return The sink definition of the method that is called at the given call
-	 *         site if such a definition exists, otherwise null
-	 */
-	protected SourceSinkDefinition getSinkDefinition(Stmt sCallSite, InfoflowManager manager, AccessPath ap) {
-		// Do we have a statement-specific definition?
-		{
-			SourceSinkDefinition def = sinkStatements.get(sCallSite);
-			if (def != null)
-				return def;
-		}
-
-		if (sCallSite.containsInvokeExpr()) {
-			// Check whether the taint is even visible inside the callee
-			final SootMethod callee = sCallSite.getInvokeExpr().getMethod();
-			if (!SystemClassHandler.isTaintVisible(ap, callee))
-				return null;
-
-			// Do we have a direct hit?
-			{
-				SourceSinkDefinition def = this.sinkMethods.get(sCallSite.getInvokeExpr().getMethod());
-				if (def != null)
-					return def;
-			}
-
-			final SootClass sc = callee.getDeclaringClass();
-			final String subSig = callee.getSubSignature();
-
-			// Check whether we have any of the interfaces on the list
-			for (SootClass i : interfacesOf.getUnchecked(sCallSite.getInvokeExpr().getMethod().getDeclaringClass())) {
-				if (i.declaresMethod(subSig)) {
-					SourceSinkDefinition def = this.sinkMethods.get(i.getMethod(subSig));
-					if (def != null)
-						return def;
-				}
-			}
-
-			// Ask the CFG in case we don't know any better
-			for (SootMethod sm : manager.getICFG().getCalleesOfCallAt(sCallSite)) {
-				SourceSinkDefinition def = this.sinkMethods.get(sm);
-				if (def != null)
-					return def;
-			}
-
-			// If the target method is in a phantom class, we scan the hierarchy
-			// upwards to see whether we have a sink definition for a parent
-			// class
-			if (callee.getDeclaringClass().isPhantom()) {
-				SourceSinkDefinition def = findDefinitionInHierarchy(callee, this.sinkMethods);
-				if (def != null)
-					return def;
-			}
-
-			// Do not consider ICC methods as sinks if only the base object is
-			// tainted
-			boolean isParamTainted = false;
-			if (ap != null) {
-				if (!sc.isInterface() && !ap.isStaticFieldRef()) {
-					for (int i = 0; i < sCallSite.getInvokeExpr().getArgCount(); i++) {
-						if (sCallSite.getInvokeExpr().getArg(i) == ap.getPlainValue()) {
-							isParamTainted = true;
-							break;
-						}
-					}
-				}
-			}
-
-			if (isParamTainted || ap == null) {
-				for (SootClass clazz : iccBaseClasses) {
-					if (Scene.v().getOrMakeFastHierarchy().isSubclass(sc, clazz)) {
-						SootMethod sm = clazz.getMethodUnsafe(subSig);
-						if (sm != null) {
-							SourceSinkDefinition def = this.sinkMethods.get(sm);
-							if (def != null)
-								return def;
-							break;
-						}
-					}
-				}
-			}
-		} else if (sCallSite instanceof AssignStmt) {
-			// Check if the target is a sink field
-			AssignStmt assignStmt = (AssignStmt) sCallSite;
-			if (assignStmt.getLeftOp() instanceof FieldRef) {
-				FieldRef fieldRef = (FieldRef) assignStmt.getLeftOp();
-				SourceSinkDefinition def = sinkFields.get(fieldRef.getField());
-				if (def != null)
-					return def;
-			}
-		} else if (sCallSite instanceof ReturnStmt) {
-			return sinkReturnMethods.get(manager.getICFG().getMethodOf(sCallSite));
-		}
-
-		return null;
-	}
-
-	/**
-	 * Scans the hierarchy of the class containing the given method to find any
-	 * implementations of the same method further up in the hierarchy for which
-	 * there is a SourceSinkDefinition in the given map
-	 *
-	 * @param callee The method for which to look for a SourceSinkDefinition
-	 * @param map    A map from methods to their corresponding SourceSinkDefinitions
-	 * @return A SourceSinKDefinition for an implementation of the given method
-	 *         somewhere up in the class hiearchy if it exists, otherwise null.
-	 */
-	private static SourceSinkDefinition findDefinitionInHierarchy(SootMethod callee,
-			Map<SootMethod, SourceSinkDefinition> map) {
-		final String subSig = callee.getSubSignature();
-		SootClass curClass = callee.getDeclaringClass();
-		while (curClass != null) {
-			// Does the current class declare the requested method?
-			SootMethod curMethod = curClass.getMethodUnsafe(subSig);
-			if (curMethod != null) {
-				SourceSinkDefinition def = map.get(curMethod);
-				if (def != null) {
-					// Patch the map to contain a direct link
-					map.put(callee, def);
-					return def;
-				}
-			}
-
-			// Try the next class up the hierarchy
-			if (curClass.hasSuperclass() && curClass.isPhantom())
-				curClass = curClass.getSuperclass();
-			else
-				curClass = null;
-		}
-
-		return null;
-	}
-
-	@Override
-	public SinkInfo getSinkInfo(Stmt sCallSite, InfoflowManager manager, AccessPath ap) {
-		SourceSinkDefinition def = getSinkDefinition(sCallSite, manager, ap);
-		return def == null ? null : new SinkInfo(def);
 	}
 
 	@Override
-	public SourceInfo getSourceInfo(Stmt sCallSite, InfoflowManager manager) {
-		// Do not look for sources in excluded methods
-		if (excludedMethods.contains(manager.getICFG().getMethodOf(sCallSite)))
-			return null;
-
-		SourceSinkDefinition def = getSource(sCallSite, manager.getICFG());
-		return createSourceInfo(sCallSite, manager, def);
-	}
-
-	protected SourceInfo createSourceInfo(Stmt sCallSite, InfoflowManager manager, SourceSinkDefinition def) {
-		// Do we have data at all?
-		if (def == null)
-			return null;
-
-		// If we don't have an invocation, we just taint the left side of the
-		// assignment
-		if (!sCallSite.containsInvokeExpr()) {
-			if (sCallSite instanceof DefinitionStmt) {
-				DefinitionStmt defStmt = (DefinitionStmt) sCallSite;
-				return new SourceInfo(def, manager.getAccessPathFactory().createAccessPath(defStmt.getLeftOp(), null,
-						null, null, true, false, true, ArrayTaintType.ContentsAndLength, false));
-			}
-			return null;
-		}
-
-		// If this is a method call and we have a return value, we taint it.
-		// Otherwise, if we have an instance invocation, we taint the base
-		// object
-		final InvokeExpr iexpr = sCallSite.getInvokeExpr();
-		if (sCallSite instanceof DefinitionStmt && iexpr.getMethod().getReturnType() != null) {
-			DefinitionStmt defStmt = (DefinitionStmt) sCallSite;
-			// no immutable aliases, we overwrite the return values as a whole
-			return new SourceInfo(def, manager.getAccessPathFactory().createAccessPath(defStmt.getLeftOp(), null, null,
-					null, true, false, true, ArrayTaintType.ContentsAndLength, false));
-		} else if (iexpr instanceof InstanceInvokeExpr && iexpr.getMethod().getReturnType() == VoidType.v()) {
-			InstanceInvokeExpr iinv = (InstanceInvokeExpr) sCallSite.getInvokeExpr();
-			return new SourceInfo(def, manager.getAccessPathFactory().createAccessPath(iinv.getBase(), true));
-		} else
-			return null;
-	}
-
-	/**
-	 * Checks whether the given method is registered as a source method. If so,
-	 * returns the corresponding definition, otherwise null.
-	 *
-	 * @param method The method to check
-	 * @return The respective source definition if the given method is a source
-	 *         method, otherwise null
-	 */
-	protected SourceSinkDefinition getSourceMethod(SootMethod method) {
-		if (oneSourceAtATime && (osaatType != SourceType.MethodCall || currentSource != method))
-			return null;
-		return this.sourceMethods.get(method);
-	}
-
-	/**
-	 * Checks whether the given method is registered as a source method
-	 *
-	 * @param method The method to check
-	 * @return True if the given method is a source method, otherwise false
-	 */
-	protected SourceSinkDefinition getSourceDefinition(SootMethod method) {
-		if (oneSourceAtATime) {
-			if (osaatType == SourceType.MethodCall && currentSource == method)
-				return this.sourceMethods.get(method);
-			else
-				return null;
-		} else
-			return this.sourceMethods.get(method);
-	}
-
-	/**
-	 * Checks whether the given method is registered as a callback method. If so,
-	 * the corresponding source definition is returned, otherwise null is returned.
-	 *
-	 * @param method The method to check
-	 * @return The source definition object if the given method is a callback
-	 *         method, otherwise null
-	 */
-	protected CallbackDefinition getCallbackDefinition(SootMethod method) {
-		if (oneSourceAtATime) {
-			if (osaatType == SourceType.Callback && currentSource == method)
-				return this.callbackMethods.get(method);
-			else
-				return null;
-		} else
-			return this.callbackMethods.get(method);
-	}
-
-	/**
-	 * Checks whether the given statement is a source, i.e. introduces new
-	 * information into the application. If so, the source definition is returned,
-	 * otherwise null
-	 *
-	 * @param sCallSite The statement to check for a source
-	 * @param cfg       An interprocedural CFG containing the statement
-	 * @return The definition of the discovered source if the given statement is a
-	 *         source, null otherwise
-	 */
-	protected SourceSinkDefinition getSource(Stmt sCallSite, IInfoflowCFG cfg) {
-		assert cfg != null;
-		assert cfg instanceof BiDiInterproceduralCFG;
-
-		// Do we have a statement-specific definition?
-		{
-			SourceSinkDefinition def = sourceStatements.get(sCallSite);
-			if (def != null)
-				return def;
-		}
-
-		SourceSinkDefinition def = null;
-		if ((!oneSourceAtATime || osaatType == SourceType.MethodCall) && sCallSite.containsInvokeExpr()) {
-			// This might be a normal source method
-			final SootMethod callee = sCallSite.getInvokeExpr().getMethod();
-			def = getSourceDefinition(callee);
-			if (def != null)
-				return def;
-
-			// Check whether we have any of the interfaces on the list
-			final String subSig = callee.getSubSignature();
-			for (SootClass i : interfacesOf.getUnchecked(callee.getDeclaringClass())) {
-				SootMethod m = i.getMethodUnsafe(subSig);
-				if (m != null) {
-					def = getSourceDefinition(m);
-					if (def != null)
-						return def;
-				}
-			}
-
-			// Ask the CFG in case we don't know any better
-			for (SootMethod sm : cfg.getCalleesOfCallAt(sCallSite)) {
-				def = getSourceDefinition(sm);
-				if (def != null)
-					return def;
-			}
-
-			// If the target method is in a phantom class, we scan the hierarchy
-			// upwards
-			// to see whether we have a sink definition for a parent class
-			if (callee.getDeclaringClass().isPhantom()) {
-				def = findDefinitionInHierarchy(callee, this.sourceMethods);
-				if (def != null)
-					return def;
-			}
-		}
-
-		// This call might read out sensitive data from the UI
-		if ((!oneSourceAtATime || osaatType == SourceType.UISource)) {
-			def = getUISourceDefinition(sCallSite, cfg);
-			if (def != null)
-				return def;
-		}
-
-		// This statement might access a sensitive parameter in a callback
-		// method
-		def = checkCallbackParamSource(sCallSite, cfg);
-		if (def != null)
-			return def;
-
-		// This statement may read sensitive data from a field
-		def = checkFieldSource(sCallSite, cfg);
-		if (def != null)
-			return def;
-
-		return null;
-	}
-
-	/**
-	 * Checks whether the given statement accesses a field that has been marked as a
-	 * source
-	 *
-	 * @param stmt The statement to check
-	 * @param cfg  The interprocedural control flow graph
-	 * @return The source and sink definition that corresponds to the detected field
-	 *         source if the given statement is a source, otherwise null
-	 */
-	private SourceSinkDefinition checkFieldSource(Stmt stmt, IInfoflowCFG cfg) {
-		if (stmt instanceof AssignStmt) {
-			AssignStmt assignStmt = (AssignStmt) stmt;
-			if (assignStmt.getRightOp() instanceof FieldRef) {
-				FieldRef fieldRef = (FieldRef) assignStmt.getRightOp();
-				return sourceFields.get(fieldRef.getField());
-			}
-		}
-		return null;
-	}
-
-	/**
-	 * Checks whether the given statement obtains data from a callback source
-	 *
-	 * @param sCallSite The statement to check
-	 * @param cfg       The interprocedural control flow graph
-	 * @return The source and sink definition that corresponds to the detected
-	 *         callback source if the given statement is a source, otherwise null
-	 */
-	protected SourceSinkDefinition checkCallbackParamSource(Stmt sCallSite, IInfoflowCFG cfg) {
-		// Do we handle callback sources at all?
-		if (sourceSinkConfig.getCallbackSourceMode() == CallbackSourceMode.NoParametersAsSources)
-			return null;
-		if (oneSourceAtATime && osaatType != SourceType.Callback)
-			return null;
-
-		// Callback sources can only be parameter references
-		if (!(sCallSite instanceof IdentityStmt))
-			return null;
-		IdentityStmt is = (IdentityStmt) sCallSite;
-		if (!(is.getRightOp() instanceof ParameterRef))
-			return null;
-		ParameterRef paramRef = (ParameterRef) is.getRightOp();
-
-		// We do not consider the parameters of lifecycle methods as
-		// sources by default
-		SootMethod parentMethod = cfg.getMethodOf(sCallSite);
-		if (parentMethod == null)
-			return null;
-		if (!sourceSinkConfig.getEnableLifecycleSources() && entryPointUtils.isEntryPointMethod(parentMethod))
-			return null;
-
-		// Obtain the callback definition for the method in which this parameter
-		// access occurs
-		CallbackDefinition def = getCallbackDefinition(parentMethod);
-		if (def == null)
-			return null;
-
-		// If this is a UI element, we only consider it as a
-		// source if we actually want to taint all UI elements
-		if (def.getCallbackType() == CallbackType.Widget
-				&& sourceSinkConfig.getLayoutMatchingMode() != LayoutMatchingMode.MatchAll)
-			return null;
+	public void initialize() {
+		super.initialize();
 
-		// Do we match all callbacks?
-		if (sourceSinkConfig.getCallbackSourceMode() == CallbackSourceMode.AllParametersAsSources)
-			return MethodSourceSinkDefinition.createParameterSource(paramRef.getIndex(), CallType.Callback);
+		// Get some frequently-used methods
+		this.smActivityFindViewById = Scene.v().grabMethod(Activity_FindViewById);
+		this.smViewFindViewById = Scene.v().grabMethod(View_FindViewById);
 
-		// Do we only match registered callback methods?
-		SourceSinkDefinition sourceSinkDef = this.sourceMethods.get(def.getParentMethod());
-		if (sourceSinkDef instanceof MethodSourceSinkDefinition) {
-			MethodSourceSinkDefinition methodDef = (MethodSourceSinkDefinition) sourceSinkDef;
-			if (sourceSinkConfig.getCallbackSourceMode() == CallbackSourceMode.SourceListOnly
-					&& sourceSinkDef != null) {
-				// Check the parameter index
-				Set<AccessPathTuple>[] methodParamDefs = methodDef.getParameters();
-				if (methodParamDefs != null && methodParamDefs.length > paramRef.getIndex()) {
-					Set<AccessPathTuple> apTuples = methodDef.getParameters()[paramRef.getIndex()];
-					if (apTuples != null && !apTuples.isEmpty()) {
-						for (AccessPathTuple curTuple : apTuples)
-							if (curTuple.getSourceSinkType().isSource())
-								return sourceSinkDef;
-					}
-				}
-			}
-		}
+		// For ICC methods (e.g., startService), the classes name of these
+		// methods may change through user's definition. We match all the
+		// ICC methods through their base class name.
+		if (iccBaseClasses == null)
+			iccBaseClasses = new SootClass[] { Scene.v().getSootClass("android.content.Context"), // activity,
+					// service
+					// and
+					// broadcast
+					Scene.v().getSootClass("android.content.ContentResolver"), // provider
+					Scene.v().getSootClass("android.app.Activity") // some
+					// methods
+					// (e.g.,
+					// onActivityResult)
+					// only
+					// defined
+					// in
+					// Activity
+					// class
+			};
 
-		return null;
 	}
 
 	/**
-	 * Checks whether the given call site indicates a UI source, e.g. a password
-	 * input. If so, creates a {@link SourceSinkDefinition} for it
+	 * Finds the given resource in the given package
 	 *
-	 * @param sCallSite The call site that may potentially read data from a
-	 *                  sensitive UI control
-	 * @param cfg       The bidirectional control flow graph
-	 * @return The generated {@link SourceSinkDefinition} if the given call site
-	 *         reads data from a UI source, null otherwise
+	 * @param resName     The name of the resource to retrieve
+	 * @param resID
+	 * @param packageName The name of the package in which to look for the resource
+	 * @return The specified resource if available, otherwise null
 	 */
-	private SourceSinkDefinition getUISourceDefinition(Stmt sCallSite, IInfoflowCFG cfg) {
-		// If we match input controls, we need to check whether this is a call
-		// to one of the well-known resource handling functions in Android
-		if (sourceSinkConfig.getLayoutMatchingMode() == LayoutMatchingMode.NoMatch || !sCallSite.containsInvokeExpr())
-			return null;
-
-		// If nobody cares about the value obtained from the UI, we can ignore
-		// the call
-		if (!(sCallSite instanceof AssignStmt))
-			return null;
-
-		InvokeExpr ie = sCallSite.getInvokeExpr();
-		SootMethod callee = ie.getMethod();
+	private AbstractResource findResource(String resName, String resID, String packageName) {
+		// Find the correct package
+		for (ARSCFileParser.ResPackage pkg : this.resourcePackages) {
+			// If we don't have any package specification, we pick the app's
+			// default package
+			boolean matches = (packageName == null || packageName.isEmpty())
+					&& pkg.getPackageName().equals(this.appPackageName);
+			matches |= pkg.getPackageName().equals(packageName);
+			if (!matches)
+				continue;
 
-		// Is this a call to resource-handling method?
-		boolean isResourceCall = callee == smActivityFindViewById || callee == smViewFindViewById;
-		if (!isResourceCall) {
-			for (SootMethod cfgCallee : cfg.getCalleesOfCallAt(sCallSite)) {
-				if (cfgCallee == smActivityFindViewById || cfgCallee == smViewFindViewById) {
-					isResourceCall = true;
-					break;
+			// We have found a suitable package, now look for the resource
+			for (ARSCFileParser.ResType type : pkg.getDeclaredTypes())
+				if (type.getTypeName().equals(resID)) {
+					AbstractResource res = type.getFirstResource(resName);
+					return res;
 				}
-			}
-		}
-
-		// We need special treatment for the Android support classes
-		if (!isResourceCall) {
-			if (callee.getDeclaringClass().getName().startsWith("android.support.v")
-					&& callee.getSubSignature().equals(smActivityFindViewById.getSubSignature()))
-				isResourceCall = true;
-		}
-
-		if (isResourceCall) {
-			// If we match all controls, we don't care about the specific
-			// control we're dealing with
-			if (sourceSinkConfig.getLayoutMatchingMode() == LayoutMatchingMode.MatchAll) {
-				return MethodSourceSinkDefinition.createReturnSource(CallType.MethodCall);
-			}
-
-			// If we don't have a layout control list, we cannot perform any
-			// more specific checks
-			if (this.layoutControls == null)
-				return null;
-
-			// Perform a constant propagation inside this method exactly
-			// once
-			SootMethod uiMethod = cfg.getMethodOf(sCallSite);
-			if (analyzedLayoutMethods.add(uiMethod))
-				ConstantPropagatorAndFolder.v().transform(uiMethod.getActiveBody());
-
-			// If we match specific controls, we need to get the ID of
-			// control and look up the respective data object
-			if (ie.getArgCount() != 1) {
-				logger.error("Framework method call with unexpected number of arguments");
-				return null;
-			}
-
-			Integer id = valueProvider.getValue(uiMethod, sCallSite, ie.getArg(0), Integer.class);
-			if (id == null && ie.getArg(0) instanceof Local) {
-				id = findLastResIDAssignment(sCallSite, (Local) ie.getArg(0), cfg,
-						new HashSet<Stmt>(cfg.getMethodOf(sCallSite).getActiveBody().getUnits().size()));
-			}
-			if (id == null) {
-				logger.debug("Could not find assignment to local " + ((Local) ie.getArg(0)).getName() + " in method "
-						+ cfg.getMethodOf(sCallSite).getSignature());
-				return null;
-			}
-
-			AndroidLayoutControl control = this.layoutControls.get(id);
-			if (control == null)
-				return null;
-			if (sourceSinkConfig.getLayoutMatchingMode() == LayoutMatchingMode.MatchSensitiveOnly
-					&& control.isSensitive()) {
-				return control.getSourceDefinition();
-			}
 		}
 		return null;
 	}
@@ -818,32 +259,23 @@ public class AndroidSourceSinkManager implements ISourceSinkManager, IOneSourceA
 	}
 
 	/**
-	 * Finds the given resource in the given package
+	 * Sets the resource packages to be used for finding sensitive layout controls
+	 * as sources
 	 *
-	 * @param resName     The name of the resource to retrieve
-	 * @param resID
-	 * @param packageName The name of the package in which to look for the resource
-	 * @return The specified resource if available, otherwise null
+	 * @param resourcePackages The resource packages to be used for looking up
+	 *                         layout controls
 	 */
-	private AbstractResource findResource(String resName, String resID, String packageName) {
-		// Find the correct package
-		for (ARSCFileParser.ResPackage pkg : this.resourcePackages) {
-			// If we don't have any package specification, we pick the app's
-			// default package
-			boolean matches = (packageName == null || packageName.isEmpty())
-					&& pkg.getPackageName().equals(this.appPackageName);
-			matches |= pkg.getPackageName().equals(packageName);
-			if (!matches)
-				continue;
+	public void setResourcePackages(List<ResPackage> resourcePackages) {
+		this.resourcePackages = resourcePackages;
+	}
 
-			// We have found a suitable package, now look for the resource
-			for (ARSCFileParser.ResType type : pkg.getDeclaredTypes())
-				if (type.getTypeName().equals(resID)) {
-					AbstractResource res = type.getFirstResource(resName);
-					return res;
-				}
-		}
-		return null;
+	/**
+	 * Sets the name of the app's base package
+	 *
+	 * @param appPackageName The name of the app's base package
+	 */
+	public void setAppPackageName(String appPackageName) {
+		this.appPackageName = appPackageName;
 	}
 
 	/**
@@ -884,223 +316,159 @@ public class AndroidSourceSinkManager implements ISourceSinkManager, IOneSourceA
 	}
 
 	/**
-	 * Sets the resource packages to be used for finding sensitive layout controls
-	 * as sources
-	 *
-	 * @param resourcePackages The resource packages to be used for looking up
-	 *                         layout controls
-	 */
-	public void setResourcePackages(List<ResPackage> resourcePackages) {
-		this.resourcePackages = resourcePackages;
-	}
-
-	/**
-	 * Sets the name of the app's base package
-	 *
-	 * @param appPackageName The name of the app's base package
-	 */
-	public void setAppPackageName(String appPackageName) {
-		this.appPackageName = appPackageName;
-	}
-
-	/**
-	 * Gets a soot method defined by class name and its sub signature from the
-	 * loaded methods in the Scene object
-	 *
-	 * @param sootClassName The class name of the method
-	 * @param subSignature  The sub signature of the method which is the method name
-	 *                      and its parameters
-	 * @return The soot method of the given class and sub signature or null
+	 * Gets the layout control that is referenced at the given call site
+	 * 
+	 * @param sCallSite A call to <code>findViewById()</code> or a similar method
+	 * @param cfg       The bidirectional control flow graph
+	 * @return The layout control that is being accessed at the given statement, or
+	 *         <code>null</code> if no such control could be found
 	 */
-	private SootMethod grabMethodWithoutReturn(String sootClassName, String subSignature) {
-		SootClass sootClass = Scene.v().getSootClassUnsafe(sootClassName);
-		if (sootClass == null)
+	protected AndroidLayoutControl getLayoutControl(Stmt sCallSite, IInfoflowCFG cfg) {
+		// If we don't have a layout control list, we cannot perform any
+		// more specific checks
+		if (this.layoutControls == null)
 			return null;
 
-		List<SootMethod> sootMethods = null;
-		if (sootClass.resolvingLevel() != DANGLING) {
-			sootMethods = sootClass.getMethods();
-
-			for (SootMethod s : sootMethods) {
-				String[] tempSignature = s.getSubSignature().split(" ");
-
-				if (tempSignature.length == 2) {
-					if (tempSignature[1].equals(subSignature))
-						return s;
-				}
+		// Perform a constant propagation inside this method exactly
+		// once
+		SootMethod uiMethod = cfg.getMethodOf(sCallSite);
+		if (analyzedLayoutMethods.add(uiMethod))
+			ConstantPropagatorAndFolder.v().transform(uiMethod.getActiveBody());
+
+		// If we match specific controls, we need to get the ID of
+		// control and look up the respective data object
+		InvokeExpr iexpr = sCallSite.getInvokeExpr();
+		if (iexpr.getArgCount() != 1) {
+			logger.error("Framework method call with unexpected number of arguments");
+			return null;
+		}
 
-			}
+		Integer id = valueProvider.getValue(uiMethod, sCallSite, iexpr.getArg(0), Integer.class);
+		if (id == null && iexpr.getArg(0) instanceof Local) {
+			id = findLastResIDAssignment(sCallSite, (Local) iexpr.getArg(0), cfg,
+					new HashSet<Stmt>(cfg.getMethodOf(sCallSite).getActiveBody().getUnits().size()));
+		}
+		if (id == null) {
+			logger.debug("Could not find assignment to local " + ((Local) iexpr.getArg(0)).getName() + " in method "
+					+ cfg.getMethodOf(sCallSite).getSignature());
+			return null;
 		}
 
-		return null;
+		AndroidLayoutControl control = this.layoutControls.get(id);
+		if (control == null)
+			return null;
+		return control;
 	}
 
 	@Override
-	public void initialize() {
-		// Get the Soot method or field for the source signatures we have
-		if (sourceDefs != null) {
-			sourceMethods = new HashMap<>();
-			sourceFields = new HashMap<>();
-			sourceStatements = new HashMap<>();
-			for (Pair<String, SourceSinkDefinition> entry : sourceDefs) {
-				SourceSinkDefinition sourceSinkDef = entry.getO2();
-				if (sourceSinkDef instanceof MethodSourceSinkDefinition) {
-					SootMethodAndClass method = ((MethodSourceSinkDefinition) sourceSinkDef).getMethod();
-					String returnType = method.getReturnType();
+	protected ISourceSinkDefinition getUISourceDefinition(Stmt sCallSite, IInfoflowCFG cfg) {
+		// If we match input controls, we need to check whether this is a call
+		// to one of the well-known resource handling functions in Android
+		if (sourceSinkConfig.getLayoutMatchingMode() == LayoutMatchingMode.NoMatch || !sCallSite.containsInvokeExpr())
+			return null;
 
-					// We need special handling for methods for which no return type has been
-					// specified, i.e., the signature is incomplete
-					if (returnType == null || returnType.isEmpty()) {
-						String className = method.getClassName();
+		// If nobody cares about the value obtained from the UI, we can ignore
+		// the call
+		if (!(sCallSite instanceof AssignStmt))
+			return null;
 
-						String subSignatureWithoutReturnType = (((MethodSourceSinkDefinition) sourceSinkDef).getMethod()
-								.getSubSignature());
-						SootMethod sootMethod = grabMethodWithoutReturn(className, subSignatureWithoutReturnType);
-						if (sootMethod != null)
-							sourceMethods.put(sootMethod, sourceSinkDef);
-					} else {
-						SootMethod sm = Scene.v().grabMethod(entry.getO1());
-						if (sm != null)
-							sourceMethods.put(sm, sourceSinkDef);
-					}
+		InvokeExpr ie = sCallSite.getInvokeExpr();
+		SootMethod callee = ie.getMethod();
 
-				} else if (sourceSinkDef instanceof FieldSourceSinkDefinition) {
-					SootField sf = Scene.v().grabField(entry.getO1());
-					if (sf != null)
-						sourceFields.put(sf, sourceSinkDef);
-				} else if (sourceSinkDef instanceof StatementSourceSinkDefinition) {
-					StatementSourceSinkDefinition sssd = (StatementSourceSinkDefinition) sourceSinkDef;
-					sourceStatements.put(sssd.getStmt(), sssd);
+		// Is this a call to resource-handling method?
+		boolean isResourceCall = callee == smActivityFindViewById || callee == smViewFindViewById;
+		if (!isResourceCall) {
+			for (SootMethod cfgCallee : cfg.getCalleesOfCallAt(sCallSite)) {
+				if (cfgCallee == smActivityFindViewById || cfgCallee == smViewFindViewById) {
+					isResourceCall = true;
+					break;
 				}
 			}
-			sourceDefs = null;
+		}
 
+		// We need special treatment for the Android support classes
+		if (!isResourceCall) {
+			if (callee.getDeclaringClass().getName().startsWith("android.support.v")
+					&& callee.getSubSignature().equals(smActivityFindViewById.getSubSignature()))
+				isResourceCall = true;
 		}
 
-		// Get the Soot method or field for the sink signatures we have
-		if (sinkDefs != null) {
-			sinkMethods = new HashMap<>();
-			sinkFields = new HashMap<>();
-			sinkReturnMethods = new HashMap<>();
-			sinkStatements = new HashMap<>();
-			for (Pair<String, SourceSinkDefinition> entry : sinkDefs) {
-				SourceSinkDefinition sourceSinkDef = entry.getO2();
-				if (sourceSinkDef instanceof MethodSourceSinkDefinition) {
-					MethodSourceSinkDefinition methodSourceSinkDef = ((MethodSourceSinkDefinition) sourceSinkDef);
-					if (methodSourceSinkDef.getCallType() == CallType.Return) {
-						SootMethodAndClass method = methodSourceSinkDef.getMethod();
-						SootMethod m = Scene.v().grabMethod(method.getSignature());
-						if (m != null)
-							sinkReturnMethods.put(m, methodSourceSinkDef);
-					} else {
-						SootMethodAndClass method = methodSourceSinkDef.getMethod();
-						String returnType = method.getReturnType();
-						boolean isMethodWithoutReturnType = returnType == null || returnType.isEmpty();
-						if (isMethodWithoutReturnType) {
-							String className = method.getClassName();
-							String subSignatureWithoutReturnType = (((MethodSourceSinkDefinition) sourceSinkDef)
-									.getMethod().getSubSignature());
-							SootMethod sootMethod = grabMethodWithoutReturn(className, subSignatureWithoutReturnType);
-							if (sootMethod != null)
-								sinkMethods.put(sootMethod, sourceSinkDef);
-						} else {
-							SootMethod sm = Scene.v().grabMethod(entry.getO1());
-							if (sm != null)
-								sinkMethods.put(sm, entry.getO2());
-						}
-					}
+		if (isResourceCall) {
+			// If we match all controls, we don't care about the specific
+			// control we're dealing with
+			if (sourceSinkConfig.getLayoutMatchingMode() == LayoutMatchingMode.MatchAll) {
+				return MethodSourceSinkDefinition.createReturnSource(CallType.MethodCall);
+			}
 
-				} else if (sourceSinkDef instanceof FieldSourceSinkDefinition) {
-					SootField sf = Scene.v().grabField(entry.getO1());
-					if (sf != null)
-						sinkFields.put(sf, sourceSinkDef);
-				} else if (sourceSinkDef instanceof StatementSourceSinkDefinition) {
-					StatementSourceSinkDefinition sssd = (StatementSourceSinkDefinition) sourceSinkDef;
-					sinkStatements.put(sssd.getStmt(), sssd);
+			AndroidLayoutControl control = getLayoutControl(sCallSite, cfg);
+			if (control != null) {
+				if (sourceSinkConfig.getLayoutMatchingMode() == LayoutMatchingMode.MatchSensitiveOnly
+						&& control.isSensitive()) {
+					return control.getSourceDefinition();
 				}
 			}
-			sinkDefs = null;
 		}
-
-		// For ICC methods (e.g., startService), the classes name of these
-		// methods may change through user's definition. We match all the
-		// ICC methods through their base class name.
-		if (iccBaseClasses == null)
-			iccBaseClasses = new SootClass[] { Scene.v().getSootClass("android.content.Context"), // activity,
-					// service
-					// and
-					// broadcast
-					Scene.v().getSootClass("android.content.ContentResolver"), // provider
-					Scene.v().getSootClass("android.app.Activity") // some
-					// methods
-					// (e.g.,
-					// onActivityResult)
-					// only
-					// defined
-					// in
-					// Activity
-					// class
-			};
-
-		// Get some frequently-used methods
-		this.smActivityFindViewById = Scene.v().grabMethod(Activity_FindViewById);
-		this.smViewFindViewById = Scene.v().grabMethod(View_FindViewById);
-	}
-
-	@Override
-	public void setOneSourceAtATimeEnabled(boolean enabled) {
-		this.oneSourceAtATime = enabled;
+		return null;
 	}
 
 	@Override
-	public boolean isOneSourceAtATimeEnabled() {
-		return this.oneSourceAtATime;
+	protected boolean isEntryPointMethod(SootMethod method) {
+		return entryPointUtils.isEntryPointMethod(method);
 	}
 
 	@Override
-	public void resetCurrentSource() {
-		this.osaatIterator = this.sourceMethods.keySet().iterator();
-		this.osaatType = SourceType.MethodCall;
-	}
+	protected ISourceSinkDefinition getSinkDefinition(Stmt sCallSite, InfoflowManager manager, AccessPath ap) {
+		ISourceSinkDefinition definition = super.getSinkDefinition(sCallSite, manager, ap);
+		if (definition != null)
+			return definition;
 
-	@Override
-	public void nextSource() {
-		if (osaatType == SourceType.MethodCall || osaatType == SourceType.Callback)
-			currentSource = this.osaatIterator.next();
-	}
+		if (sCallSite.containsInvokeExpr()) {
+			final SootMethod callee = sCallSite.getInvokeExpr().getMethod();
+			final String subSig = callee.getSubSignature();
+			final SootClass sc = callee.getDeclaringClass();
 
-	@Override
-	public boolean hasNextSource() {
-		if (osaatType == SourceType.MethodCall) {
-			if (this.osaatIterator.hasNext())
-				return true;
-			else {
-				this.osaatType = SourceType.Callback;
-				this.osaatIterator = this.callbackMethods.keySet().iterator();
-				return hasNextSource();
+			// Do not consider ICC methods as sinks if only the base object is
+			// tainted
+			boolean isParamTainted = false;
+			if (ap != null) {
+				if (!sc.isInterface() && !ap.isStaticFieldRef()) {
+					for (int i = 0; i < sCallSite.getInvokeExpr().getArgCount(); i++) {
+						if (sCallSite.getInvokeExpr().getArg(i) == ap.getPlainValue()) {
+							isParamTainted = true;
+							break;
+						}
+					}
+				}
 			}
-		} else if (osaatType == SourceType.Callback) {
-			if (this.osaatIterator.hasNext())
-				return true;
-			else {
-				this.osaatType = SourceType.UISource;
-				return true;
+
+			if (isParamTainted || ap == null) {
+				for (SootClass clazz : iccBaseClasses) {
+					if (Scene.v().getOrMakeFastHierarchy().isSubclass(sc, clazz)) {
+						SootMethod sm = clazz.getMethodUnsafe(subSig);
+						if (sm != null) {
+							ISourceSinkDefinition def = this.sinkMethods.get(sm);
+							if (def != null)
+								return def;
+							break;
+						}
+					}
+				}
 			}
-		} else if (osaatType == SourceType.UISource) {
-			osaatType = SourceType.NoSource;
-			return false;
 		}
-		return false;
+		return null;
 	}
 
-	/**
-	 * Excludes the given method from the source/sink analysis. No sources or sinks
-	 * will be detected in excluded methods.
-	 *
-	 * @param toExclude The method to exclude
-	 */
-	public void excludeMethod(SootMethod toExclude) {
-		this.excludedMethods.add(toExclude);
+	@Override
+	protected CallbackDefinition getCallbackDefinition(SootMethod method) {
+		CallbackDefinition def = super.getCallbackDefinition(method);
+		if (def instanceof AndroidCallbackDefinition) {
+			AndroidCallbackDefinition d = (AndroidCallbackDefinition) def;
+			// If this is a UI element, we only consider it as a
+			// source if we actually want to taint all UI elements
+			if (d.getCallbackType() == CallbackType.Widget
+					&& sourceSinkConfig.getLayoutMatchingMode() != LayoutMatchingMode.MatchAll)
+				return null;
+		}
+		return def;
 	}
-
 }
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/source/ConfigurationBasedCategoryFilter.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/source/ConfigurationBasedCategoryFilter.java
index edc4845..47d9c2e 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/source/ConfigurationBasedCategoryFilter.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/source/ConfigurationBasedCategoryFilter.java
@@ -1,8 +1,8 @@
 package soot.jimple.infoflow.android.source;
 
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CategoryMode;
+import soot.jimple.infoflow.InfoflowConfiguration.CategoryMode;
+import soot.jimple.infoflow.InfoflowConfiguration.SourceSinkFilterMode;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.SourceSinkConfiguration;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.SourceSinkFilterMode;
 import soot.jimple.infoflow.android.data.CategoryDefinition;
 import soot.jimple.infoflow.android.source.parsers.xml.XMLSourceSinkParser.ICategoryFilter;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
@@ -20,9 +20,8 @@ public class ConfigurationBasedCategoryFilter implements ICategoryFilter {
 	/**
 	 * Creates a new instance of the {@link ConfigurationBasedCategoryFilter} class
 	 * 
-	 * @param config
-	 *            The configuration that defines which source and sink categories to
-	 *            include and which ones to exclude
+	 * @param config The configuration that defines which source and sink categories
+	 *               to include and which ones to exclude
 	 */
 	public ConfigurationBasedCategoryFilter(SourceSinkConfiguration config) {
 		this.config = config;
diff --git a/soot-infoflow-android/src/soot/jimple/infoflow/android/source/parsers/xml/XMLSourceSinkParser.java b/soot-infoflow-android/src/soot/jimple/infoflow/android/source/parsers/xml/XMLSourceSinkParser.java
index a9c00f8..87e1061 100644
--- a/soot-infoflow-android/src/soot/jimple/infoflow/android/source/parsers/xml/XMLSourceSinkParser.java
+++ b/soot-infoflow-android/src/soot/jimple/infoflow/android/source/parsers/xml/XMLSourceSinkParser.java
@@ -30,10 +30,10 @@ import soot.jimple.infoflow.android.data.CategoryDefinition;
 import soot.jimple.infoflow.android.data.CategoryDefinition.CATEGORY;
 import soot.jimple.infoflow.sourcesSinks.definitions.AccessPathTuple;
 import soot.jimple.infoflow.sourcesSinks.definitions.FieldSourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.IAccessPathBasedSourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinitionProvider;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition.CallType;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 
 /**
@@ -61,8 +61,7 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 		/**
 		 * Checks whether methods from the given category shall be parsed or not
 		 * 
-		 * @param category
-		 *            The category in which the source or sink is defined
+		 * @param category The category in which the source or sink is defined
 		 * @return True if the given category shall be parsed, otherwise false
 		 */
 		public boolean acceptsCategory(CategoryDefinition category);
@@ -70,10 +69,9 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 		/**
 		 * Filters sources and sinks by category
 		 * 
-		 * @param category
-		 *            The category in which the source or sink is defined
-		 * @param sourceSinkType
-		 *            Specifies whether the category is used for sources or sinks
+		 * @param category       The category in which the source or sink is defined
+		 * @param sourceSinkType Specifies whether the category is used for sources or
+		 *                       sinks
 		 * @return The acceptable use of the given category. This is a reduction from
 		 *         the given type. If the requested type, for example, is "Both", this
 		 *         method may return "Source", if the category shall only be used for
@@ -182,17 +180,21 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 						if (tempStr != null && !tempStr.isEmpty())
 							isSink = tempStr.equalsIgnoreCase(XMLConstants.TRUE);
 
-						description = attributes.getValue(XMLConstants.DESCRIPTION_ATTRIBUTE);
+						String newDesc = attributes.getValue(XMLConstants.DESCRIPTION_ATTRIBUTE);
+						if (newDesc != null && !newDesc.isEmpty())
+							description = newDesc;
 					}
 				}
 				break;
 
 			case XMLConstants.BASE_TAG:
 				accessPathParentElement = qNameLower;
+				description = attributes.getValue(XMLConstants.DESCRIPTION_ATTRIBUTE);
 				break;
 
 			case XMLConstants.RETURN_TAG:
 				accessPathParentElement = qNameLower;
+				description = attributes.getValue(XMLConstants.DESCRIPTION_ATTRIBUTE);
 				break;
 
 			case XMLConstants.PARAM_TAG:
@@ -206,6 +208,7 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 						paramTypes.add(tempStr.trim());
 				}
 				accessPathParentElement = qNameLower;
+				description = attributes.getValue(XMLConstants.DESCRIPTION_ATTRIBUTE);
 				break;
 
 			case XMLConstants.PATHELEMENT_TAG:
@@ -227,8 +230,7 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 		/**
 		 * Reads the method or field signature from the given attribute map
 		 * 
-		 * @param attributes
-		 *            The attribute map from which to read the signature
+		 * @param attributes The attribute map from which to read the signature
 		 * @return The signature that identifies a Soot method or field
 		 */
 		private String parseSignature(Attributes attributes) {
@@ -275,7 +277,7 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 					AndroidMethod tempMeth = AndroidMethod.createFromSignature(methodSignature);
 
 					@SuppressWarnings("unchecked")
-					SourceSinkDefinition ssd = createMethodSourceSinkDefinition(tempMeth, baseAPs,
+					IAccessPathBasedSourceSinkDefinition ssd = createMethodSourceSinkDefinition(tempMeth, baseAPs,
 							paramAPs.toArray(new Set[paramAPs.size()]), returnAPs, callType);
 					ssd.setCategory(category);
 					addSourceSinkDefinition(methodSignature, ssd);
@@ -287,18 +289,20 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 				baseAPs = new HashSet<>();
 				paramAPs = new ArrayList<>();
 				returnAPs = new HashSet<>();
+				description = null;
 				break;
 
 			case XMLConstants.FIELD_TAG:
 				// Create the field source
 				if (!baseAPs.isEmpty()) {
-					SourceSinkDefinition ssd = createFieldSourceSinkDefinition(fieldSignature, baseAPs);
+					IAccessPathBasedSourceSinkDefinition ssd = createFieldSourceSinkDefinition(fieldSignature, baseAPs);
 					addSourceSinkDefinition(fieldSignature, ssd);
 				}
 
 				// Start a new field and discard our old data
 				methodSignature = null;
 				fieldSignature = null;
+				description = null;
 				break;
 
 			case XMLConstants.ACCESSPATH_TAG:
@@ -356,6 +360,8 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 				isSink = false;
 				pathElements = null;
 				pathElementTypes = null;
+
+				description = null;
 				break;
 
 			case XMLConstants.BASE_TAG:
@@ -379,10 +385,10 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 
 	}
 
-	protected Map<String, SourceSinkDefinition> sourcesAndSinks;
+	protected Map<String, IAccessPathBasedSourceSinkDefinition> sourcesAndSinks;
 
-	protected Set<SourceSinkDefinition> sources = new HashSet<>();
-	protected Set<SourceSinkDefinition> sinks = new HashSet<>();
+	protected Set<IAccessPathBasedSourceSinkDefinition> sources = new HashSet<>();
+	protected Set<IAccessPathBasedSourceSinkDefinition> sinks = new HashSet<>();
 	protected ICategoryFilter categoryFilter = null;
 
 	protected final Map<CategoryDefinition, CategoryDefinition> categories = new HashMap<>();
@@ -427,12 +433,12 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSources() {
+	public Set<IAccessPathBasedSourceSinkDefinition> getSources() {
 		return sources;
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSinks() {
+	public Set<IAccessPathBasedSourceSinkDefinition> getSinks() {
 		return sinks;
 	}
 
@@ -441,12 +447,10 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 	 * category is requested, the respective definition is created. Otherwise, the
 	 * existing one is returned.
 	 * 
-	 * @param systemCategory
-	 *            The system-defined category name
-	 * @param customCategory
-	 *            The user-defined category name
-	 * @param customDescription
-	 *            The human-readable description for the custom category
+	 * @param systemCategory    The system-defined category name
+	 * @param customCategory    The user-defined category name
+	 * @param customDescription The human-readable description for the custom
+	 *                          category
 	 * @return The category definition object for the given category names
 	 */
 	private CategoryDefinition getOrMakeCategory(CATEGORY systemCategory, String customCategory,
@@ -464,8 +468,7 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 	/**
 	 * Creates a new instance of the {@link XMLSourceSinkParser} class
 	 * 
-	 * @param filter
-	 *            A filter for excluding certain categories of sources and sinks
+	 * @param filter A filter for excluding certain categories of sources and sinks
 	 */
 	protected XMLSourceSinkParser(ICategoryFilter categoryFilter) {
 		this.sourcesAndSinks = new HashMap<>();
@@ -475,8 +478,7 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 	/**
 	 * Parses the given input stream to obtain the source/sink definitions
 	 * 
-	 * @param stream
-	 *            The stream whose data to parse
+	 * @param stream The stream whose data to parse
 	 */
 	protected void parseInputStream(InputStream stream) {
 		SAXParserFactory pf = SAXParserFactory.newInstance();
@@ -499,8 +501,8 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 	 * Builds the lists of sources and sinks from the data that we have parsed
 	 */
 	protected void buildSourceSinkLists() {
-		for (SourceSinkDefinition def : sourcesAndSinks.values()) {
-			SourceSinkDefinition sourceDef = def.getSourceOnlyDefinition();
+		for (IAccessPathBasedSourceSinkDefinition def : sourcesAndSinks.values()) {
+			IAccessPathBasedSourceSinkDefinition sourceDef = def.getSourceOnlyDefinition();
 			if (sourceDef != null && !sourceDef.isEmpty()) {
 				if (sourceDef instanceof MethodSourceSinkDefinition) {
 					MethodSourceSinkDefinition methodSrc = (MethodSourceSinkDefinition) sourceDef;
@@ -512,7 +514,7 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 				sources.add(sourceDef);
 			}
 
-			SourceSinkDefinition sinkDef = def.getSinkOnlyDefinition();
+			IAccessPathBasedSourceSinkDefinition sinkDef = def.getSinkOnlyDefinition();
 			if (sinkDef != null && !sinkDef.isEmpty()) {
 				if (sourceDef instanceof MethodSourceSinkDefinition) {
 					MethodSourceSinkDefinition methodSink = (MethodSourceSinkDefinition) sourceDef;
@@ -531,8 +533,7 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 	 * Checks whether the given XML is valid against the XSD for the new data
 	 * format.
 	 * 
-	 * @param fileName
-	 *            of the XML
+	 * @param fileName of the XML
 	 * @throws IOException
 	 */
 	private static void verifyXML(InputStream inp) throws IOException {
@@ -559,8 +560,8 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getAllMethods() {
-		Set<SourceSinkDefinition> sourcesSinks = new HashSet<>(sources.size() + sinks.size());
+	public Set<IAccessPathBasedSourceSinkDefinition> getAllMethods() {
+		Set<IAccessPathBasedSourceSinkDefinition> sourcesSinks = new HashSet<>(sources.size() + sinks.size());
 		sourcesSinks.addAll(sources);
 		sourcesSinks.addAll(sinks);
 		return sourcesSinks;
@@ -569,13 +570,11 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 	/**
 	 * Adds a new source or sink definition
 	 * 
-	 * @param signature
-	 *            The signature of the method or field that is considered a source
-	 *            or a sink
-	 * @param ssd
-	 *            The source or sink definition
+	 * @param signature The signature of the method or field that is considered a
+	 *                  source or a sink
+	 * @param ssd       The source or sink definition
 	 */
-	protected void addSourceSinkDefinition(String signature, SourceSinkDefinition ssd) {
+	protected void addSourceSinkDefinition(String signature, IAccessPathBasedSourceSinkDefinition ssd) {
 		if (sourcesAndSinks.containsKey(signature))
 			sourcesAndSinks.get(signature).merge(ssd);
 		else
@@ -585,41 +584,35 @@ public class XMLSourceSinkParser implements ISourceSinkDefinitionProvider {
 	/**
 	 * Factory method for {@link MethodSourceSinkDefinition} instances
 	 * 
-	 * @param method
-	 *            The method that is to be defined as a source or sink
-	 * @param baseAPs
-	 *            The access paths rooted in the base object that shall be
-	 *            considered as sources or sinks
-	 * @param paramAPs
-	 *            The access paths rooted in parameters that shall be considered as
-	 *            sources or sinks. The index in the set corresponds to the index of
-	 *            the formal parameter to which the respective set of access paths
-	 *            belongs.
-	 * @param returnAPs
-	 *            The access paths rooted in the return object that shall be
-	 *            considered as sources or sinks
-	 * @param callType
-	 *            The type of call (normal call, callback, etc.)
+	 * @param method    The method that is to be defined as a source or sink
+	 * @param baseAPs   The access paths rooted in the base object that shall be
+	 *                  considered as sources or sinks
+	 * @param paramAPs  The access paths rooted in parameters that shall be
+	 *                  considered as sources or sinks. The index in the set
+	 *                  corresponds to the index of the formal parameter to which
+	 *                  the respective set of access paths belongs.
+	 * @param returnAPs The access paths rooted in the return object that shall be
+	 *                  considered as sources or sinks
+	 * @param callType  The type of call (normal call, callback, etc.)
 	 * @return The newly created {@link MethodSourceSinkDefinition} instance
 	 */
-	protected SourceSinkDefinition createMethodSourceSinkDefinition(AndroidMethod method, Set<AccessPathTuple> baseAPs,
-			Set<AccessPathTuple>[] paramAPs, Set<AccessPathTuple> returnAPs, CallType callType) {
-		SourceSinkDefinition ssd = new MethodSourceSinkDefinition(method, baseAPs, paramAPs, returnAPs, callType);
-		return ssd;
+	protected IAccessPathBasedSourceSinkDefinition createMethodSourceSinkDefinition(AndroidMethod method,
+			Set<AccessPathTuple> baseAPs, Set<AccessPathTuple>[] paramAPs, Set<AccessPathTuple> returnAPs,
+			CallType callType) {
+		return new MethodSourceSinkDefinition(method, baseAPs, paramAPs, returnAPs, callType);
 	}
 
 	/**
 	 * Factory method for {@link FieldSourceSinkDefinition} instances
 	 * 
-	 * @param signature
-	 *            The signature of the target field
-	 * @param baseAPs
-	 *            The access paths that shall be considered as sources or sinks
+	 * @param signature The signature of the target field
+	 * @param baseAPs   The access paths that shall be considered as sources or
+	 *                  sinks
 	 * @return The newly created {@link FieldSourceSinkDefinition} instance
 	 */
-	protected SourceSinkDefinition createFieldSourceSinkDefinition(String signature, Set<AccessPathTuple> baseAPs) {
-		SourceSinkDefinition ssd = new FieldSourceSinkDefinition(signature, baseAPs);
-		return ssd;
+	protected IAccessPathBasedSourceSinkDefinition createFieldSourceSinkDefinition(String signature,
+			Set<AccessPathTuple> baseAPs) {
+		return new FieldSourceSinkDefinition(signature, baseAPs);
 	}
 
 }
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AliasingTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AliasingTest.java
similarity index 97%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AliasingTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AliasingTest.java
index bccc94f..a7f550f 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AliasingTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AliasingTest.java
@@ -19,7 +19,7 @@ import org.xmlpull.v1.XmlPullParserException;
 
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class AliasingTests extends JUnitTests {
+public class AliasingTest extends JUnitTests {
 	
 	@Test(timeout=300000)
 	public void runTestFlowSensitivity1() throws IOException, XmlPullParserException {
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AndroidSpecificTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AndroidSpecificTest.java
similarity index 89%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AndroidSpecificTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AndroidSpecificTest.java
index e540d2b..cf49caf 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AndroidSpecificTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/AndroidSpecificTest.java
@@ -19,98 +19,98 @@ import org.xmlpull.v1.XmlPullParserException;
 
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class AndroidSpecificTests extends JUnitTests {
-	
-	@Test(timeout=300000)
+public class AndroidSpecificTest extends JUnitTests {
+
+	@Test // (timeout=300000)
 	public void runTestApplicationModeling1() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/ApplicationModeling1.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
-	
-	@Test(timeout=300000)
+
+	@Test(timeout = 300000)
 	public void runTestDirectLeak1() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/DirectLeak1.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
 
-	@Test(timeout=300000)
+	@Test(timeout = 300000)
 	public void runTestInactiveActivity() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/InactiveActivity.apk");
 		if (res != null)
 			Assert.assertEquals(0, res.size());
 	}
 
-	@Test(timeout=300000)
+	@Test(timeout = 300000)
 	public void runTestLibrary2() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/Library2.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
 
-	@Test(timeout=300000)
+	@Test(timeout = 300000)
 	public void runTestLogNoLeak() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/LogNoLeak.apk");
 		if (res != null)
 			Assert.assertEquals(0, res.size());
 	}
 
-	@Test(timeout=300000)
+	@Test(timeout = 300000)
 	public void runTestObfuscation1() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/Obfuscation1.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
 
-	@Test(timeout=300000)
+	@Test(timeout = 300000)
 	public void runTestParcel1() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/Parcel1.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
 
-	@Test(timeout=300000)
+	@Test(timeout = 300000)
 	public void runTestPrivateDataLeak1() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/PrivateDataLeak1.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
 
-	@Test(timeout=300000)
+	@Test(timeout = 300000)
 	public void runTestPrivateDataLeak2() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/PrivateDataLeak2.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
 
-	@Test(timeout=300000)
-	@Ignore		// not supported, would require taint tracking via files
+	@Test(timeout = 300000)
+	@Ignore // not supported, would require taint tracking via files
 	public void runTestPrivateDataLeak3() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/PrivateDataLeak3.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(2, res.size());
 	}
-	
-	@Test(timeout=300000)
+
+	@Test(timeout = 300000)
 	public void runPublicAPIField1() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/PublicAPIField1.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
-	
-	@Test(timeout=300000)
+
+	@Test(timeout = 300000)
 	public void runPublicAPIField2() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/PublicAPIField2.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
-	
-	@Test(timeout=300000)
+
+	@Test(timeout = 300000)
 	public void runView1() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("AndroidSpecific/View1.apk");
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
-	
+
 }
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ArrayAndListTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ArrayAndListTest.java
similarity index 98%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ArrayAndListTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ArrayAndListTest.java
index 61220c5..75ed048 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ArrayAndListTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ArrayAndListTest.java
@@ -19,7 +19,7 @@ import org.xmlpull.v1.XmlPullParserException;
 
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class ArrayAndListTests extends JUnitTests {
+public class ArrayAndListTest extends JUnitTests {
 		
 	@Test(timeout=300000)
 	@Ignore
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/CallbackTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/CallbackTest.java
similarity index 95%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/CallbackTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/CallbackTest.java
index ad14d2c..49be9b7 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/CallbackTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/CallbackTest.java
@@ -17,12 +17,12 @@ import org.junit.Ignore;
 import org.junit.Test;
 import org.xmlpull.v1.XmlPullParserException;
 
+import soot.jimple.infoflow.InfoflowConfiguration.CallbackSourceMode;
+import soot.jimple.infoflow.InfoflowConfiguration.LayoutMatchingMode;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CallbackSourceMode;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.LayoutMatchingMode;
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class CallbackTests extends JUnitTests {
+public class CallbackTest extends JUnitTests {
 
 	@Test(timeout = 300000)
 	public void runTestAnonymousClass1() throws IOException, XmlPullParserException {
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/EmulatorDetectionTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/EmulatorDetectionTest.java
similarity index 98%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/EmulatorDetectionTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/EmulatorDetectionTest.java
index 699cb39..120395c 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/EmulatorDetectionTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/EmulatorDetectionTest.java
@@ -18,7 +18,7 @@ import org.xmlpull.v1.XmlPullParserException;
 
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class EmulatorDetectionTests extends JUnitTests {
+public class EmulatorDetectionTest extends JUnitTests {
 	
 	@Test(timeout=300000)
 	public void runTestBattery1() throws IOException, XmlPullParserException {
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/FieldAndObjectSensitivityTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/FieldAndObjectSensitivityTest.java
similarity index 97%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/FieldAndObjectSensitivityTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/FieldAndObjectSensitivityTest.java
index a1fa021..77fade5 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/FieldAndObjectSensitivityTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/FieldAndObjectSensitivityTest.java
@@ -18,7 +18,7 @@ import org.xmlpull.v1.XmlPullParserException;
 
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class FieldAndObjectSensitivityTests extends JUnitTests {
+public class FieldAndObjectSensitivityTest extends JUnitTests {
 	
 	@Test(timeout=300000)
 	public void runTestFieldSensitivity1() throws IOException, XmlPullParserException {
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/GeneralJavaTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/GeneralJavaTest.java
similarity index 99%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/GeneralJavaTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/GeneralJavaTest.java
index 90d8de3..ad39752 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/GeneralJavaTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/GeneralJavaTest.java
@@ -19,7 +19,7 @@ import org.xmlpull.v1.XmlPullParserException;
 
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class GeneralJavaTests extends JUnitTests {
+public class GeneralJavaTest extends JUnitTests {
 		
 	@Test(timeout=300000)
 	public void runTestClone1() throws IOException, XmlPullParserException {
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ImplicitFlowTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ImplicitFlowTest.java
similarity index 85%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ImplicitFlowTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ImplicitFlowTest.java
index a2e08ab..f3b8778 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ImplicitFlowTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ImplicitFlowTest.java
@@ -13,48 +13,50 @@ package soot.jimple.infoflow.android.test.droidBench;
 import java.io.IOException;
 
 import org.junit.Assert;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.xmlpull.v1.XmlPullParserException;
 
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class ImplicitFlowTests extends JUnitTests {
-	
-	@Test(timeout=300000)
+public class ImplicitFlowTest extends JUnitTests {
+
+	@Test(timeout = 300000)
 	public void runTestImplicitFlow1() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("ImplicitFlows/ImplicitFlow1.apk", true);
-		Assert.assertEquals(1, res.size());		// same source and sink, gets collapsed into one leak
+		Assert.assertEquals(1, res.size()); // same source and sink, gets collapsed into one leak
 	}
 
-	@Test(timeout=300000)
+	@Test(timeout = 300000)
 	public void runTestImplicitFlow2() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("ImplicitFlows/ImplicitFlow2.apk", true);
 		Assert.assertNotNull(res);
 		Assert.assertEquals(2, res.size());
 	}
 
-	@Test(timeout=300000)
+	@Test(timeout = 300000)
 	public void runTestImplicitFlow3() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("ImplicitFlows/ImplicitFlow3.apk", true);
 		Assert.assertNotNull(res);
 		Assert.assertEquals(2, res.size());
 	}
 
-	@Test(timeout=300000)
+	@Test(timeout = 300000)
 	public void runTestImplicitFlow4() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("ImplicitFlows/ImplicitFlow4.apk", true);
 		Assert.assertNotNull(res);
 		Assert.assertEquals(2, res.size());
 	}
-	
-	@Test(timeout=300000)
+
+	@Test(timeout = 300000)
+	@Ignore("We don't track array lengths at the moment")
 	public void runTestImplicitFlow5() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("ImplicitFlows/ImplicitFlow5.apk", true);
 		Assert.assertNotNull(res);
 		Assert.assertEquals(1, res.size());
 	}
-	
-	@Test(timeout=300000)
+
+	@Test(timeout = 300000)
 	public void runTestImplicitFlow6() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile("ImplicitFlows/ImplicitFlow6.apk", true);
 		Assert.assertTrue(res == null || res.isEmpty());
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/InterComponentCommunicationTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/InterComponentCommunicationTest.java
similarity index 98%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/InterComponentCommunicationTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/InterComponentCommunicationTest.java
index 22d21e1..15cc6b5 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/InterComponentCommunicationTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/InterComponentCommunicationTest.java
@@ -19,7 +19,7 @@ import org.xmlpull.v1.XmlPullParserException;
 
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class InterComponentCommunicationTests extends JUnitTests {
+public class InterComponentCommunicationTest extends JUnitTests {
 	
 	@Test(timeout=300000)
 	public void runTestActivityCommunication1() throws IOException, XmlPullParserException {
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/JUnitTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/JUnitTests.java
index a3bec85..1795e3d 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/JUnitTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/JUnitTests.java
@@ -26,14 +26,12 @@ public class JUnitTests {
 	/**
 	 * Analyzes the given APK file for data flows
 	 * 
-	 * @param fileName
-	 *            The full path and file name of the APK file to analyze
+	 * @param fileName The full path and file name of the APK file to analyze
 	 * @return The data leaks found in the given APK file
-	 * @throws IOException
-	 *             Thrown if the given APK file or any other required file could
-	 *             not be found
-	 * @throws XmlPullParserException
-	 *             Thrown if the Android manifest file could not be read.
+	 * @throws IOException            Thrown if the given APK file or any other
+	 *                                required file could not be found
+	 * @throws XmlPullParserException Thrown if the Android manifest file could not
+	 *                                be read.
 	 */
 	public InfoflowResults analyzeAPKFile(String fileName) throws IOException, XmlPullParserException {
 		return analyzeAPKFile(fileName, false);
@@ -42,16 +40,13 @@ public class JUnitTests {
 	/**
 	 * Analyzes the given APK file for data flows
 	 * 
-	 * @param fileName
-	 *            The full path and file name of the APK file to analyze
-	 * @param iccModel
-	 *            The full path and file name of the ICC model to use
+	 * @param fileName The full path and file name of the APK file to analyze
+	 * @param iccModel The full path and file name of the ICC model to use
 	 * @return The data leaks found in the given APK file
-	 * @throws IOException
-	 *             Thrown if the given APK file or any other required file could
-	 *             not be found
-	 * @throws XmlPullParserException
-	 *             Thrown if the Android manifest file could not be read.
+	 * @throws IOException            Thrown if the given APK file or any other
+	 *                                required file could not be found
+	 * @throws XmlPullParserException Thrown if the Android manifest file could not
+	 *                                be read.
 	 */
 	public InfoflowResults analyzeAPKFile(String fileName, String iccModel) throws IOException, XmlPullParserException {
 		return analyzeAPKFile(fileName, iccModel, null);
@@ -60,16 +55,15 @@ public class JUnitTests {
 	/**
 	 * Analyzes the given APK file for data flows
 	 * 
-	 * @param fileName
-	 *            The full path and file name of the APK file to analyze
-	 * @param enableImplicitFlows
-	 *            True if implicit flows shall be tracked, otherwise false
+	 * @param fileName            The full path and file name of the APK file to
+	 *                            analyze
+	 * @param enableImplicitFlows True if implicit flows shall be tracked, otherwise
+	 *                            false
 	 * @return The data leaks found in the given APK file
-	 * @throws IOException
-	 *             Thrown if the given APK file or any other required file could
-	 *             not be found
-	 * @throws XmlPullParserException
-	 *             Thrown if the Android manifest file could not be read.
+	 * @throws IOException            Thrown if the given APK file or any other
+	 *                                required file could not be found
+	 * @throws XmlPullParserException Thrown if the Android manifest file could not
+	 *                                be read.
 	 */
 	public InfoflowResults analyzeAPKFile(String fileName, final boolean enableImplicitFlows)
 			throws IOException, XmlPullParserException {
@@ -93,11 +87,10 @@ public class JUnitTests {
 	public interface AnalysisConfigurationCallback {
 
 		/**
-		 * Method that is called to give the test case the chance to change the
-		 * analyzer configuration
+		 * Method that is called to give the test case the chance to change the analyzer
+		 * configuration
 		 * 
-		 * @param config
-		 *            The configuration object used by the analyzer
+		 * @param config The configuration object used by the analyzer
 		 */
 		public void configureAnalyzer(InfoflowAndroidConfiguration config);
 
@@ -106,20 +99,16 @@ public class JUnitTests {
 	/**
 	 * Analyzes the given APK file for data flows
 	 * 
-	 * @param fileName
-	 *            The full path and file name of the APK file to analyze
-	 * @param iccModel
-	 *            The full path and file name of the ICC model to use
-	 * @param configCallback
-	 *            A callback that is invoked to allow the test case to change
-	 *            the analyzer configuration when necessary. Pass null to ignore
-	 *            the callback.
+	 * @param fileName       The full path and file name of the APK file to analyze
+	 * @param iccModel       The full path and file name of the ICC model to use
+	 * @param configCallback A callback that is invoked to allow the test case to
+	 *                       change the analyzer configuration when necessary. Pass
+	 *                       null to ignore the callback.
 	 * @return The data leaks found in the given APK file
-	 * @throws IOException
-	 *             Thrown if the given APK file or any other required file could
-	 *             not be found
-	 * @throws XmlPullParserException
-	 *             Thrown if the Android manifest file could not be read.
+	 * @throws IOException            Thrown if the given APK file or any other
+	 *                                required file could not be found
+	 * @throws XmlPullParserException Thrown if the Android manifest file could not
+	 *                                be read.
 	 */
 	public InfoflowResults analyzeAPKFile(String fileName, String iccModel,
 			AnalysisConfigurationCallback configCallback) throws IOException, XmlPullParserException {
@@ -133,6 +122,13 @@ public class JUnitTests {
 		String droidBenchDir = System.getenv("DROIDBENCH");
 		if (droidBenchDir == null)
 			droidBenchDir = System.getProperty("DROIDBENCH");
+		if (droidBenchDir == null) {
+			File droidBenchFile = new File("DroidBench/apk");
+			if (!droidBenchFile.exists())
+				droidBenchFile = new File("../DroidBench/apk");
+			if (droidBenchFile.exists())
+				droidBenchDir = droidBenchFile.getAbsolutePath();
+		}
 		if (droidBenchDir == null)
 			throw new RuntimeException("DroidBench dir not set");
 		System.out.println("Loading DroidBench from " + droidBenchDir);
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/LifecycleTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/LifecycleTest.java
similarity index 98%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/LifecycleTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/LifecycleTest.java
index 3b774d4..079ebde 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/LifecycleTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/LifecycleTest.java
@@ -17,11 +17,11 @@ import org.junit.Ignore;
 import org.junit.Test;
 import org.xmlpull.v1.XmlPullParserException;
 
+import soot.jimple.infoflow.InfoflowConfiguration.CallbackSourceMode;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CallbackSourceMode;
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class LifecycleTests extends JUnitTests {
+public class LifecycleTest extends JUnitTests {
 
 	@Test(timeout = 300000)
 	public void runTestActivityEventSequence1() throws IOException, XmlPullParserException {
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ReflectionTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ReflectionTest.java
similarity index 98%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ReflectionTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ReflectionTest.java
index 525d21e..96e9823 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ReflectionTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ReflectionTest.java
@@ -20,7 +20,7 @@ import org.xmlpull.v1.XmlPullParserException;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class ReflectionTests extends JUnitTests {
+public class ReflectionTest extends JUnitTests {
 	
 	private AnalysisConfigurationCallback enableReflectionCallback = new AnalysisConfigurationCallback() {
 		
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ThreadingTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ThreadingTest.java
similarity index 97%
rename from soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ThreadingTests.java
rename to soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ThreadingTest.java
index 4ed59c6..b3c3afd 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ThreadingTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/droidBench/ThreadingTest.java
@@ -18,7 +18,7 @@ import org.xmlpull.v1.XmlPullParserException;
 
 import soot.jimple.infoflow.results.InfoflowResults;
 
-public class ThreadingTests extends JUnitTests {
+public class ThreadingTest extends JUnitTests {
 	
 	@Test(timeout=300000)
 	public void runTestAsyncTask1() throws IOException, XmlPullParserException {
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/insecureBank/InsecureBankTests.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/insecureBank/InsecureBankTests.java
index 4352256..2560fea 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/insecureBank/InsecureBankTests.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/insecureBank/InsecureBankTests.java
@@ -14,11 +14,12 @@ import java.io.File;
 import java.io.IOException;
 
 import org.junit.Assert;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.xmlpull.v1.XmlPullParserException;
 
 import soot.jimple.infoflow.InfoflowConfiguration.ImplicitFlowMode;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.LayoutMatchingMode;
+import soot.jimple.infoflow.InfoflowConfiguration.LayoutMatchingMode;
 import soot.jimple.infoflow.android.SetupApplication;
 import soot.jimple.infoflow.results.InfoflowResults;
 import soot.jimple.infoflow.taintWrappers.EasyTaintWrapper;
@@ -38,14 +39,13 @@ public class InsecureBankTests {
 	/**
 	 * Analyzes the given APK file for data flows
 	 * 
-	 * @param enableImplicitFlows
-	 *            True if implicit flows shall be tracked, otherwise false
+	 * @param enableImplicitFlows True if implicit flows shall be tracked, otherwise
+	 *                            false
 	 * @return The data leaks found in the given APK file
-	 * @throws IOException
-	 *             Thrown if the given APK file or any other required file could
-	 *             not be found
-	 * @throws XmlPullParserException
-	 *             Thrown if the Android manifest file could not be read.
+	 * @throws IOException            Thrown if the given APK file or any other
+	 *                                required file could not be found
+	 * @throws XmlPullParserException Thrown if the Android manifest file could not
+	 *                                be read.
 	 */
 	private InfoflowResults analyzeAPKFile(boolean enableImplicitFlows) throws IOException, XmlPullParserException {
 		String androidJars = System.getenv("ANDROID_JARS");
@@ -70,10 +70,12 @@ public class InsecureBankTests {
 	}
 
 	@Test
+	@Ignore("Package is com.android, filteres out as system package")
 	public void runTestInsecureBank() throws IOException, XmlPullParserException {
 		InfoflowResults res = analyzeAPKFile(false);
 		// 7 leaks + 1x inter-component communication (server ip going through
 		// an intent)
+		Assert.assertNotNull(res);
 		Assert.assertEquals(8, res.size());
 
 		Assert.assertTrue(res.isPathBetweenMethods(log_i, activity_findViewById));
diff --git a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/xmlParser/XmlParserTest.java b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/xmlParser/XmlParserTest.java
index 841f6c0..8efdd4f 100644
--- a/soot-infoflow-android/test/soot/jimple/infoflow/android/test/xmlParser/XmlParserTest.java
+++ b/soot-infoflow-android/test/soot/jimple/infoflow/android/test/xmlParser/XmlParserTest.java
@@ -13,8 +13,8 @@ import org.xmlpull.v1.XmlPullParserException;
 import soot.jimple.infoflow.android.data.AndroidMethod;
 import soot.jimple.infoflow.android.data.parsers.PermissionMethodParser;
 import soot.jimple.infoflow.android.source.parsers.xml.XMLSourceSinkParser;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 
 /**
@@ -28,8 +28,7 @@ public class XmlParserTest {
 	/**
 	 * Compares the new and the old Parser for different xml files
 	 * 
-	 * @param xmlFile
-	 *            in new format
+	 * @param xmlFile    in new format
 	 * @param oldXmlFile
 	 * @throws IOException
 	 */
@@ -39,13 +38,13 @@ public class XmlParserTest {
 
 		// The old format can't specify access paths, so we need to fix the data
 		// objects for not comparing apples and oranges
-		Set<SourceSinkDefinition> cleanedSources = new HashSet<>();
-		Set<SourceSinkDefinition> cleanedSinks = new HashSet<>();
-		for (SourceSinkDefinition def : newParser.getSources()) {
+		Set<ISourceSinkDefinition> cleanedSources = new HashSet<>();
+		Set<ISourceSinkDefinition> cleanedSinks = new HashSet<>();
+		for (ISourceSinkDefinition def : newParser.getSources()) {
 			MethodSourceSinkDefinition methodDef = (MethodSourceSinkDefinition) def;
 			cleanedSources.add(new MethodSourceSinkDefinition(methodDef.getMethod()));
 		}
-		for (SourceSinkDefinition def : newParser.getSinks()) {
+		for (ISourceSinkDefinition def : newParser.getSinks()) {
 			MethodSourceSinkDefinition methodDef = (MethodSourceSinkDefinition) def;
 			cleanedSinks.add(new MethodSourceSinkDefinition(methodDef.getMethod()));
 		}
@@ -138,8 +137,8 @@ public class XmlParserTest {
 		// parsing data from xml file
 		String xmlFile = "testXmlParser/complete.xml";
 		XMLSourceSinkParser newParser = XMLSourceSinkParser.fromFile(xmlFile);
-		Set<SourceSinkDefinition> sourceListParser = newParser.getSources();
-		Set<SourceSinkDefinition> sinkListParser = newParser.getSinks();
+		Set<? extends ISourceSinkDefinition> sourceListParser = newParser.getSources();
+		Set<? extends ISourceSinkDefinition> sinkListParser = newParser.getSinks();
 
 		// create two methods with reference data
 		String methodName = "sourceTest";
@@ -167,7 +166,7 @@ public class XmlParserTest {
 
 		// Check the loaded access paths (sinks)
 		Assert.assertEquals(2, sinkListParser.size());
-		for (SourceSinkDefinition def : sinkListParser) {
+		for (ISourceSinkDefinition def : sinkListParser) {
 			MethodSourceSinkDefinition methodDef = (MethodSourceSinkDefinition) def;
 			Assert.assertTrue(methodDef.getMethod().equals(am1) || methodDef.getMethod().equals(am2));
 			if (methodDef.getMethod().equals(am1)) {
diff --git a/soot-infoflow-cmd/pom.xml b/soot-infoflow-cmd/pom.xml
index cf9fb74..890e5d1 100644
--- a/soot-infoflow-cmd/pom.xml
+++ b/soot-infoflow-cmd/pom.xml
@@ -5,7 +5,7 @@
 	<groupId>de.tud.sse</groupId>
 	<artifactId>soot-infoflow-cmd</artifactId>
 	<name>FlowDroid Command Line Util</name>
-	<version>2.7.2-SNAPSHOT</version>
+	<version>2.7.3-SNAPSHOT</version>
 	<description>Command-line utility for running FlowDroid</description>
 	
 	<properties>
@@ -14,6 +14,28 @@
 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 	</properties>
 	
+    <organization>
+        <name>Fraunhofer SIT</name>
+        <url>https://www.sit.fraunhofer.de/</url>
+    </organization>
+
+    <licenses>
+        <license>
+            <name>GNU LESSER GENERAL PUBLIC LICENSE 2.1</name>
+            <url>https://www.gnu.org/licenses/lgpl-2.1.txt</url>
+            <distribution>repo</distribution>
+        </license>
+    </licenses>
+
+    <developers>
+        <developer>
+            <name>Steven Arzt</name>
+            <email>steven.arzt@sit.fraunhofer.de</email>
+            <organization>Fraunhofer SIT</organization>
+            <organizationUrl>https://www.sit.fraunhofer.de/en/</organizationUrl>
+        </developer>
+    </developers>
+
 	<build>
 		<finalName>soot-infoflow-cmd-classes</finalName>
 		<sourceDirectory>src</sourceDirectory>
@@ -105,22 +127,12 @@
 		<dependency>
 			<groupId>de.tud.sse</groupId>
 			<artifactId>soot-infoflow-android</artifactId>
-			<version>2.7.2-SNAPSHOT</version>
+			<version>2.7.3-SNAPSHOT</version>
 		</dependency>
 		<dependency>
 			<groupId>de.tud.sse</groupId>
 			<artifactId>soot-infoflow-summaries</artifactId>
-			<version>2.7.2-SNAPSHOT</version>
-		</dependency>
-		<dependency>
-			<groupId>de.upb.cs.swt</groupId>
-			<artifactId>heros</artifactId>
-			<version>1.1.0</version>
-		</dependency>
-		<dependency>
-			<groupId>ca.mcgill.sable</groupId>
-			<artifactId>soot</artifactId>
-			<version>3.3.0</version>
+			<version>2.7.3-SNAPSHOT</version>
 		</dependency>
 		<dependency>
 			<groupId>commons-cli</groupId>
diff --git a/soot-infoflow-cmd/schema/FlowDroidConfiguration.xsd b/soot-infoflow-cmd/schema/FlowDroidConfiguration.xsd
index aa30ed4..f58a4d4 100644
--- a/soot-infoflow-cmd/schema/FlowDroidConfiguration.xsd
+++ b/soot-infoflow-cmd/schema/FlowDroidConfiguration.xsd
@@ -151,6 +151,8 @@
 			<xs:element name="enableExceptions" type="xs:boolean" minOccurs="0" />
 			<xs:element name="enableArrays" type="xs:boolean" minOccurs="0" />
 			<xs:element name="enableReflection" type="xs:boolean" minOccurs="0" />
+			<xs:element name="enableLineNumbers" type="xs:boolean" minOccurs="0" />
+			<xs:element name="enableOriginalNames" type="xs:boolean" minOccurs="0" />
 			<xs:element name="flowSensitiveAliasing" type="xs:boolean" minOccurs="0" />
 			<xs:element name="logSourcesAndSinks" type="xs:boolean" minOccurs="0" />
 			<xs:element name="enableArraySizeTainting" type="xs:boolean" minOccurs="0" />
diff --git a/soot-infoflow-cmd/src/soot/jimple/infoflow/cmd/MainClass.java b/soot-infoflow-cmd/src/soot/jimple/infoflow/cmd/MainClass.java
index 48fca37..0987cfe 100644
--- a/soot-infoflow-cmd/src/soot/jimple/infoflow/cmd/MainClass.java
+++ b/soot-infoflow-cmd/src/soot/jimple/infoflow/cmd/MainClass.java
@@ -20,17 +20,17 @@ import org.slf4j.LoggerFactory;
 
 import soot.jimple.infoflow.InfoflowConfiguration;
 import soot.jimple.infoflow.InfoflowConfiguration.AliasingAlgorithm;
+import soot.jimple.infoflow.InfoflowConfiguration.CallbackSourceMode;
 import soot.jimple.infoflow.InfoflowConfiguration.CallgraphAlgorithm;
 import soot.jimple.infoflow.InfoflowConfiguration.CodeEliminationMode;
 import soot.jimple.infoflow.InfoflowConfiguration.DataFlowSolver;
 import soot.jimple.infoflow.InfoflowConfiguration.ImplicitFlowMode;
+import soot.jimple.infoflow.InfoflowConfiguration.LayoutMatchingMode;
 import soot.jimple.infoflow.InfoflowConfiguration.PathBuildingAlgorithm;
 import soot.jimple.infoflow.InfoflowConfiguration.PathReconstructionMode;
 import soot.jimple.infoflow.InfoflowConfiguration.StaticFieldTrackingMode;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
 import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CallbackAnalyzer;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.CallbackSourceMode;
-import soot.jimple.infoflow.android.InfoflowAndroidConfiguration.LayoutMatchingMode;
 import soot.jimple.infoflow.android.SetupApplication;
 import soot.jimple.infoflow.android.config.XMLConfigurationParser;
 import soot.jimple.infoflow.methodSummary.data.provider.LazySummaryProvider;
@@ -53,11 +53,11 @@ public class MainClass {
 
 	private final Logger logger = LoggerFactory.getLogger(getClass());
 
-	private final Options options = new Options();
-	private SetupApplication analyzer = null;
-	private ReportMissingSummaryWrapper reportMissingSummaryWrapper;
+	protected final Options options = new Options();
+	protected SetupApplication analyzer = null;
+	protected ReportMissingSummaryWrapper reportMissingSummaryWrapper;
 
-	private Set<String> filesToSkip = new HashSet<>();
+	protected Set<String> filesToSkip = new HashSet<>();
 
 	// Files
 	private static final String OPTION_CONFIG_FILE = "c";
@@ -81,6 +81,8 @@ public class MainClass {
 	private static final String OPTION_NO_TYPE_CHECKING = "nt";
 	private static final String OPTION_REFLECTION = "r";
 	private static final String OPTION_MISSING_SUMMARIES_FILE = "ms";
+	private static final String OPTION_OUTPUT_LINENUMBERS = "ol";
+	private static final String OPTION_ORIGINAL_NAMES = "on";
 
 	// Taint wrapper
 	private static final String OPTION_TAINT_WRAPPER = "tw";
@@ -121,7 +123,7 @@ public class MainClass {
 	// Evaluation-specific options
 	private static final String OPTION_ANALYZE_FRAMEWORKS = "ff";
 
-	private MainClass() {
+	protected MainClass() {
 		initializeCommandLineOptions();
 	}
 
@@ -160,6 +162,10 @@ public class MainClass {
 		options.addOption(OPTION_REFLECTION, "enablereflection", false, "Enable support for reflective method calls");
 		options.addOption(OPTION_MISSING_SUMMARIES_FILE, "missingsummariesoutputfile", true,
 				"Outputs a file with information about which summaries are missing");
+		options.addOption(OPTION_OUTPUT_LINENUMBERS, "outputlinenumbers", false,
+				"Enable the output of bytecode line numbers associated with sources and sinks in XML results");
+		options.addOption(OPTION_ORIGINAL_NAMES, "originalnames", false,
+				"Enable the usage of original variablenames if available");
 
 		// Taint wrapper
 		options.addOption(OPTION_TAINT_WRAPPER, "taintwrapper", true,
@@ -233,7 +239,7 @@ public class MainClass {
 		main.run(args);
 	}
 
-	private void run(String[] args) throws Exception {
+	protected void run(String[] args) throws Exception {
 		// We need proper parameters
 		final HelpFormatter formatter = new HelpFormatter();
 		if (args.length == 0) {
@@ -328,7 +334,7 @@ public class MainClass {
 				}
 
 				// Create the data flow analyzer
-				analyzer = new SetupApplication(config);
+				analyzer = createFlowDroidInstance(config);
 				analyzer.setTaintWrapper(taintWrapper);
 
 				// Start the data flow analysis
@@ -350,6 +356,18 @@ public class MainClass {
 		}
 	}
 
+	/**
+	 * Creates an instance of the FlowDroid data flow solver tool for Android.
+	 * Derived classes can override this method to inject custom variants of
+	 * FlowDroid.
+	 * 
+	 * @param config The configuration object
+	 * @return An instance of the data flow solver
+	 */
+	protected SetupApplication createFlowDroidInstance(final InfoflowAndroidConfiguration config) {
+		return new SetupApplication(config);
+	}
+
 	/**
 	 * Initializes the taint wrapper based on the command-line parameters
 	 * 
@@ -526,6 +544,8 @@ public class MainClass {
 			return PathBuildingAlgorithm.ContextInsensitive;
 		else if (pathAlgo.equalsIgnoreCase("SOURCESONLY"))
 			return PathBuildingAlgorithm.ContextInsensitiveSourceFinder;
+		else if (pathAlgo.equalsIgnoreCase("RECURSIVE"))
+			return PathBuildingAlgorithm.Recursive;
 		else {
 			System.err.println(String.format("Invalid path reconstruction algorithm: %s", pathAlgo));
 			throw new AbortAnalysisException();
@@ -548,6 +568,8 @@ public class MainClass {
 			return DataFlowSolver.ContextFlowSensitive;
 		else if (solver.equalsIgnoreCase("FLOWINSENSITIVE"))
 			return DataFlowSolver.FlowInsensitive;
+		else if (solver.equalsIgnoreCase("GC"))
+			return DataFlowSolver.GarbageCollecting;
 		else {
 			System.err.println(String.format("Invalid data flow solver: %s", solver));
 			throw new AbortAnalysisException();
@@ -699,6 +721,10 @@ public class MainClass {
 			config.setEnableTypeChecking(false);
 		if (cmd.hasOption(OPTION_REFLECTION))
 			config.setEnableReflection(true);
+		if (cmd.hasOption(OPTION_OUTPUT_LINENUMBERS))
+			config.setEnableLineNumbers(true);
+		if (cmd.hasOption(OPTION_ORIGINAL_NAMES))
+			config.setEnableOriginalNames(true);
 		// Individual settings
 		{
 			Integer aplength = getIntOption(cmd, OPTION_ACCESS_PATH_LENGTH);
diff --git a/soot-infoflow-summaries/.classpath b/soot-infoflow-summaries/.classpath
index e73d8a8..f5d795a 100644
--- a/soot-infoflow-summaries/.classpath
+++ b/soot-infoflow-summaries/.classpath
@@ -8,6 +8,7 @@
 	</classpathentry>
 	<classpathentry kind="src" output="build/testclasses" path="test">
 		<attributes>
+			<attribute name="test" value="true"/>
 			<attribute name="optional" value="true"/>
 			<attribute name="maven.pomderived" value="true"/>
 		</attributes>
diff --git a/soot-infoflow-summaries/pom.xml b/soot-infoflow-summaries/pom.xml
index c554463..ca7ff1f 100644
--- a/soot-infoflow-summaries/pom.xml
+++ b/soot-infoflow-summaries/pom.xml
@@ -1,207 +1,230 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-	<modelVersion>4.0.0</modelVersion>
-	<groupId>de.tud.sse</groupId>
-	<artifactId>soot-infoflow-summaries</artifactId>
-	<name>StubDroid</name>
-	<version>2.7.2-SNAPSHOT</version>
-	<description>Data Flow Summaries for FlowDroid</description>
-	
-	<properties>
-		<maven.compiler.source>1.8</maven.compiler.source>
-		<maven.compiler.target>1.8</maven.compiler.target>
-		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-	</properties>
-	
-	<build>
-		<finalName>soot-infoflow-summaries-classes</finalName>
-		<sourceDirectory>src</sourceDirectory>
-		<testSourceDirectory>test</testSourceDirectory>
-		<outputDirectory>build/classes</outputDirectory>
-		<testOutputDirectory>build/testclasses</testOutputDirectory>
-		<plugins>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-compiler-plugin</artifactId>
-				<version>3.2</version>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-surefire-plugin</artifactId>
-				<version>2.17</version>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-jar-plugin</artifactId>
-				<version>3.0.2</version>
-				<configuration>
-					<archive>
-						<manifest>
-							<addClasspath>true</addClasspath>
-							<mainClass>soot.jimple.infoflow.methodSummary.Main</mainClass>
-						</manifest>
-					</archive>
-				</configuration>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-source-plugin</artifactId>
-				<version>3.0.1</version>
-				<executions>
-					<execution>
-						<id>attach-sources</id>
-						<goals>
-							<goal>test-jar</goal>
-						</goals>
-					</execution>
-				</executions>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-javadoc-plugin</artifactId>
-				<version>2.10.4</version>
-				<configuration>
-					<failOnError>false</failOnError>
-				</configuration>
-				<executions>
-					<execution>
-						<id>attach-javadocs</id>
-						<goals>
-							<goal>jar</goal>
-						</goals>
-					</execution>
-				</executions>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-assembly-plugin</artifactId>
-				<configuration>
-					<finalName>soot-infoflow-summaries</finalName>
-					<descriptorRefs>
-						<descriptorRef>jar-with-dependencies</descriptorRef>
-					</descriptorRefs>
-					<archive>
-						<manifest>
-							<addClasspath>true</addClasspath>
-							<mainClass>soot.jimple.infoflow.methodSummary.Main</mainClass>
-						</manifest>
-					</archive>
-				</configuration>
-				<executions>
-					<execution>
-						<id>simple-command</id>
-						<phase>package</phase>
-						<goals>
-							<goal>attached</goal>
-						</goals>
-					</execution>
-				</executions>
-			</plugin>
-		</plugins>
-		
-		<resources>
-	        <resource>
-				<targetPath>summariesManual</targetPath>
-	            <directory>summariesManual</directory>
-	            <includes>
-	                <include>**/*</include>
-	            </includes>
-	        </resource>
-	        <resource>
-	        	<directory>schema</directory>
-	        	<targetPath>schema</targetPath>
-	        </resource>
-		</resources>
-	</build>
-
-	<dependencies>
-		<dependency>
-			<groupId>de.upb.cs.swt</groupId>
-			<artifactId>heros</artifactId>
-			<version>1.1.0</version>
-		</dependency>
-		<!-- Uploaded to http://soot-build.cs.uni-paderborn.de/nexus/repository/soot-snapshot/ 
-			from the nightly build server -->
-		<dependency>
-			<groupId>ca.mcgill.sable</groupId>
-			<artifactId>jasmin</artifactId>
-			<version>3.0.1</version>
-		</dependency>
-		<dependency>
-			<groupId>ca.mcgill.sable</groupId>
-			<artifactId>soot</artifactId>
-			<version>3.3.0</version>
-		</dependency>
-		<dependency>
-			<groupId>de.tud.sse</groupId>
-			<artifactId>soot-infoflow</artifactId>
-			<version>2.7.2-SNAPSHOT</version>
-
-			<exclusions>
-				<exclusion>
-					<groupId>org.slf4j</groupId>
-					<artifactId>slf4j-simple</artifactId>
-				</exclusion>
-				<exclusion>
-					<groupId>log4j</groupId>
-					<artifactId>log4j</artifactId>
-				</exclusion>
-			</exclusions>
-		</dependency>
-		<dependency>
-			<groupId>de.tud.sse</groupId>
-			<artifactId>soot-infoflow</artifactId>
-			<version>2.7.2-SNAPSHOT</version>
-			<type>test-jar</type>
-			<scope>test</scope>
-			
-			<exclusions>
-				<exclusion>
-					<groupId>org.slf4j</groupId>
-					<artifactId>slf4j-simple</artifactId>
-				</exclusion>
-				<exclusion>
-					<groupId>log4j</groupId>
-					<artifactId>log4j</artifactId>
-				</exclusion>
-			</exclusions>
-		</dependency>
-		<dependency>
-			<groupId>junit</groupId>
-			<artifactId>junit</artifactId>
-			<version>4.12</version>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.hamcrest</groupId>
-			<artifactId>hamcrest-core</artifactId>
-			<version>1.3</version>
-			<scope>test</scope>
-		</dependency>
-		<!-- https://mvnrepository.com/artifact/com.google.guava/guava -->
-		<dependency>
-		    <groupId>com.google.guava</groupId>
-		    <artifactId>guava</artifactId>
-		    <version>25.1-jre</version>
-		</dependency>
-		<dependency>
-			<groupId>commons-cli</groupId>
-			<artifactId>commons-cli</artifactId>
-			<version>1.4</version>
-		</dependency>
-	</dependencies>
-	
-	<repositories>
-		<repository>
-			<id>soot-snapshot</id>
-			<name>Soot snapshot server</name>
-			<url>https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-snapshot/</url>
-		</repository>
-		<repository>
-			<id>soot-release</id>
-			<name>Soot release server</name>
-			<url>https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/</url>
-		</repository>
-	</repositories>
-</project>
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+	<groupId>de.tud.sse</groupId>
+	<artifactId>soot-infoflow-summaries</artifactId>
+	<name>StubDroid</name>
+	<version>2.7.3-SNAPSHOT</version>
+	<description>Data Flow Summaries for FlowDroid</description>
+	
+	<properties>
+		<maven.compiler.source>1.8</maven.compiler.source>
+		<maven.compiler.target>1.8</maven.compiler.target>
+		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+		<maven-surefire-plugin.version>2.20.1</maven-surefire-plugin.version>
+	</properties>
+	
+    <organization>
+        <name>Fraunhofer SIT</name>
+        <url>https://www.sit.fraunhofer.de/</url>
+    </organization>
+
+    <licenses>
+        <license>
+            <name>GNU LESSER GENERAL PUBLIC LICENSE 2.1</name>
+            <url>https://www.gnu.org/licenses/lgpl-2.1.txt</url>
+            <distribution>repo</distribution>
+        </license>
+    </licenses>
+
+    <developers>
+        <developer>
+            <name>Steven Arzt</name>
+            <email>steven.arzt@sit.fraunhofer.de</email>
+            <organization>Fraunhofer SIT</organization>
+            <organizationUrl>https://www.sit.fraunhofer.de/en/</organizationUrl>
+        </developer>
+    </developers>
+
+	<build>
+		<finalName>soot-infoflow-summaries-classes</finalName>
+		<sourceDirectory>src</sourceDirectory>
+		<testSourceDirectory>test</testSourceDirectory>
+		<outputDirectory>build/classes</outputDirectory>
+		<testOutputDirectory>build/testclasses</testOutputDirectory>
+		<plugins>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-compiler-plugin</artifactId>
+				<version>3.2</version>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-surefire-plugin</artifactId>
+				<version>${maven-surefire-plugin.version}</version>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-jar-plugin</artifactId>
+				<version>3.0.2</version>
+				<configuration>
+					<archive>
+						<manifest>
+							<addClasspath>true</addClasspath>
+							<mainClass>soot.jimple.infoflow.methodSummary.Main</mainClass>
+						</manifest>
+					</archive>
+				</configuration>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-source-plugin</artifactId>
+				<version>3.0.1</version>
+				<executions>
+					<execution>
+						<id>attach-sources</id>
+						<goals>
+							<goal>test-jar</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+<!--			<plugin>-->
+<!--				<groupId>org.apache.maven.plugins</groupId>-->
+<!--				<artifactId>maven-javadoc-plugin</artifactId>-->
+<!--				<version>2.10.4</version>-->
+<!--				<configuration>-->
+<!--					<failOnError>false</failOnError>-->
+<!--				</configuration>-->
+<!--				<executions>-->
+<!--					<execution>-->
+<!--						<id>attach-javadocs</id>-->
+<!--						<goals>-->
+<!--							<goal>jar</goal>-->
+<!--						</goals>-->
+<!--					</execution>-->
+<!--				</executions>-->
+<!--			</plugin>-->
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-assembly-plugin</artifactId>
+				<configuration>
+					<finalName>soot-infoflow-summaries</finalName>
+					<descriptorRefs>
+						<descriptorRef>jar-with-dependencies</descriptorRef>
+					</descriptorRefs>
+					<archive>
+						<manifest>
+							<addClasspath>true</addClasspath>
+							<mainClass>soot.jimple.infoflow.methodSummary.Main</mainClass>
+						</manifest>
+					</archive>
+				</configuration>
+				<executions>
+					<execution>
+						<id>simple-command</id>
+						<phase>package</phase>
+						<goals>
+							<goal>attached</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+		</plugins>
+		
+		<resources>
+	        <resource>
+				<targetPath>summariesManual</targetPath>
+	            <directory>summariesManual</directory>
+	            <includes>
+	                <include>**/*</include>
+	            </includes>
+	        </resource>
+	        <resource>
+	        	<directory>schema</directory>
+	        	<targetPath>schema</targetPath>
+	        </resource>
+		</resources>
+	</build>
+
+	<dependencies>
+<!--		<dependency>-->
+<!--			<groupId>de.upb.cs.swt</groupId>-->
+<!--			<artifactId>heros</artifactId>-->
+<!--			<version>1.1.0</version>-->
+<!--		</dependency>-->
+<!--		&lt;!&ndash; Uploaded to http://soot-build.cs.uni-paderborn.de/nexus/repository/soot-snapshot/ -->
+<!--			from the nightly build server &ndash;&gt;-->
+<!--		<dependency>-->
+<!--			<groupId>ca.mcgill.sable</groupId>-->
+<!--			<artifactId>jasmin</artifactId>-->
+<!--			<version>3.0.1</version>-->
+<!--		</dependency>-->
+<!--		<dependency>-->
+<!--			<groupId>ca.mcgill.sable</groupId>-->
+<!--			<artifactId>soot</artifactId>-->
+<!--			<version>3.3.1-SNAPSHOT</version>-->
+<!--		</dependency>-->
+		<dependency>
+			<groupId>de.tud.sse</groupId>
+			<artifactId>soot-infoflow</artifactId>
+			<version>2.7.3-SNAPSHOT</version>
+
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>slf4j-simple</artifactId>
+				</exclusion>
+				<exclusion>
+					<groupId>log4j</groupId>
+					<artifactId>log4j</artifactId>
+				</exclusion>
+			</exclusions>
+		</dependency>
+		<dependency>
+			<groupId>de.tud.sse</groupId>
+			<artifactId>soot-infoflow</artifactId>
+			<version>2.7.3-SNAPSHOT</version>
+			<type>test-jar</type>
+			<scope>test</scope>
+			
+			<exclusions>
+				<exclusion>
+					<groupId>org.slf4j</groupId>
+					<artifactId>slf4j-simple</artifactId>
+				</exclusion>
+				<exclusion>
+					<groupId>log4j</groupId>
+					<artifactId>log4j</artifactId>
+				</exclusion>
+			</exclusions>
+		</dependency>
+		<dependency>
+			<groupId>junit</groupId>
+			<artifactId>junit</artifactId>
+			<version>4.12</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.hamcrest</groupId>
+			<artifactId>hamcrest-core</artifactId>
+			<version>1.3</version>
+			<scope>test</scope>
+		</dependency>
+		<!-- https://mvnrepository.com/artifact/com.google.guava/guava -->
+		<dependency>
+		    <groupId>com.google.guava</groupId>
+		    <artifactId>guava</artifactId>
+		    <version>25.1-jre</version>
+		</dependency>
+		<dependency>
+			<groupId>commons-cli</groupId>
+			<artifactId>commons-cli</artifactId>
+			<version>1.4</version>
+		</dependency>
+	</dependencies>
+	
+	<repositories>
+		<repository>
+			<id>soot-snapshot</id>
+			<name>Soot snapshot server</name>
+			<url>https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-snapshot/</url>
+		</repository>
+		<repository>
+			<id>soot-release</id>
+			<name>Soot release server</name>
+			<url>https://soot-build.cs.uni-paderborn.de/nexus/repository/soot-release/</url>
+		</repository>
+	</repositories>
+</project>
diff --git a/soot-infoflow-summaries/schema/ClassSummary.xsd b/soot-infoflow-summaries/schema/ClassSummary.xsd
index 7b0d183..ba4a731 100644
--- a/soot-infoflow-summaries/schema/ClassSummary.xsd
+++ b/soot-infoflow-summaries/schema/ClassSummary.xsd
@@ -34,6 +34,7 @@
 			</xs:choice>
 		</xs:sequence>
 		<xs:attribute name="fileFormatVersion" type="xs:int" />
+		<xs:attribute name="isInterface" type="xs:boolean" />
 	</xs:complexType>
 </xs:element>
 
@@ -55,6 +56,7 @@
 		</xs:element>
 	</xs:sequence>
 	<xs:attribute name="id" type="xs:string" />
+	<xs:attribute name="isExcluded" type="xs:boolean" />
 </xs:complexType>
 
 <xs:complexType name="flowType">
diff --git a/soot-infoflow-summaries/schema/SummaryMetaData.xsd b/soot-infoflow-summaries/schema/SummaryMetaData.xsd
index 81e71a4..c20a45d 100644
--- a/soot-infoflow-summaries/schema/SummaryMetaData.xsd
+++ b/soot-infoflow-summaries/schema/SummaryMetaData.xsd
@@ -3,7 +3,7 @@
 
 <xs:element name="summaryMetaData">
 	<xs:complexType>
-		<xs:sequence minOccurs="1" maxOccurs="1">
+		<xs:sequence minOccurs="1" maxOccurs="unbounded">
 			<xs:choice>
 				<xs:element name="exclusiveModels" minOccurs="0" maxOccurs="1">
 					<xs:complexType>
@@ -12,6 +12,13 @@
 						</xs:sequence>
 					</xs:complexType>
 				</xs:element>
+				<xs:element name="hierarchy" minOccurs="0" maxOccurs="1">
+					<xs:complexType>
+						<xs:sequence>
+							<xs:element name="class" type="classType" minOccurs="0" maxOccurs="unbounded" />
+						</xs:sequence>
+					</xs:complexType>
+				</xs:element>
 			</xs:choice>
 		</xs:sequence>
 		<xs:attribute name="fileFormatVersion" type="xs:int" />
@@ -30,4 +37,9 @@
 	</xs:restriction>
 </xs:simpleType>
 
+<xs:complexType name="classType">
+	<xs:attribute name="name" type="xs:string" use="required" />
+	<xs:attribute name="superClass" type="xs:string" use="optional" />
+</xs:complexType>
+
 </xs:schema>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/Main.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/Main.java
index abf0478..dee317e 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/Main.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/Main.java
@@ -124,7 +124,7 @@ class Main {
 			generator.getConfig().setExcludes(excludes);
 
 			// Set optional settings
-			conifgureOptionalSettings(cmd, generator);
+			configureOptionalSettings(cmd, generator);
 
 			// Configure the output directory
 			if (!toAnalyze.exists()) {
@@ -149,6 +149,13 @@ class Main {
 					System.out.println(String.format("Jar %d of %d: %s", c + 1, files.length, f));
 					createSummaries(generator, classesToAnalyze, forceOverwrite, f, outputFolder);
 				}
+
+				// If we don't have any JAR files, the target may be a normal classpath with
+				// Java class files
+				if (files.length == 0) {
+					System.out.println(String.format("Analyzing directory %s...", toAnalyze.getAbsolutePath()));
+					createSummaries(generator, classesToAnalyze, forceOverwrite, toAnalyze, outputFolder);
+				}
 			} else {
 				createSummaries(generator, classesToAnalyze, forceOverwrite, toAnalyze, outputFolder);
 			}
@@ -167,7 +174,7 @@ class Main {
 	 * @param cmd       The command-line options
 	 * @param generator The summary generator
 	 */
-	protected void conifgureOptionalSettings(CommandLine cmd, SummaryGenerator generator) {
+	protected void configureOptionalSettings(CommandLine cmd, SummaryGenerator generator) {
 		{
 			int repeatCount = Integer.parseInt(cmd.getOptionValue(OPTION_REPEAT, "-1"));
 			if (repeatCount > 0)
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/factory/SourceSinkFactory.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/factory/SourceSinkFactory.java
index 5864d35..d319c17 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/factory/SourceSinkFactory.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/factory/SourceSinkFactory.java
@@ -1,13 +1,13 @@
 package soot.jimple.infoflow.methodSummary.data.factory;
 
 import soot.ArrayType;
-import soot.SootField;
 import soot.Type;
 import soot.jimple.infoflow.data.AccessPath;
 import soot.jimple.infoflow.methodSummary.data.sourceSink.FlowSink;
 import soot.jimple.infoflow.methodSummary.data.sourceSink.FlowSource;
 import soot.jimple.infoflow.methodSummary.data.summary.GapDefinition;
 import soot.jimple.infoflow.methodSummary.data.summary.SourceSinkType;
+import soot.jimple.infoflow.methodSummary.taintWrappers.AccessPathFragment;
 
 /**
  * Factory class for source and sink data objects
@@ -23,41 +23,15 @@ public class SourceSinkFactory {
 	}
 
 	/**
-	 * Cuts the given array of fields to the maximum access path length
+	 * Cuts the given access path to the maximum access path length
 	 * 
-	 * @param fields The array of fields to cut
-	 * @return The cut array of fields
+	 * @param fields The access path to cut
+	 * @return The cut access path
 	 */
-	private SootField[] cutAPLength(SootField[] fields) {
-		if (fields == null || fields.length == 0)
+	private AccessPathFragment cutAPLength(AccessPathFragment accessPath) {
+		if (accessPath == null || accessPath.isEmpty())
 			return null;
-		if (fields.length <= summaryAPLength)
-			return fields;
-		if (summaryAPLength < 0)
-			return fields;
-
-		SootField f[] = new SootField[summaryAPLength];
-		System.arraycopy(fields, 0, f, 0, summaryAPLength);
-		return f;
-	}
-
-	/**
-	 * Cuts the given array of types to the maximum access path length
-	 * 
-	 * @param fields The array of types to cut
-	 * @return The cut array of types
-	 */
-	private Type[] cutAPLength(Type[] fields) {
-		if (fields == null || fields.length == 0)
-			return null;
-		if (fields.length <= summaryAPLength)
-			return fields;
-		if (summaryAPLength < 0)
-			return fields;
-
-		Type f[] = new Type[summaryAPLength];
-		System.arraycopy(fields, 0, f, 0, summaryAPLength);
-		return f;
+		return accessPath.prefix(summaryAPLength);
 	}
 
 	public FlowSource createParameterSource(int parameterIdx, String baseType) {
@@ -81,8 +55,7 @@ public class SourceSinkFactory {
 	 */
 	public FlowSource createSource(SourceSinkType type, int parameterIdx, AccessPath accessPath, GapDefinition gap) {
 		return new FlowSource(type, parameterIdx, accessPath.getBaseType().toString(),
-				sootFieldsToString(cutAPLength(accessPath.getFields())),
-				sootTypesToString(cutAPLength(accessPath.getFieldTypes())), gap);
+				cutAPLength(new AccessPathFragment(accessPath)), gap);
 	}
 
 	/**
@@ -117,12 +90,10 @@ public class SourceSinkFactory {
 						accessPath.getTaintSubFields(), gap);
 		} else if (accessPath.getFieldCount() < summaryAPLength)
 			return new FlowSink(SourceSinkType.Parameter, paraIdx, accessPath.getBaseType().toString(),
-					sootFieldsToString(accessPath.getFields()), sootTypesToString(accessPath.getFieldTypes()),
-					accessPath.getTaintSubFields(), gap, false);
+					new AccessPathFragment(accessPath), accessPath.getTaintSubFields(), gap, false);
 		else
 			return new FlowSink(SourceSinkType.Parameter, paraIdx, accessPath.getBaseType().toString(),
-					sootFieldsToString(cutAPLength(accessPath.getFields())),
-					sootTypesToString(cutAPLength(accessPath.getFieldTypes())), true, gap, false);
+					cutAPLength(new AccessPathFragment(accessPath)), true, gap, false);
 	}
 
 	/**
@@ -162,12 +133,10 @@ public class SourceSinkFactory {
 					accessPath.getTaintSubFields(), gap);
 		else if (accessPath.getFieldCount() < summaryAPLength)
 			return new FlowSink(SourceSinkType.Return, -1, accessPath.getBaseType().toString(),
-					sootFieldsToString(accessPath.getFields()), sootTypesToString(accessPath.getFieldTypes()),
-					accessPath.getTaintSubFields(), gap, false);
+					new AccessPathFragment(accessPath), accessPath.getTaintSubFields(), gap, false);
 		else
 			return new FlowSink(SourceSinkType.Return, -1, accessPath.getBaseType().toString(),
-					sootFieldsToString(cutAPLength(accessPath.getFields())),
-					sootTypesToString(cutAPLength(accessPath.getFieldTypes())), true, gap, false);
+					cutAPLength(new AccessPathFragment(accessPath)), true, gap, false);
 	}
 
 	/**
@@ -193,44 +162,10 @@ public class SourceSinkFactory {
 					accessPath.getTaintSubFields(), gap);
 		else if (accessPath.getFieldCount() < summaryAPLength)
 			return new FlowSink(SourceSinkType.Field, -1, accessPath.getBaseType().toString(),
-					sootFieldsToString(accessPath.getFields()), sootTypesToString(accessPath.getFieldTypes()),
-					accessPath.getTaintSubFields(), gap, false);
+					new AccessPathFragment(accessPath), accessPath.getTaintSubFields(), gap, false);
 		else
 			return new FlowSink(SourceSinkType.Field, -1, accessPath.getBaseType().toString(),
-					sootFieldsToString(cutAPLength(accessPath.getFields())),
-					sootTypesToString(cutAPLength(accessPath.getFieldTypes())), true, gap, false);
-	}
-
-	/**
-	 * Converts an array of Soot fields into a string representation
-	 * 
-	 * @param fields The array of Soot fields to convert
-	 * @return The string representation of the given Soot fields
-	 */
-	private String[] sootFieldsToString(SootField[] fields) {
-		if (fields == null || fields.length == 0)
-			return null;
-
-		String[] res = new String[fields.length];
-		for (int i = 0; i < fields.length; i++)
-			res[i] = fields[i].toString();
-		return res;
-	}
-
-	/**
-	 * Converts an array of Soot types into a string representation
-	 * 
-	 * @param fields The array of Soot types to convert
-	 * @return The string representation of the given Soot types
-	 */
-	private String[] sootTypesToString(Type[] types) {
-		if (types == null || types.length == 0)
-			return null;
-
-		String[] res = new String[types.length];
-		for (int i = 0; i < types.length; i++)
-			res[i] = types[i].toString();
-		return res;
+					cutAPLength(new AccessPathFragment(accessPath)), true, gap, false);
 	}
 
 	/**
@@ -251,12 +186,10 @@ public class SourceSinkFactory {
 						accessPath.getTaintSubFields());
 		} else if (accessPath.getFieldCount() < summaryAPLength)
 			return new FlowSink(SourceSinkType.Parameter, paraIdx, accessPath.getBaseType().toString(),
-					sootFieldsToString(accessPath.getFields()), sootTypesToString(accessPath.getFieldTypes()),
-					accessPath.getTaintSubFields());
+					new AccessPathFragment(accessPath), accessPath.getTaintSubFields());
 		else
 			return new FlowSink(SourceSinkType.Parameter, paraIdx, accessPath.getBaseType().toString(),
-					sootFieldsToString(cutAPLength(accessPath.getFields())),
-					sootTypesToString(cutAPLength(accessPath.getFieldTypes())), true);
+					cutAPLength(new AccessPathFragment(accessPath)), true);
 	}
 
 	/**
@@ -279,12 +212,10 @@ public class SourceSinkFactory {
 						accessPath.getTaintSubFields(), gap, userData);
 		} else if (accessPath.getFieldCount() < summaryAPLength)
 			return new FlowSink(SourceSinkType.Custom, paraIdx, accessPath.getBaseType().toString(),
-					sootFieldsToString(accessPath.getFields()), sootTypesToString(accessPath.getFieldTypes()),
-					accessPath.getTaintSubFields(), gap, userData, false);
+					new AccessPathFragment(accessPath), accessPath.getTaintSubFields(), gap, userData, false);
 		else
 			return new FlowSink(SourceSinkType.Custom, paraIdx, accessPath.getBaseType().toString(),
-					sootFieldsToString(cutAPLength(accessPath.getFields())),
-					sootTypesToString(cutAPLength(accessPath.getFieldTypes())), true, gap, userData, false);
+					cutAPLength(new AccessPathFragment(accessPath)), true, gap, userData, false);
 	}
 
 }
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/IMethodSummaryProvider.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/IMethodSummaryProvider.java
index f808c37..f578400 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/IMethodSummaryProvider.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/IMethodSummaryProvider.java
@@ -103,4 +103,14 @@ public interface IMethodSummaryProvider {
 	 */
 	public ClassSummaries getSummaries();
 
+	/**
+	 * Gets whether the given method has been excluded from the data flow analysis
+	 * 
+	 * @param className    The name of the class that contains the method to check
+	 * @param subSignature The method to check
+	 * @return True if the given method has been excluded from the data flow
+	 *         analysis, false otherwise
+	 */
+	public boolean isMethodExcluded(String className, String subSignature);
+
 }
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/MemorySummaryProvider.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/MemorySummaryProvider.java
index e527b6e..5a07b12 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/MemorySummaryProvider.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/MemorySummaryProvider.java
@@ -85,4 +85,12 @@ public class MemorySummaryProvider implements IMethodSummaryProvider {
 		summaries.merge(summaries);
 	}
 
+	@Override
+	public boolean isMethodExcluded(String className, String subSignature) {
+		ClassMethodSummaries classSummaries = summaries.getClassSummaries(className);
+		if (classSummaries == null)
+			return false;
+		return classSummaries.getMethodSummaries().isExcluded(subSignature);
+	}
+
 }
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/MergingSummaryProvider.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/MergingSummaryProvider.java
index 0b89e93..7e4a9e0 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/MergingSummaryProvider.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/MergingSummaryProvider.java
@@ -127,4 +127,13 @@ public class MergingSummaryProvider implements IMethodSummaryProvider {
 		return summaries;
 	}
 
+	@Override
+	public boolean isMethodExcluded(String className, String subSignature) {
+		for (IMethodSummaryProvider provider : innerProviders) {
+			if (provider.isMethodExcluded(className, subSignature))
+				return true;
+		}
+		return false;
+	}
+
 }
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/XMLSummaryProvider.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/XMLSummaryProvider.java
index cc50e23..9bcc99f 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/XMLSummaryProvider.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/provider/XMLSummaryProvider.java
@@ -29,6 +29,7 @@ import soot.jimple.infoflow.methodSummary.data.summary.ClassSummaries;
 import soot.jimple.infoflow.methodSummary.data.summary.MethodClear;
 import soot.jimple.infoflow.methodSummary.data.summary.MethodFlow;
 import soot.jimple.infoflow.methodSummary.data.summary.MethodSummaries;
+import soot.jimple.infoflow.methodSummary.data.summary.SummaryMetaData;
 import soot.jimple.infoflow.methodSummary.xml.MetaDataReader;
 import soot.jimple.infoflow.methodSummary.xml.SummaryReader;
 import soot.util.MultiMap;
@@ -41,7 +42,7 @@ public class XMLSummaryProvider implements IMethodSummaryProvider {
 
 	private final Logger logger = LoggerFactory.getLogger(getClass());
 
-	private final static String FILE_META_DATA = "SummaryMetaData.xml";
+	protected final static String FILE_META_DATA = "SummaryMetaData.xml";
 
 	private final SummaryReader summaryReader;
 	private MetaDataReader metaDataReader;
@@ -50,8 +51,8 @@ public class XMLSummaryProvider implements IMethodSummaryProvider {
 
 	private Set<String> supportedClasses = new HashSet<String>();
 	protected Set<String> loadableClasses = new HashSet<String>();
-	private Set<File> files;
-	private Set<Path> pathes;
+	protected Set<File> files;
+	protected Set<Path> pathes;
 	private FileSystem fileSystem;
 
 	protected Set<String> subsigMethodsWithSummaries = new HashSet<String>();
@@ -252,10 +253,21 @@ public class XMLSummaryProvider implements IMethodSummaryProvider {
 
 	@Override
 	public ClassMethodSummaries getMethodFlows(String className, String methodSignature) {
+		ClassMethodSummaries classSummaries = getClassSummaries(className);
+		return classSummaries == null ? null : classSummaries.filterForMethod(methodSignature);
+	}
+
+	/**
+	 * Gets all summaries for the given class
+	 * 
+	 * @param className The name of the class for which to get the summaries
+	 * @return The data flow summaries for the given class
+	 */
+	protected ClassMethodSummaries getClassSummaries(String className) {
 		if (loadableClasses != null && loadableClasses.contains(className))
 			loadClass(className);
 		ClassMethodSummaries classSummaries = summaries.getClassSummaries(className);
-		return classSummaries == null ? null : classSummaries.filterForMethod(methodSignature);
+		return classSummaries;
 	}
 
 	protected void loadClass(String clazz) {
@@ -327,11 +339,13 @@ public class XMLSummaryProvider implements IMethodSummaryProvider {
 	 */
 	private void loadMetaData() {
 		// Do we have a plain file we can load?
+		SummaryMetaData metadata = null;
 		if (files != null) {
 			for (File f : files) {
 				if (f.getName().equals(FILE_META_DATA)) {
 					try {
-						summaries.setMetaData(metaDataReader.read(f));
+						metadata = metaDataReader.read(f);
+						summaries.setMetaData(metadata);
 					} catch (Exception ex) {
 						LoggerFactory.getLogger(getClass())
 								.error("An error occurred while loading the meta data data of %s");
@@ -345,7 +359,8 @@ public class XMLSummaryProvider implements IMethodSummaryProvider {
 			for (Path path : pathes) {
 				if (getFileName(path).equals(FILE_META_DATA)) {
 					try (InputStream inputStream = path.getFileSystem().provider().newInputStream(path)) {
-						summaries.setMetaData(metaDataReader.read(new InputStreamReader(inputStream)));
+						metadata = metaDataReader.read(new InputStreamReader(inputStream));
+						summaries.setMetaData(metadata);
 					} catch (Exception e) {
 						LoggerFactory.getLogger(getClass())
 								.error("An error occurred while loading the meta data data of %s");
@@ -353,6 +368,10 @@ public class XMLSummaryProvider implements IMethodSummaryProvider {
 				}
 			}
 		}
+
+		// Merge the hierarchy data from the metadata object into the summaries
+		if (metadata != null)
+			metadata.mergeHierarchyData(summaries);
 	}
 
 	public boolean hasLoadingErrors() {
@@ -410,4 +429,10 @@ public class XMLSummaryProvider implements IMethodSummaryProvider {
 		return subsigMethodsWithSummaries.contains(subsig);
 	}
 
+	@Override
+	public boolean isMethodExcluded(String className, String subSignature) {
+		ClassMethodSummaries summaries = getClassSummaries(className);
+		return summaries != null && summaries.getMethodSummaries().isExcluded(subSignature);
+	}
+
 }
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/AbstractFlowSinkSource.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/AbstractFlowSinkSource.java
index ba6132c..8ffb192 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/AbstractFlowSinkSource.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/AbstractFlowSinkSource.java
@@ -1,11 +1,11 @@
 package soot.jimple.infoflow.methodSummary.data.sourceSink;
 
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 
 import soot.jimple.infoflow.methodSummary.data.summary.GapDefinition;
 import soot.jimple.infoflow.methodSummary.data.summary.SourceSinkType;
+import soot.jimple.infoflow.methodSummary.taintWrappers.AccessPathFragment;
 import soot.jimple.infoflow.methodSummary.xml.XMLConstants;
 
 /**
@@ -16,8 +16,7 @@ public abstract class AbstractFlowSinkSource {
 	protected final SourceSinkType type;
 	protected final int parameterIdx;
 	protected final String baseType;
-	protected final String[] accessPath;
-	protected final String[] accessPathTypes;
+	protected final AccessPathFragment accessPath;
 	protected final GapDefinition gap;
 	protected final Object userData;
 	protected final boolean matchStrict;
@@ -26,30 +25,25 @@ public abstract class AbstractFlowSinkSource {
 		this(type, parameterIdx, baseType, null, null, matchStrict);
 	}
 
-	public AbstractFlowSinkSource(SourceSinkType type, int parameterIdx, String baseType, String[] accessPath,
-			String[] accessPathTypes, boolean matchStrict) {
-		this(type, parameterIdx, baseType, accessPath, accessPathTypes, null, matchStrict);
+	public AbstractFlowSinkSource(SourceSinkType type, int parameterIdx, String baseType, AccessPathFragment accessPath,
+			boolean matchStrict) {
+		this(type, parameterIdx, baseType, accessPath, null, matchStrict);
 	}
 
-	public AbstractFlowSinkSource(SourceSinkType type, int parameterIdx, String baseType, String[] accessPath,
-			String[] accessPathTypes, GapDefinition gap, boolean matchStrict) {
-		this(type, parameterIdx, baseType, accessPath, accessPathTypes, gap, null, matchStrict);
+	public AbstractFlowSinkSource(SourceSinkType type, int parameterIdx, String baseType, AccessPathFragment accessPath,
+			GapDefinition gap, boolean matchStrict) {
+		this(type, parameterIdx, baseType, accessPath, gap, null, matchStrict);
 	}
 
-	public AbstractFlowSinkSource(SourceSinkType type, int parameterIdx, String baseType, String[] accessPath,
-			String[] accessPathTypes, GapDefinition gap, Object userData, boolean matchStrict) {
+	public AbstractFlowSinkSource(SourceSinkType type, int parameterIdx, String baseType, AccessPathFragment accessPath,
+			GapDefinition gap, Object userData, boolean matchStrict) {
 		this.type = type;
 		this.parameterIdx = parameterIdx;
 		this.baseType = baseType;
 		this.accessPath = accessPath;
-		this.accessPathTypes = accessPathTypes;
 		this.gap = gap;
 		this.userData = userData;
 		this.matchStrict = matchStrict;
-
-		// Sanity check
-		if (accessPath != null && accessPathTypes != null && accessPath.length != accessPathTypes.length)
-			throw new RuntimeException("Access path arrayand type array must be of equal length");
 	}
 
 	/**
@@ -69,10 +63,10 @@ public abstract class AbstractFlowSinkSource {
 				|| !safeCompare(this.baseType, other.baseType) || !safeCompare(this.gap, other.gap))
 			return false;
 		if (this.accessPath != null && other.accessPath != null) {
-			if (this.accessPath.length > other.accessPath.length)
+			if (this.accessPath.length() > other.accessPath.length())
 				return false;
-			for (int i = 0; i < this.accessPath.length; i++)
-				if (!this.accessPath[i].equals(other.accessPath[i]))
+			for (int i = 0; i < this.accessPath.length(); i++)
+				if (!this.accessPath.getField(i).equals(other.accessPath.getField(i)))
 					return false;
 		}
 		return true;
@@ -108,14 +102,10 @@ public abstract class AbstractFlowSinkSource {
 		return type == SourceSinkType.Field;
 	}
 
-	public String[] getAccessPath() {
+	public AccessPathFragment getAccessPath() {
 		return accessPath;
 	}
 
-	public String[] getAccessPathTypes() {
-		return accessPathTypes;
-	}
-
 	public boolean isReturn() {
 		return type == SourceSinkType.Return;
 	}
@@ -125,13 +115,11 @@ public abstract class AbstractFlowSinkSource {
 	}
 
 	public boolean hasAccessPath() {
-		return accessPath != null && accessPath.length > 0;
+		return accessPath != null && !accessPath.isEmpty();
 	}
 
 	public int getAccessPathLength() {
-		if (hasAccessPath())
-			return accessPath.length;
-		return 0;
+		return accessPath == null ? 0 : accessPath.length();
 	}
 
 	public SourceSinkType getType() {
@@ -147,9 +135,9 @@ public abstract class AbstractFlowSinkSource {
 	}
 
 	public String getLastFieldType() {
-		if (accessPathTypes == null || accessPathTypes.length == 0)
+		if (accessPath == null || accessPath.isEmpty())
 			return baseType;
-		return accessPathTypes[accessPathTypes.length - 1];
+		return accessPath.getLastFieldType();
 	}
 
 	/**
@@ -167,8 +155,7 @@ public abstract class AbstractFlowSinkSource {
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
-		result = prime * result + Arrays.hashCode(accessPath);
-		result = prime * result + Arrays.hashCode(accessPathTypes);
+		result = prime * result + ((accessPath == null) ? 0 : accessPath.hashCode());
 		result = prime * result + ((baseType == null) ? 0 : baseType.hashCode());
 		result = prime * result + ((gap == null) ? 0 : gap.hashCode());
 		result = prime * result + (matchStrict ? 1231 : 1237);
@@ -187,9 +174,10 @@ public abstract class AbstractFlowSinkSource {
 		if (getClass() != obj.getClass())
 			return false;
 		AbstractFlowSinkSource other = (AbstractFlowSinkSource) obj;
-		if (!Arrays.equals(accessPath, other.accessPath))
-			return false;
-		if (!Arrays.equals(accessPathTypes, other.accessPathTypes))
+		if (accessPath == null) {
+			if (other.accessPath != null)
+				return false;
+		} else if (!accessPath.equals(other.accessPath))
 			return false;
 		if (baseType == null) {
 			if (other.baseType != null)
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowClear.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowClear.java
index 006f189..211e29d 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowClear.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowClear.java
@@ -4,6 +4,7 @@ import java.util.Map;
 
 import soot.jimple.infoflow.methodSummary.data.summary.GapDefinition;
 import soot.jimple.infoflow.methodSummary.data.summary.SourceSinkType;
+import soot.jimple.infoflow.methodSummary.taintWrappers.AccessPathFragment;
 
 /**
  * Definition of a point at which an existing data flow is killed
@@ -21,12 +22,12 @@ public class FlowClear extends AbstractFlowSinkSource implements Cloneable {
 		super(type, -1, baseType, null, null, gap, false);
 	}
 
-	public FlowClear(SourceSinkType type, String baseType, String[] fields, String[] fieldTypes) {
-		super(type, -1, baseType, fields, fieldTypes, false);
+	public FlowClear(SourceSinkType type, String baseType, AccessPathFragment accessPath) {
+		super(type, -1, baseType, accessPath, false);
 	}
 
-	public FlowClear(SourceSinkType type, String baseType, String[] fields, String[] fieldTypes, GapDefinition gap) {
-		super(type, -1, baseType, fields, fieldTypes, gap, false);
+	public FlowClear(SourceSinkType type, String baseType, AccessPathFragment accessPath, GapDefinition gap) {
+		super(type, -1, baseType, accessPath, gap, false);
 	}
 
 	public FlowClear(SourceSinkType type, int parameterIdx, String baseType) {
@@ -37,18 +38,18 @@ public class FlowClear extends AbstractFlowSinkSource implements Cloneable {
 		super(type, parameterIdx, baseType, null, null, gap, false);
 	}
 
-	public FlowClear(SourceSinkType type, int parameterIdx, String baseType, String[] fields, String[] fieldTypes) {
-		super(type, parameterIdx, baseType, fields, fieldTypes, false);
+	public FlowClear(SourceSinkType type, int parameterIdx, String baseType, AccessPathFragment accessPath) {
+		super(type, parameterIdx, baseType, accessPath, false);
 	}
 
-	public FlowClear(SourceSinkType type, int parameterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public FlowClear(SourceSinkType type, int parameterIdx, String baseType, AccessPathFragment accessPath,
 			GapDefinition gap) {
-		super(type, parameterIdx, baseType, fields, fieldTypes, gap, false);
+		super(type, parameterIdx, baseType, accessPath, gap, false);
 	}
 
-	public FlowClear(SourceSinkType type, int parameterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public FlowClear(SourceSinkType type, int parameterIdx, String baseType, AccessPathFragment accessPath,
 			GapDefinition gap, Object userData) {
-		super(type, parameterIdx, baseType, fields, fieldTypes, gap, userData, false);
+		super(type, parameterIdx, baseType, accessPath, gap, userData, false);
 	}
 
 	@Override
@@ -58,12 +59,12 @@ public class FlowClear extends AbstractFlowSinkSource implements Cloneable {
 		GapDefinition newGap = replacementMap.get(gap.getID());
 		if (newGap == null)
 			return this;
-		return new FlowClear(type, parameterIdx, baseType, accessPath, accessPathTypes, newGap);
+		return new FlowClear(type, parameterIdx, baseType, accessPath, newGap);
 	}
 
 	@Override
 	protected Object clone() throws CloneNotSupportedException {
-		return new FlowClear(type, parameterIdx, baseType, accessPath, accessPathTypes, gap, userData);
+		return new FlowClear(type, parameterIdx, baseType, accessPath, gap, userData);
 	}
 
 }
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowSink.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowSink.java
index ffcf737..694d0c0 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowSink.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowSink.java
@@ -1,10 +1,10 @@
 package soot.jimple.infoflow.methodSummary.data.sourceSink;
 
-import java.util.Arrays;
 import java.util.Map;
 
 import soot.jimple.infoflow.methodSummary.data.summary.GapDefinition;
 import soot.jimple.infoflow.methodSummary.data.summary.SourceSinkType;
+import soot.jimple.infoflow.methodSummary.taintWrappers.AccessPathFragment;
 import soot.jimple.infoflow.methodSummary.xml.XMLConstants;
 
 /**
@@ -16,27 +16,27 @@ public class FlowSink extends AbstractFlowSinkSource implements Cloneable {
 
 	protected final boolean taintSubFields;
 
-	public FlowSink(SourceSinkType type, int paramterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public FlowSink(SourceSinkType type, int paramterIdx, String baseType, AccessPathFragment accessPath,
 			boolean taintSubFields) {
-		super(type, paramterIdx, baseType, fields, fieldTypes, false);
+		super(type, paramterIdx, baseType, accessPath, false);
 		this.taintSubFields = taintSubFields;
 	}
 
-	public FlowSink(SourceSinkType type, int paramterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public FlowSink(SourceSinkType type, int paramterIdx, String baseType, AccessPathFragment accessPath,
 			boolean taintSubFields, GapDefinition gap) {
-		super(type, paramterIdx, baseType, fields, fieldTypes, gap, false);
+		super(type, paramterIdx, baseType, accessPath, gap, false);
 		this.taintSubFields = taintSubFields;
 	}
 
-	public FlowSink(SourceSinkType type, int paramterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public FlowSink(SourceSinkType type, int paramterIdx, String baseType, AccessPathFragment accessPath,
 			boolean taintSubFields, GapDefinition gap, boolean matchStrict) {
-		super(type, paramterIdx, baseType, fields, fieldTypes, gap, matchStrict);
+		super(type, paramterIdx, baseType, accessPath, gap, matchStrict);
 		this.taintSubFields = taintSubFields;
 	}
 
-	public FlowSink(SourceSinkType type, int paramterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public FlowSink(SourceSinkType type, int paramterIdx, String baseType, AccessPathFragment accessPath,
 			boolean taintSubFields, GapDefinition gap, Object userData, boolean matchStrict) {
-		super(type, paramterIdx, baseType, fields, fieldTypes, gap, userData, matchStrict);
+		super(type, paramterIdx, baseType, accessPath, gap, userData, matchStrict);
 		this.taintSubFields = taintSubFields;
 	}
 
@@ -46,26 +46,26 @@ public class FlowSink extends AbstractFlowSinkSource implements Cloneable {
 	}
 
 	public FlowSink(SourceSinkType type, int paramterIdx, String baseType, boolean taintSubFields, GapDefinition gap) {
-		super(type, paramterIdx, baseType, null, null, gap, false);
+		super(type, paramterIdx, baseType, null, gap, null, false);
 		this.taintSubFields = taintSubFields;
 	}
 
 	public FlowSink(SourceSinkType type, int paramterIdx, String baseType, boolean taintSubFields, GapDefinition gap,
 			Object userData) {
-		super(type, paramterIdx, baseType, null, null, gap, userData, false);
+		super(type, paramterIdx, baseType, null, gap, userData, false);
 		this.taintSubFields = taintSubFields;
 	}
 
-	public FlowSink(SourceSinkType type, String baseType, String[] accessPath, String[] accessPathTypes,
-			boolean taintSubFields2, boolean matchStrict) {
-		super(type, -1, baseType, accessPath, accessPathTypes, matchStrict);
-		this.taintSubFields = taintSubFields2 || (accessPath != null && accessPath.length > this.accessPath.length);
+	public FlowSink(SourceSinkType type, String baseType, AccessPathFragment accessPath, boolean taintSubFields2,
+			boolean matchStrict) {
+		super(type, -1, baseType, accessPath, matchStrict);
+		this.taintSubFields = taintSubFields2 || (accessPath != null && accessPath.length() > this.accessPath.length());
 	}
 
-	public FlowSink(SourceSinkType type, String baseType, String[] accessPath, String[] accessPathTypes,
-			boolean taintSubFields2, GapDefinition gap, boolean matchStrict) {
-		super(type, -1, baseType, accessPath, accessPathTypes, gap, matchStrict);
-		this.taintSubFields = taintSubFields2 || (accessPath != null && accessPath.length > this.accessPath.length);
+	public FlowSink(SourceSinkType type, String baseType, AccessPathFragment accessPath, boolean taintSubFields2,
+			GapDefinition gap, boolean matchStrict) {
+		super(type, -1, baseType, accessPath, gap, matchStrict);
+		this.taintSubFields = taintSubFields2 || (accessPath != null && accessPath.length() > this.accessPath.length());
 	}
 
 	public boolean taintSubFields() {
@@ -77,8 +77,7 @@ public class FlowSink extends AbstractFlowSinkSource implements Cloneable {
 	 * i.e., if all elements referenced by the given source or sink are also
 	 * referenced by this one
 	 * 
-	 * @param src
-	 *            The source or sink with which to compare the current one
+	 * @param src The source or sink with which to compare the current one
 	 * @return True if the current source or sink is coarser than the given one,
 	 *         otherwise false
 	 */
@@ -103,19 +102,20 @@ public class FlowSink extends AbstractFlowSinkSource implements Cloneable {
 
 		if (isParameter())
 			return gapString + "Parameter " + getParameterIndex()
-					+ (accessPath == null ? "" : " " + Arrays.toString(accessPath)) + " " + taintSubFields();
+					+ (accessPath == null ? "" : " " + AccessPathFragment.toString(accessPath)) + " "
+					+ taintSubFields();
 
 		if (isField())
-			return gapString + "Field" + (accessPath == null ? "" : " " + Arrays.toString(accessPath)) + " "
+			return gapString + "Field" + (accessPath == null ? "" : " " + AccessPathFragment.toString(accessPath)) + " "
 					+ taintSubFields();
 
 		if (isReturn())
-			return gapString + "Return" + (accessPath == null ? "" : " " + Arrays.toString(accessPath)) + " "
-					+ taintSubFields();
+			return gapString + "Return" + (accessPath == null ? "" : " " + AccessPathFragment.toString(accessPath))
+					+ " " + taintSubFields();
 
 		if (isCustom())
 			return "CUSTOM " + gapString + "Parameter " + getParameterIndex()
-					+ (accessPath == null ? "" : " " + Arrays.toString(accessPath));
+					+ (accessPath == null ? "" : " " + AccessPathFragment.toString(accessPath));
 
 		return "invalid sink";
 	}
@@ -136,14 +136,16 @@ public class FlowSink extends AbstractFlowSinkSource implements Cloneable {
 	/**
 	 * Validates this flow sink
 	 * 
-	 * @param methodName
-	 *            The name of the containing method. This will be used to give more
-	 *            context in exception messages
+	 * @param methodName The name of the containing method. This will be used to
+	 *                   give more context in exception messages
 	 */
 	public void validate(String methodName) {
 		if (getType() == SourceSinkType.GapBaseObject && getGap() == null)
-			throw new RuntimeException(
-					"Gap base flows must always be linked " + "with gaps. Offending method: " + methodName);
+			throw new InvalidFlowSpecificationException(
+					"Gap base flows must always be linked with gaps. Offending method: " + methodName, this);
+
+		if (getType() == SourceSinkType.Parameter && getGap() == null)
+			throw new InvalidFlowSpecificationException("Parameters may only be sinks when referencing gaps", this);
 	}
 
 	@Override
@@ -153,14 +155,12 @@ public class FlowSink extends AbstractFlowSinkSource implements Cloneable {
 		GapDefinition newGap = replacementMap.get(gap.getID());
 		if (newGap == null)
 			return this;
-		return new FlowSink(type, parameterIdx, baseType, accessPath, accessPathTypes, taintSubFields, newGap,
-				matchStrict);
+		return new FlowSink(type, parameterIdx, baseType, accessPath, taintSubFields, newGap, matchStrict);
 	}
 
 	@Override
 	protected Object clone() throws CloneNotSupportedException {
-		return new FlowSink(type, parameterIdx, baseType, accessPath, accessPathTypes, taintSubFields, gap, userData,
-				matchStrict);
+		return new FlowSink(type, parameterIdx, baseType, accessPath, taintSubFields, gap, userData, matchStrict);
 	}
 
 }
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowSource.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowSource.java
index 76b5d49..db30f8b 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowSource.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/FlowSource.java
@@ -1,10 +1,10 @@
 package soot.jimple.infoflow.methodSummary.data.sourceSink;
 
-import java.util.Arrays;
 import java.util.Map;
 
 import soot.jimple.infoflow.methodSummary.data.summary.GapDefinition;
 import soot.jimple.infoflow.methodSummary.data.summary.SourceSinkType;
+import soot.jimple.infoflow.methodSummary.taintWrappers.AccessPathFragment;
 
 /**
  * Representation of a flow source
@@ -18,24 +18,24 @@ public class FlowSource extends AbstractFlowSinkSource implements Cloneable {
 	}
 
 	public FlowSource(SourceSinkType type, String baseType, GapDefinition gap) {
-		super(type, -1, baseType, null, null, gap, false);
+		super(type, -1, baseType, null, gap, null, false);
 	}
 
 	public FlowSource(SourceSinkType type, String baseType, GapDefinition gap, boolean matchStrict) {
-		super(type, -1, baseType, null, null, gap, matchStrict);
+		super(type, -1, baseType, null, gap, null, matchStrict);
 	}
 
-	public FlowSource(SourceSinkType type, String baseType, String[] fields, String[] fieldTypes) {
-		super(type, -1, baseType, fields, fieldTypes, false);
+	public FlowSource(SourceSinkType type, String baseType, AccessPathFragment accessPath) {
+		super(type, -1, baseType, accessPath, false);
 	}
 
-	public FlowSource(SourceSinkType type, String baseType, String[] fields, String[] fieldTypes, GapDefinition gap) {
-		super(type, -1, baseType, fields, fieldTypes, gap, false);
+	public FlowSource(SourceSinkType type, String baseType, AccessPathFragment accessPath, GapDefinition gap) {
+		super(type, -1, baseType, accessPath, gap, false);
 	}
 
-	public FlowSource(SourceSinkType type, String baseType, String[] fields, String[] fieldTypes, GapDefinition gap,
+	public FlowSource(SourceSinkType type, String baseType, AccessPathFragment accessPath, GapDefinition gap,
 			boolean matchStrict) {
-		super(type, -1, baseType, fields, fieldTypes, gap, matchStrict);
+		super(type, -1, baseType, accessPath, gap, matchStrict);
 	}
 
 	public FlowSource(SourceSinkType type, int parameterIdx, String baseType) {
@@ -43,26 +43,26 @@ public class FlowSource extends AbstractFlowSinkSource implements Cloneable {
 	}
 
 	public FlowSource(SourceSinkType type, int parameterIdx, String baseType, GapDefinition gap) {
-		super(type, parameterIdx, baseType, null, null, gap, false);
+		super(type, parameterIdx, baseType, null, gap, null, false);
 	}
 
-	public FlowSource(SourceSinkType type, int parameterIdx, String baseType, String[] fields, String[] fieldTypes) {
-		super(type, parameterIdx, baseType, fields, fieldTypes, false);
+	public FlowSource(SourceSinkType type, int parameterIdx, String baseType, AccessPathFragment accessPath) {
+		super(type, parameterIdx, baseType, accessPath, false);
 	}
 
-	public FlowSource(SourceSinkType type, int parameterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public FlowSource(SourceSinkType type, int parameterIdx, String baseType, AccessPathFragment accessPath,
 			GapDefinition gap) {
-		super(type, parameterIdx, baseType, fields, fieldTypes, gap, false);
+		super(type, parameterIdx, baseType, accessPath, gap, false);
 	}
 
-	public FlowSource(SourceSinkType type, int parameterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public FlowSource(SourceSinkType type, int parameterIdx, String baseType, AccessPathFragment accessPath,
 			GapDefinition gap, boolean matchStrict) {
-		super(type, parameterIdx, baseType, fields, fieldTypes, gap, matchStrict);
+		super(type, parameterIdx, baseType, accessPath, gap, matchStrict);
 	}
 
-	public FlowSource(SourceSinkType type, int parameterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public FlowSource(SourceSinkType type, int parameterIdx, String baseType, AccessPathFragment accessPath,
 			GapDefinition gap, Object userData, boolean matchStrict) {
-		super(type, parameterIdx, baseType, fields, fieldTypes, gap, userData, matchStrict);
+		super(type, parameterIdx, baseType, accessPath, gap, userData, matchStrict);
 	}
 
 	@Override
@@ -71,20 +71,21 @@ public class FlowSource extends AbstractFlowSinkSource implements Cloneable {
 
 		if (isParameter())
 			return gapString + "Parameter " + getParameterIndex()
-					+ (accessPath == null ? "" : " " + Arrays.toString(accessPath));
+					+ (accessPath == null ? "" : " " + AccessPathFragment.toString(accessPath));
 
 		if (isField())
-			return gapString + "Field" + (accessPath == null ? "" : " " + Arrays.toString(accessPath));
+			return gapString + "Field" + (accessPath == null ? "" : " " + AccessPathFragment.toString(accessPath));
 
 		if (isThis())
 			return "THIS";
 
 		if (isReturn() && gap != null)
-			return "Return value of gap " + gap.getSignature();
+			return "Return value of gap " + gap.getSignature()
+					+ (accessPath == null ? "" : " " + AccessPathFragment.toString(accessPath));
 
 		if (isCustom())
 			return "CUSTOM " + gapString + "Parameter " + getParameterIndex()
-					+ (accessPath == null ? "" : " " + Arrays.toString(accessPath));
+					+ (accessPath == null ? "" : " " + AccessPathFragment.toString(accessPath));
 
 		return "<unknown>";
 	}
@@ -92,13 +93,13 @@ public class FlowSource extends AbstractFlowSinkSource implements Cloneable {
 	/**
 	 * Validates this flow source
 	 * 
-	 * @param methodName
-	 *            The name of the containing method. This will be used to give more
-	 *            context in exception messages
+	 * @param methodName The name of the containing method. This will be used to
+	 *                   give more context in exception messages
 	 */
 	public void validate(String methodName) {
 		if (getType() == SourceSinkType.Return && getGap() == null)
-			throw new RuntimeException("Return values cannot be sources. " + "Offending method: " + methodName);
+			throw new InvalidFlowSpecificationException(
+					"Return values cannot be sources. Offending method: " + methodName, this);
 	}
 
 	@Override
@@ -108,12 +109,12 @@ public class FlowSource extends AbstractFlowSinkSource implements Cloneable {
 		GapDefinition newGap = replacementMap.get(gap.getID());
 		if (newGap == null)
 			return this;
-		return new FlowSource(type, parameterIdx, baseType, accessPath, accessPathTypes, newGap, matchStrict);
+		return new FlowSource(type, parameterIdx, baseType, accessPath, newGap, matchStrict);
 	}
 
 	@Override
 	protected Object clone() throws CloneNotSupportedException {
-		return new FlowSource(type, parameterIdx, baseType, accessPath, accessPathTypes, gap, userData, matchStrict);
+		return new FlowSource(type, parameterIdx, baseType, accessPath, gap, userData, matchStrict);
 	}
 
 }
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/InvalidFlowSpecificationException.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/InvalidFlowSpecificationException.java
new file mode 100644
index 0000000..59e7183
--- /dev/null
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/sourceSink/InvalidFlowSpecificationException.java
@@ -0,0 +1,25 @@
+package soot.jimple.infoflow.methodSummary.data.sourceSink;
+
+/**
+ * Exception that is thrown when a source or sink specification inside a summary
+ * flow is invalid
+ * 
+ * @author Steven Arzt
+ *
+ */
+public class InvalidFlowSpecificationException extends RuntimeException {
+
+	private static final long serialVersionUID = -6548286243034212560L;
+
+	private final AbstractFlowSinkSource sinkSource;
+
+	public InvalidFlowSpecificationException(String message, AbstractFlowSinkSource sinkSource) {
+		super(message);
+		this.sinkSource = sinkSource;
+	}
+
+	public AbstractFlowSinkSource getSinkSource() {
+		return sinkSource;
+	}
+
+}
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/ClassMethodSummaries.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/ClassMethodSummaries.java
index 243cd26..4ab9c14 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/ClassMethodSummaries.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/ClassMethodSummaries.java
@@ -15,6 +15,7 @@ public class ClassMethodSummaries {
 	private final MethodSummaries methodSummaries;
 	private final Set<String> interfaces = new HashSet<>();
 	private String superClass;
+	private Boolean isInterface = null;
 
 	private boolean isExclusiveForClass = true;
 
@@ -43,7 +44,8 @@ public class ClassMethodSummaries {
 	 *         class, false otherwise
 	 */
 	public boolean isEmpty() {
-		return (methodSummaries == null || methodSummaries.isEmpty()) && !hasInterfaces();
+		return (methodSummaries == null || methodSummaries.isEmpty()) && !hasInterfaces() && !hasSuperclass()
+				&& isInterface == null;
 	}
 
 	/**
@@ -102,15 +104,28 @@ public class ClassMethodSummaries {
 			throw new RuntimeException("Class name mismatch");
 		if (otherClassName != null && !otherClassName.equals(this.className))
 			throw new RuntimeException("Class name mismatch");
+		if (hasSuperclass() && methodFlows.hasSuperclass()) {
+			if (!superClass.equals(methodFlows.getSuperClass()))
+				throw new RuntimeException("Class name mismatch");
+		}
 
-		// Merge the summaries
 		boolean hasNewData = false;
+		if (methodFlows.hasSuperclass() && !hasSuperclass()) {
+			setSuperClass(methodFlows.getSuperClass());
+			hasNewData = true;
+		}
+
+		// Merge the summaries
 		if (this.methodSummaries.merge(methodFlows.getMethodSummaries()))
 			hasNewData = true;
 
 		if (methodFlows.hasInterfaces())
 			if (this.interfaces.addAll(methodFlows.getInterfaces()))
 				hasNewData = true;
+
+		if (isInterface == null && methodFlows.isInterface != null)
+			this.isInterface = methodFlows.isInterface;
+
 		return hasNewData;
 	}
 
@@ -196,6 +211,16 @@ public class ClassMethodSummaries {
 		return interfaces != null && !interfaces.isEmpty();
 	}
 
+	/**
+	 * Gets whether this summary object contains a reference to the superclass of
+	 * the target class
+	 * 
+	 * @return True if we know the superclass of the target class, false otherwise
+	 */
+	public boolean hasSuperclass() {
+		return superClass != null && !superClass.isEmpty();
+	}
+
 	@Override
 	public String toString() {
 		return String.format("Summaries for %s", className);
@@ -219,6 +244,36 @@ public class ClassMethodSummaries {
 		this.superClass = superClass;
 	}
 
+	/**
+	 * Gets whether this summary models an interface
+	 * 
+	 * @return True if this summary models an interface, false if it models a normal
+	 *         class
+	 */
+	public boolean isInterface() {
+		return isInterface != null && isInterface.booleanValue();
+	}
+
+	/**
+	 * Gets whether this summary holds information about whether the target class is
+	 * an interface or not
+	 * 
+	 * @return True if interface status data is available, false otherwise
+	 */
+	public boolean hasInterfaceInfo() {
+		return isInterface != null;
+	}
+
+	/**
+	 * Sets whether this summary models an interface
+	 * 
+	 * @param isInterface True if this summary models an interface, false if it
+	 *                    models a normal class
+	 */
+	public void setInterface(boolean isInterface) {
+		this.isInterface = isInterface;
+	}
+
 	@Override
 	public int hashCode() {
 		final int prime = 31;
@@ -226,6 +281,7 @@ public class ClassMethodSummaries {
 		result = prime * result + ((className == null) ? 0 : className.hashCode());
 		result = prime * result + ((interfaces == null) ? 0 : interfaces.hashCode());
 		result = prime * result + (isExclusiveForClass ? 1231 : 1237);
+		result = prime * result + ((isInterface == null) ? 0 : isInterface.hashCode());
 		result = prime * result + ((methodSummaries == null) ? 0 : methodSummaries.hashCode());
 		result = prime * result + ((superClass == null) ? 0 : superClass.hashCode());
 		return result;
@@ -252,6 +308,11 @@ public class ClassMethodSummaries {
 			return false;
 		if (isExclusiveForClass != other.isExclusiveForClass)
 			return false;
+		if (isInterface == null) {
+			if (other.isInterface != null)
+				return false;
+		} else if (!isInterface.equals(other.isInterface))
+			return false;
 		if (methodSummaries == null) {
 			if (other.methodSummaries != null)
 				return false;
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/ClassSummaries.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/ClassSummaries.java
index 35c6d70..287e043 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/ClassSummaries.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/ClassSummaries.java
@@ -37,6 +37,16 @@ public class ClassSummaries {
 		return summaries.get(className);
 	}
 
+	/**
+	 * Gets or creates a summary object for the given class
+	 * 
+	 * @param className The name of the class for which to get a summary object
+	 * @return The summary object for the class with the given name
+	 */
+	public ClassMethodSummaries getOrCreateClassSummaries(String className) {
+		return summaries.computeIfAbsent(className, n -> new ClassMethodSummaries(className));
+	}
+
 	/**
 	 * Gets the flow summaries for the methods in the given class
 	 * 
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/MethodFlow.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/MethodFlow.java
index 6c02952..3d80a7f 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/MethodFlow.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/MethodFlow.java
@@ -20,8 +20,8 @@ public class MethodFlow extends AbstractMethodSummary {
 	private final FlowSource from;
 	private final FlowSink to;
 	private final boolean isAlias;
-	private final boolean typeChecking;
-	private final boolean cutSubFields;
+	private final Boolean typeChecking;
+	private final Boolean cutSubFields;
 
 	/**
 	 * Creates a new instance of the MethodFlow class
@@ -38,8 +38,8 @@ public class MethodFlow extends AbstractMethodSummary {
 	 *                     field "b" will not appended to the sink if this option is
 	 *                     enabled.
 	 */
-	public MethodFlow(String methodSig, FlowSource from, FlowSink to, boolean isAlias, boolean typeChecking,
-			boolean cutSubFields) {
+	public MethodFlow(String methodSig, FlowSource from, FlowSink to, boolean isAlias, Boolean typeChecking,
+			Boolean cutSubFields) {
 		super(methodSig);
 		this.from = from;
 		this.to = to;
@@ -102,9 +102,9 @@ public class MethodFlow extends AbstractMethodSummary {
 		}
 
 		FlowSource reverseSource = new FlowSource(fromType, to.getParameterIndex(), to.getBaseType(),
-				to.getAccessPath(), to.getAccessPathTypes(), to.getGap(), to.isMatchStrict());
+				to.getAccessPath(), to.getGap(), to.isMatchStrict());
 		FlowSink reverseSink = new FlowSink(toType, from.getParameterIndex(), from.getBaseType(), from.getAccessPath(),
-				from.getAccessPathTypes(), taintSubFields, from.getGap(), from.isMatchStrict());
+				taintSubFields, from.getGap(), from.isMatchStrict());
 		return new MethodFlow(methodSig, reverseSource, reverseSink, isAlias, typeChecking, cutSubFields);
 	}
 
@@ -124,7 +124,7 @@ public class MethodFlow extends AbstractMethodSummary {
 	 * @return True if type checking shall be performed before applying this method
 	 *         flow, otherwise false
 	 */
-	public boolean getTypeChecking() {
+	public Boolean getTypeChecking() {
 		return this.typeChecking;
 	}
 
@@ -136,7 +136,7 @@ public class MethodFlow extends AbstractMethodSummary {
 	 * @return True if sub fields shall be discarded and shall not be appended to
 	 *         the sink
 	 */
-	public boolean getCutSubFields() {
+	public Boolean getCutSubFields() {
 		return cutSubFields;
 	}
 
@@ -195,7 +195,10 @@ public class MethodFlow extends AbstractMethodSummary {
 		if (getClass() != obj.getClass())
 			return false;
 		MethodFlow other = (MethodFlow) obj;
-		if (cutSubFields != other.cutSubFields)
+		if (cutSubFields == null) {
+			if (other.cutSubFields != null)
+				return false;
+		} else if (!cutSubFields.equals(other.cutSubFields))
 			return false;
 		if (from == null) {
 			if (other.from != null)
@@ -209,7 +212,10 @@ public class MethodFlow extends AbstractMethodSummary {
 				return false;
 		} else if (!to.equals(other.to))
 			return false;
-		if (typeChecking != other.typeChecking)
+		if (typeChecking == null) {
+			if (other.typeChecking != null)
+				return false;
+		} else if (!typeChecking.equals(other.typeChecking))
 			return false;
 		return true;
 	}
@@ -218,11 +224,11 @@ public class MethodFlow extends AbstractMethodSummary {
 	public int hashCode() {
 		final int prime = 31;
 		int result = super.hashCode();
-		result = prime * result + (cutSubFields ? 1231 : 1237);
+		result = prime * result + ((cutSubFields == null) ? 0 : cutSubFields.hashCode());
 		result = prime * result + ((from == null) ? 0 : from.hashCode());
 		result = prime * result + (isAlias ? 1231 : 1237);
 		result = prime * result + ((to == null) ? 0 : to.hashCode());
-		result = prime * result + (typeChecking ? 1231 : 1237);
+		result = prime * result + ((typeChecking == null) ? 0 : typeChecking.hashCode());
 		return result;
 	}
 
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/MethodSummaries.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/MethodSummaries.java
index 790ea67..a6eb6fb 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/MethodSummaries.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/MethodSummaries.java
@@ -28,6 +28,7 @@ public class MethodSummaries implements Iterable<MethodFlow> {
 	private volatile MultiMap<String, MethodFlow> flows;
 	private volatile MultiMap<String, MethodClear> clears;
 	private volatile Map<Integer, GapDefinition> gaps;
+	private volatile Set<String> excludedMethods;
 
 	public MethodSummaries() {
 		this(new ConcurrentHashMultiMap<String, MethodFlow>());
@@ -679,11 +680,35 @@ public class MethodSummaries implements Iterable<MethodFlow> {
 		return new MethodSummaries(reversedFlows, clears, gaps);
 	}
 
+	/**
+	 * Adds a method to exclude in the taint wrapper
+	 * 
+	 * @param methodSignature The subsignature of the method to ignore
+	 */
+	public void addExcludedMethod(String methodSignature) {
+		if (excludedMethods == null)
+			excludedMethods = new HashSet<>();
+		excludedMethods.add(methodSignature);
+	}
+
+	/**
+	 * Gets whether the method with the given subsignature has been excluded from
+	 * the data flow analysis
+	 * 
+	 * @param subsignature The subsignature
+	 * @return True if the method with the given subsignature has been excluded,
+	 *         false otherwise
+	 */
+	public boolean isExcluded(String subsignature) {
+		return excludedMethods != null && excludedMethods.contains(subsignature);
+	}
+
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ((clears == null) ? 0 : clears.hashCode());
+		result = prime * result + ((excludedMethods == null) ? 0 : excludedMethods.hashCode());
 		result = prime * result + ((flows == null) ? 0 : flows.hashCode());
 		result = prime * result + ((gaps == null) ? 0 : gaps.hashCode());
 		return result;
@@ -703,6 +728,11 @@ public class MethodSummaries implements Iterable<MethodFlow> {
 				return false;
 		} else if (!clears.equals(other.clears))
 			return false;
+		if (excludedMethods == null) {
+			if (other.excludedMethods != null)
+				return false;
+		} else if (!excludedMethods.equals(other.excludedMethods))
+			return false;
 		if (flows == null) {
 			if (other.flows != null)
 				return false;
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/SummaryMetaData.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/SummaryMetaData.java
index cab6efd..f1496a3 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/SummaryMetaData.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/data/summary/SummaryMetaData.java
@@ -1,6 +1,8 @@
 package soot.jimple.infoflow.methodSummary.data.summary;
 
+import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
 
 /**
@@ -13,6 +15,7 @@ public class SummaryMetaData {
 
 	private final Set<String> exclusiveClasses = new HashSet<>();
 	private final Set<String> exclusivePackages = new HashSet<>();
+	private final Map<String, String> classToSuperclass = new HashMap<>();
 
 	public SummaryMetaData() {
 		//
@@ -88,6 +91,39 @@ public class SummaryMetaData {
 		return false;
 	}
 
+	/**
+	 * Sets the superclass for the given class
+	 * 
+	 * @param name       The name of the class
+	 * @param superclass The name of the superclass
+	 */
+	public void setSuperclass(String name, String superclass) {
+		classToSuperclass.put(name, superclass);
+	}
+
+	/**
+	 * Gets the name of the superclass of the given class
+	 * 
+	 * @param name The class name
+	 * @return The name of the superclass of the given class
+	 */
+	public String getSuperclass(String name) {
+		return classToSuperclass.get(name);
+	}
+
+	/**
+	 * Merges this hierarchy data into the given summaries object
+	 * 
+	 * @param summaries The summaries into which to merge the hierarchy data
+	 */
+	public void mergeHierarchyData(ClassSummaries summaries) {
+		for (String className : classToSuperclass.keySet()) {
+			ClassMethodSummaries clazzSummaries = summaries.getOrCreateClassSummaries(className);
+			if (!clazzSummaries.hasSuperclass())
+				clazzSummaries.setSuperClass(classToSuperclass.get(className));
+		}
+	}
+
 	@Override
 	public int hashCode() {
 		final int prime = 31;
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryGenerator.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryGenerator.java
index ee94239..4798704 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryGenerator.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryGenerator.java
@@ -45,6 +45,7 @@ import soot.jimple.infoflow.methodSummary.handler.SummaryTaintPropagationHandler
 import soot.jimple.infoflow.methodSummary.postProcessor.InfoflowResultPostProcessor;
 import soot.jimple.infoflow.methodSummary.postProcessor.SummaryFlowCompactor;
 import soot.jimple.infoflow.methodSummary.source.SummarySourceSinkManager;
+import soot.jimple.infoflow.methodSummary.taintWrappers.AccessPathFragment;
 import soot.jimple.infoflow.methodSummary.taintWrappers.SummaryTaintWrapper;
 import soot.jimple.infoflow.methodSummary.taintWrappers.TaintWrapperFactory;
 import soot.jimple.infoflow.nativeCallHandler.INativeCallHandler;
@@ -73,9 +74,21 @@ public class SummaryGenerator {
 	protected List<String> substitutedWith = new LinkedList<String>();
 
 	protected SummaryTaintWrapper fallbackWrapper;
+	protected boolean fallbackWrapperInitialized = false;
 	protected MemorySummaryProvider onFlySummaryProvider = null;
 
 	public SummaryGenerator() {
+		//
+	}
+
+	/**
+	 * Initializes the fallback taint wrapper
+	 */
+	private void initializeFallbackWrapper() {
+		if (fallbackWrapperInitialized)
+			return;
+		fallbackWrapperInitialized = true;
+
 		try {
 			// Do we want to integrate summaries on the fly?
 			List<IMethodSummaryProvider> innerProviders = new ArrayList<>();
@@ -93,7 +106,8 @@ public class SummaryGenerator {
 			}
 
 			// Load the normal JDK summaries
-			innerProviders.add(new EagerSummaryProvider(TaintWrapperFactory.DEFAULT_SUMMARY_DIR));
+			if (config.isUseDefaultSummaries())
+				innerProviders.add(new EagerSummaryProvider(TaintWrapperFactory.DEFAULT_SUMMARY_DIR));
 
 			// Combine our summary providers
 			IMethodSummaryProvider provider = new MergingSummaryProvider(innerProviders);
@@ -104,6 +118,16 @@ public class SummaryGenerator {
 		}
 	}
 
+	/**
+	 * Releases all pre-existing summary information that is used when constructing
+	 * new summaries. Call this method after changing pre-existing summary files on
+	 * disk.
+	 */
+	public void releaseFallbackTaintWrapper() {
+		this.fallbackWrapper = null;
+		this.fallbackWrapperInitialized = false;
+	}
+
 	/**
 	 * Generates the summaries for the given set of classes
 	 * 
@@ -482,18 +506,26 @@ public class SummaryGenerator {
 	 */
 	private void calculateDependencies(ClassSummaries summaries) {
 		for (MethodFlow flow : summaries.getAllFlows()) {
-			if (flow.source().hasAccessPath())
-				for (String apElement : flow.source().getAccessPath()) {
-					String className = getTypeFromFieldDef(apElement);
-					if (!summaries.hasSummariesForClass(className))
-						summaries.addDependency(className);
+			if (flow.source().hasAccessPath()) {
+				final AccessPathFragment sourceAP = flow.source().getAccessPath();
+				if (!sourceAP.isEmpty()) {
+					for (String apElement : sourceAP.getFields()) {
+						String className = getTypeFromFieldDef(apElement);
+						if (!summaries.hasSummariesForClass(className))
+							summaries.addDependency(className);
+					}
 				}
-			if (flow.sink().hasAccessPath())
-				for (String apElement : flow.sink().getAccessPath()) {
-					String className = getTypeFromFieldDef(apElement);
-					if (!summaries.hasSummariesForClass(className))
-						summaries.addDependency(className);
+			}
+			if (flow.sink().hasAccessPath()) {
+				final AccessPathFragment sinkAP = flow.sink().getAccessPath();
+				if (!sinkAP.isEmpty()) {
+					for (String apElement : sinkAP.getFields()) {
+						String className = getTypeFromFieldDef(apElement);
+						if (!summaries.hasSummariesForClass(className))
+							summaries.addDependency(className);
+					}
 				}
+			}
 		}
 	}
 
@@ -572,6 +604,10 @@ public class SummaryGenerator {
 	 */
 	private MethodSummaries createMethodSummary(String classpath, final String methodSig, final String parentClass,
 			final GapManager gapManager, final ResultsAvailableHandler resultHandler) {
+		// We need to construct a fallback taint wrapper based on the current
+		// configuration
+		initializeFallbackWrapper();
+
 		logger.info(String.format("Computing method summary for %s...", methodSig));
 		long nanosBeforeMethod = System.nanoTime();
 
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryGeneratorConfiguration.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryGeneratorConfiguration.java
index b0c4df0..0c36fc0 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryGeneratorConfiguration.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryGeneratorConfiguration.java
@@ -23,6 +23,7 @@ public class SummaryGeneratorConfiguration extends InfoflowConfiguration {
 
 	protected boolean applySummariesOnTheFly = true;
 	protected Set<String> additionalSummaryDirectories;
+	protected boolean useDefaultSummaries = true;
 
 	protected long classSummaryTimeout = -1;
 	private int repeatCount = 1;
@@ -65,6 +66,7 @@ public class SummaryGeneratorConfiguration extends InfoflowConfiguration {
 			this.validateResults = summaryConfig.validateResults;
 			this.repeatCount = summaryConfig.repeatCount;
 			this.applySummariesOnTheFly = summaryConfig.applySummariesOnTheFly;
+			this.useDefaultSummaries = summaryConfig.useDefaultSummaries;
 
 			{
 				Set<String> otherAdditionalDirs = summaryConfig.additionalSummaryDirectories;
@@ -240,6 +242,33 @@ public class SummaryGeneratorConfiguration extends InfoflowConfiguration {
 		return additionalSummaryDirectories;
 	}
 
+	/**
+	 * Sets whether the default summaries shall be applied while generating more
+	 * summaries
+	 * 
+	 * @param useDefaultSummaries True to use the default summaries for the JDK and
+	 *                            well-known libraries when generating new
+	 *                            summaries, false to only rely on the
+	 *                            implementation (and potentially user-defined
+	 *                            additional summary directories)
+	 */
+	public void setUseDefaultSummaries(boolean useDefaultSummaries) {
+		this.useDefaultSummaries = useDefaultSummaries;
+	}
+
+	/**
+	 * Gets whether the default summaries shall be applied while generating more
+	 * summaries
+	 * 
+	 * @return True to use the default summaries for the JDK and well-known
+	 *         libraries when generating new summaries, false to only rely on the
+	 *         implementation (and potentially user-defined additional summary
+	 *         directories)
+	 */
+	public boolean isUseDefaultSummaries() {
+		return useDefaultSummaries;
+	}
+
 	/**
 	 * Adds an additional directory in which the summary generator shall look for
 	 * existing summaries to speed up the generation of new ones
@@ -288,6 +317,7 @@ public class SummaryGeneratorConfiguration extends InfoflowConfiguration {
 		result = prime * result + (loadFullJAR ? 1231 : 1237);
 		result = prime * result + repeatCount;
 		result = prime * result + (summarizeHashCodeEquals ? 1231 : 1237);
+		result = prime * result + (useDefaultSummaries ? 1231 : 1237);
 		result = prime * result + (validateResults ? 1231 : 1237);
 		return result;
 	}
@@ -326,6 +356,8 @@ public class SummaryGeneratorConfiguration extends InfoflowConfiguration {
 			return false;
 		if (summarizeHashCodeEquals != other.summarizeHashCodeEquals)
 			return false;
+		if (useDefaultSummaries != other.useDefaultSummaries)
+			return false;
 		if (validateResults != other.validateResults)
 			return false;
 		return true;
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryInfoflow.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryInfoflow.java
index 3580e90..11a8a84 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryInfoflow.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/generator/SummaryInfoflow.java
@@ -4,6 +4,7 @@ import java.util.Collection;
 
 import soot.jimple.infoflow.Infoflow;
 import soot.jimple.infoflow.InfoflowManager;
+import soot.jimple.infoflow.solver.IInfoflowSolver;
 import soot.options.Options;
 
 /**
@@ -33,7 +34,7 @@ public class SummaryInfoflow extends Infoflow {
 	}
 
 	@Override
-	protected void onTaintPropagationCompleted() {
+	protected void onTaintPropagationCompleted(IInfoflowSolver forwardSolver, IInfoflowSolver backwardSolver) {
 		cachedManager = this.manager;
 	}
 
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/InfoflowResultPostProcessor.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/InfoflowResultPostProcessor.java
index b52a351..9b606a7 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/InfoflowResultPostProcessor.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/InfoflowResultPostProcessor.java
@@ -33,6 +33,7 @@ import soot.jimple.infoflow.methodSummary.generator.GapManager;
 import soot.jimple.infoflow.methodSummary.generator.SummaryGeneratorConfiguration;
 import soot.jimple.infoflow.methodSummary.postProcessor.SummaryPathBuilder.SummaryResultInfo;
 import soot.jimple.infoflow.methodSummary.postProcessor.SummaryPathBuilder.SummarySourceInfo;
+import soot.jimple.infoflow.methodSummary.taintWrappers.AccessPathFragment;
 import soot.jimple.infoflow.methodSummary.util.AliasUtils;
 import soot.jimple.infoflow.solver.executors.InterruptableExecutor;
 import soot.jimple.infoflow.util.SootMethodRepresentationParser;
@@ -177,12 +178,9 @@ public class InfoflowResultPostProcessor {
 							if (sourceAP == null || sinkAP == null)
 								throw new RuntimeException("Invalid access path");
 
-							// We only take flows which are not identity flows.
-							// If we have a flow from a gap parameter to the
-							// original
-							// method parameter, the access paths are equal, but
-							// that's
-							// ok in the case of aliasing.
+							// We only take flows which are not identity flows. If we have a flow from a gap
+							// parameter to the original method parameter, the access paths are equal, but
+							// that's ok in the case of aliasing.
 							boolean isAliasedField = gapManager.getGapForCall(sourceStmt) != null
 									&& isAliasedField(sinkAP, sourceAP, sourceStmt) && si.getSourceInfo().getIsAlias();
 							if (!sinkAP.equals(sourceAP) || isAliasedField) {
@@ -427,11 +425,13 @@ public class InfoflowResultPostProcessor {
 			return false;
 
 		// Compare the access paths
-		if (sink.getAccessPath() != null) {
-			if (sink.getAccessPath().length != source.getAccessPath().length)
+		final AccessPathFragment sinkAccessPath = sink.getAccessPath();
+		final AccessPathFragment sourceAccessPath = source.getAccessPath();
+		if (sinkAccessPath != null && sourceAccessPath != null) {
+			if (sinkAccessPath.length() != sourceAccessPath.length())
 				return false;
-			for (int i = 0; i < sink.getAccessPath().length; i++) {
-				if (!source.getAccessPath()[i].equals(sink.getAccessPath()[i]))
+			for (int i = 0; i < sink.getAccessPath().length(); i++) {
+				if (!sourceAccessPath.getField(i).equals(sinkAccessPath.getField(i)))
 					return false;
 			}
 		}
@@ -466,6 +466,9 @@ public class InfoflowResultPostProcessor {
 			System.out.println("source: " + source.toString());
 			System.out.println("sink  : " + sink.toString());
 			System.out.println("alias : " + isAlias);
+			GapDefinition gap = sink.getGap();
+			if (gap != null)
+				System.out.println("gap : " + gap.getSignature());
 
 			System.out.println("------------------------------------");
 		}
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummaryFlowCompactor.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummaryFlowCompactor.java
index ef64d4f..10a8a94 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummaryFlowCompactor.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummaryFlowCompactor.java
@@ -11,6 +11,7 @@ import org.slf4j.LoggerFactory;
 import soot.jimple.infoflow.methodSummary.data.summary.GapDefinition;
 import soot.jimple.infoflow.methodSummary.data.summary.MethodFlow;
 import soot.jimple.infoflow.methodSummary.data.summary.MethodSummaries;
+import soot.jimple.infoflow.methodSummary.taintWrappers.AccessPathFragment;
 
 /**
  * Class for compacting a set of method flow summaries
@@ -135,6 +136,25 @@ public class SummaryFlowCompactor {
 		}
 	}
 
+	/**
+	 * Compares two access paths to create some sort of ordering. This is important
+	 * to get reproducible test cases for those flows that can be represented
+	 * ambiguously.
+	 * 
+	 * @param accessPath  The first access path
+	 * @param accessPath2 The second access path
+	 * @return An ordering (-1, 0, 1) on the given access paths
+	 */
+	private int compare(AccessPathFragment accessPath, AccessPathFragment accessPath2) {
+		if (accessPath == null && accessPath2 == null)
+			return 0;
+		if (accessPath == null)
+			return -1;
+		if (accessPath2 == null)
+			return 1;
+		return compare(accessPath.getFields(), accessPath2.getFields());
+	}
+
 	/**
 	 * Compares two access paths to create some sort of ordering. This is important
 	 * to get reproducible test cases for those flows that can be represented
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummaryPathBuilder.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummaryPathBuilder.java
index d3f3405..52d082f 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummaryPathBuilder.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummaryPathBuilder.java
@@ -45,6 +45,12 @@ class SummaryPathBuilder extends ContextSensitivePathBuilder {
 		private final boolean isAlias;
 		private final boolean isInCallee;
 
+		public SummarySourceInfo() {
+			this.sourceAP = null;
+			this.isAlias = false;
+			this.isInCallee = false;
+		}
+
 		public SummarySourceInfo(AccessPath source, Stmt context, Object userData, AccessPath sourceAP, boolean isAlias,
 				boolean isInCallee) {
 			super(null, source, context, userData, null, null);
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummarySourceContextAndPath.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummarySourceContextAndPath.java
index eeb1c92..fd649cd 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummarySourceContextAndPath.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/postProcessor/SummarySourceContextAndPath.java
@@ -196,12 +196,14 @@ class SummarySourceContextAndPath extends SourceContextAndPath {
 
 			// Match the access path from the caller back into the callee
 			for (SootMethod callee : curCallees) {
-				AccessPath newAP = mapAccessPathBackIntoCaller(scap.curAP, stmt, callee);
-				if (newAP != null) {
-					scap.curAP = newAP;
-					scap.depth--;
-					matched = true;
-					break;
+				if (callee.isConcrete()) {
+					AccessPath newAP = mapAccessPathBackIntoCaller(scap.curAP, stmt, callee);
+					if (newAP != null) {
+						scap.curAP = newAP;
+						scap.depth--;
+						matched = true;
+						break;
+					}
 				}
 			}
 
@@ -457,7 +459,7 @@ class SummarySourceContextAndPath extends SourceContextAndPath {
 		// Make sure that we don't end up with a senseless callee
 		if (!callee.getSubSignature().equals(stmt.getInvokeExpr().getMethod().getSubSignature())
 				&& !isThreadCall(stmt.getInvokeExpr().getMethod(), callee)) {
-			System.out.println(String.format("WARNING: Invalid callee on stack. Caller was %s, callee was %s",
+			logger.warn(String.format("Invalid callee on stack. Caller was %s, callee was %s",
 					stmt.getInvokeExpr().getMethod().getSubSignature(), callee));
 			return null;
 		}
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/AccessPathFragment.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/AccessPathFragment.java
new file mode 100644
index 0000000..563be08
--- /dev/null
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/AccessPathFragment.java
@@ -0,0 +1,279 @@
+package soot.jimple.infoflow.methodSummary.taintWrappers;
+
+import java.util.Arrays;
+
+import soot.SootField;
+import soot.Type;
+import soot.jimple.infoflow.data.AccessPath;
+
+/**
+ * A portion of an access path
+ * 
+ * @author Steven Arzt
+ *
+ */
+public class AccessPathFragment {
+
+	private final String[] fields;
+	private final String[] fieldTypes;
+
+	/**
+	 * Creates a new instance of the {@link AccessPathFragment} class
+	 * 
+	 * @param fields     The names of the fields in this fragment of an access path
+	 * @param fieldTypes The types of the given fields
+	 */
+	public AccessPathFragment(String[] fields, String[] fieldTypes) {
+		this.fields = fields;
+		this.fieldTypes = fieldTypes;
+
+		// Sanity check
+		if (fields != null && fieldTypes != null && fields.length != fieldTypes.length)
+			throw new RuntimeException("Access path array and type array must be of equal length");
+	}
+
+	/**
+	 * Creates a new instance of the {@link AccessPathFragment} class
+	 * 
+	 * @param fields     The fields in this fragment of an access path
+	 * @param fieldTypes The types of the given fields
+	 */
+	public AccessPathFragment(SootField[] fields, Type[] fieldTypes) {
+		this(fieldArrayToStringArray(fields), typeArrayToStringArray(fieldTypes));
+	}
+
+	/**
+	 * Creates a new instance of the {@link AccessPathFragment} class based on an
+	 * existing access path
+	 * 
+	 * @param accessPath The original access path
+	 */
+	public AccessPathFragment(AccessPath accessPath) {
+		this(accessPath.getFields(), accessPath.getFieldTypes());
+	}
+
+	/**
+	 * Converts an array of SootFields to an array of strings
+	 * 
+	 * @param fields The array of SootFields to convert
+	 * @return The array of strings corresponding to the given array of SootFields
+	 */
+	private static String[] fieldArrayToStringArray(SootField[] fields) {
+		if (fields == null)
+			return null;
+		String[] stringFields = new String[fields.length];
+		for (int i = 0; i < fields.length; i++)
+			stringFields[i] = fields[i].toString();
+		return stringFields;
+	}
+
+	/**
+	 * Converts an array of Soot Types to an array of strings
+	 * 
+	 * @param fields The array of Soot Types to convert
+	 * @return The array of strings corresponding to the given array of Soot Types
+	 */
+	private static String[] typeArrayToStringArray(Type[] types) {
+		if (types == null)
+			return null;
+		String[] stringTypes = new String[types.length];
+		for (int i = 0; i < types.length; i++)
+			stringTypes[i] = types[i].toString();
+		return stringTypes;
+	}
+
+	/**
+	 * Gets the number of fields in this access path fragments
+	 * 
+	 * @return The length of this access path fragments
+	 */
+	public int length() {
+		return fields == null ? 0 : fields.length;
+	}
+
+	/**
+	 * Gets the names of the fields in this access path fragment
+	 * 
+	 * @return The names of the fields in this access path fragment
+	 */
+	public String[] getFields() {
+		return fields;
+	}
+
+	/**
+	 * Gets the types of the fields in this access path fragment
+	 * 
+	 * @return The types of the fields in this access path fragment
+	 */
+	public String[] getFieldTypes() {
+		return fieldTypes;
+	}
+
+	/**
+	 * Gets the name of the last field in this access path fragment
+	 * 
+	 * @return The name of the last field in this access path fragment
+	 */
+	public String getLastFieldName() {
+		if (fields == null || fields.length == 0)
+			return null;
+		return fields[fields.length - 1];
+	}
+
+	/**
+	 * Gets the type of the last field in this access path fragment
+	 * 
+	 * @return The type of the last field in this access path fragment
+	 */
+	public String getLastFieldType() {
+		if (fieldTypes == null || fieldTypes.length == 0)
+			return null;
+		return fieldTypes[fieldTypes.length - 1];
+	}
+
+	/**
+	 * Gets whether this access path fragment is empty
+	 * 
+	 * @return true if this access path fragment is empty, false otherwise
+	 */
+	public boolean isEmpty() {
+		return this.fields == null || this.fields.length == 0;
+	}
+
+	/**
+	 * Append the given access path fragment to this one
+	 * 
+	 * @param toAppend The access path fragment to append to this one
+	 * @return The concatenated access path fragment containing all elements from
+	 *         this fragment followed by those from the given fragment
+	 */
+	public AccessPathFragment append(AccessPathFragment toAppend) {
+		// If only one of the two operands contains actual data, we simply take that
+		// object and don't need to append anything
+		if (toAppend == null || toAppend.isEmpty()) {
+			if (this.isEmpty())
+				return null;
+			return this;
+		}
+		if (this.isEmpty())
+			return toAppend;
+
+		String[] toAppendFields = toAppend.getFields();
+		String[] toAppendFieldTypes = toAppend.getFieldTypes();
+
+		String[] appendedFields = new String[fields.length + toAppendFields.length];
+		System.arraycopy(fields, 0, appendedFields, 0, fields.length);
+		System.arraycopy(toAppendFields, 0, appendedFields, fields.length, toAppendFields.length);
+
+		String[] appendedTypes = new String[fieldTypes.length + toAppendFieldTypes.length];
+		System.arraycopy(fieldTypes, 0, appendedTypes, 0, fieldTypes.length);
+		System.arraycopy(toAppendFieldTypes, 0, appendedTypes, fieldTypes.length, toAppendFieldTypes.length);
+
+		return new AccessPathFragment(appendedFields, appendedTypes);
+	}
+
+	/**
+	 * Derives a new access path fragment by replacing the field type at the given
+	 * index with the given type
+	 * 
+	 * @param idx       The index at which to change the field type
+	 * @param fieldType The new field type
+	 * @return The new access path fragment with the updated field type
+	 */
+	public AccessPathFragment updateFieldType(int idx, String fieldType) {
+		String[] newFieldTypes = Arrays.copyOf(fieldTypes, fieldTypes.length);
+		newFieldTypes[idx] = fieldType;
+		return new AccessPathFragment(fields, newFieldTypes);
+	}
+
+	/**
+	 * Gets the name of the field at the given index
+	 * 
+	 * @param idx The field index
+	 * @return The name of the field at the given index
+	 */
+	public String getField(int idx) {
+		if (idx < 0 || idx >= fields.length)
+			return null;
+		return fields[idx];
+	}
+
+	/**
+	 * Gets the prefix of this access path with the given length
+	 * 
+	 * @param length The length to which this access path shall be cut
+	 * @return This access path cut to the given length
+	 */
+	public AccessPathFragment prefix(int length) {
+		if (length < 0)
+			return this;
+		if (length() <= length)
+			return this;
+
+		String[] newFields = new String[length];
+		String[] newFieldTypes = new String[length];
+
+		System.arraycopy(fields, 0, newFields, 0, length);
+		System.arraycopy(fieldTypes, 0, newFieldTypes, 0, length);
+		return new AccessPathFragment(newFields, newFieldTypes);
+	}
+
+	@Override
+	public String toString() {
+		return fields == null ? "<null>" : Arrays.toString(fields);
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + Arrays.hashCode(fieldTypes);
+		result = prime * result + Arrays.hashCode(fields);
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		AccessPathFragment other = (AccessPathFragment) obj;
+		if (!Arrays.equals(fieldTypes, other.fieldTypes))
+			return false;
+		if (!Arrays.equals(fields, other.fields))
+			return false;
+		return true;
+	}
+
+	/**
+	 * Obtains the string representation of the given access path fragment
+	 * 
+	 * @param accessPath The access path fragment for which to get the string
+	 *                   representation
+	 * @return The string representation of the given access path fragment
+	 */
+	public static String toString(AccessPathFragment accessPath) {
+		return accessPath.fields == null ? "" : Arrays.toString(accessPath.fields);
+	}
+
+	/**
+	 * Appends the given suffix to the given access path
+	 * 
+	 * @param accessPath The base access path, which will become the first part of
+	 *                   the result
+	 * @param suffix     The access path to append, which will become the second
+	 *                   part of the result
+	 * @return The concatenated access path
+	 */
+	public static AccessPathFragment append(AccessPathFragment accessPath, AccessPathFragment suffix) {
+		if (accessPath == null)
+			return suffix;
+		if (suffix == null)
+			return accessPath;
+		return accessPath.append(suffix);
+	}
+
+}
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/SummaryTaintWrapper.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/SummaryTaintWrapper.java
index 0a0d7e0..4b9442e 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/SummaryTaintWrapper.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/SummaryTaintWrapper.java
@@ -1,7 +1,6 @@
 package soot.jimple.infoflow.methodSummary.taintWrappers;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
@@ -202,7 +201,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 						for (SootClass childClass : childClasses) {
 							// Do we have support for the target class?
 							if (summaries.merge(flows.getMethodFlows(childClass, methodSig)))
-								return true;
+								found = true;
 
 							// Do we support any interface this class might have?
 							if (checkInterfaces(methodSig, summaries, childClass))
@@ -571,8 +570,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 				newTaints = new HashSet<>();
 
 			newTaints.add(new Taint(SourceSinkType.Field, -1, ap.getBaseType().toString(),
-					fieldArrayToStringArray(ap.getFields()), typeArrayToStringArray(ap.getFieldTypes()),
-					ap.getTaintSubFields()));
+					new AccessPathFragment(ap.getFields(), ap.getFieldTypes()), ap.getTaintSubFields()));
 		}
 
 		// Check whether a parameter is tainted
@@ -582,8 +580,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 				newTaints = new HashSet<>();
 
 			newTaints.add(new Taint(SourceSinkType.Parameter, paramIdx, ap.getBaseType().toString(),
-					fieldArrayToStringArray(ap.getFields()), typeArrayToStringArray(ap.getFieldTypes()),
-					ap.getTaintSubFields()));
+					new AccessPathFragment(ap.getFields(), ap.getFieldTypes()), ap.getTaintSubFields()));
 		}
 
 		// If we also match returned values, we must do this here
@@ -594,8 +591,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 					newTaints = new HashSet<>();
 
 				newTaints.add(new Taint(SourceSinkType.Return, -1, ap.getBaseType().toString(),
-						fieldArrayToStringArray(ap.getFields()), typeArrayToStringArray(ap.getFieldTypes()),
-						ap.getTaintSubFields()));
+						new AccessPathFragment(ap.getFields(), ap.getFieldTypes()), ap.getTaintSubFields()));
 			}
 		}
 
@@ -622,8 +618,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 			if (res == null)
 				res = new HashSet<>();
 			res.add(new Taint(SourceSinkType.Field, -1, ap.getBaseType().toString(),
-					fieldArrayToStringArray(ap.getFields()), typeArrayToStringArray(ap.getFieldTypes()),
-					ap.getTaintSubFields(), gap));
+					new AccessPathFragment(ap.getFields(), ap.getFieldTypes()), ap.getTaintSubFields(), gap));
 		}
 
 		// Check whether a parameter is tainted
@@ -632,8 +627,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 			if (res == null)
 				res = new HashSet<>();
 			res.add(new Taint(SourceSinkType.Parameter, paramIdx, ap.getBaseType().toString(),
-					fieldArrayToStringArray(ap.getFields()), typeArrayToStringArray(ap.getFieldTypes()),
-					ap.getTaintSubFields(), gap));
+					new AccessPathFragment(ap.getFields(), ap.getFieldTypes()), ap.getTaintSubFields(), gap));
 		}
 
 		// Check whether the return value is tainted
@@ -643,8 +637,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 				if (res == null)
 					res = new HashSet<>();
 				res.add(new Taint(SourceSinkType.Return, -1, ap.getBaseType().toString(),
-						fieldArrayToStringArray(ap.getFields()), typeArrayToStringArray(ap.getFieldTypes()),
-						ap.getTaintSubFields(), gap));
+						new AccessPathFragment(ap.getFields(), ap.getFieldTypes()), ap.getTaintSubFields(), gap));
 			}
 		}
 
@@ -662,7 +655,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 	protected AccessPath createAccessPathFromTaint(Taint t, Stmt stmt) {
 		// Convert the taints to Soot objects
 		SootField[] fields = safeGetFields(t.getAccessPath());
-		Type[] types = safeGetTypes(t.getAccessPathTypes(), fields);
+		Type[] types = safeGetTypes(t.getAccessPath(), fields);
 		Type baseType = TypeUtils.getTypeFromString(t.getBaseType());
 
 		// If the taint is a return value, we taint the left side of the
@@ -725,7 +718,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 	private AccessPath createAccessPathInMethod(Taint t, SootMethod sm) {
 		// Convert the taints to Soot objects
 		SootField[] fields = safeGetFields(t.getAccessPath());
-		Type[] types = safeGetTypes(t.getAccessPathTypes(), fields);
+		Type[] types = safeGetTypes(t.getAccessPath(), fields);
 		Type baseType = TypeUtils.getTypeFromString(t.getBaseType());
 
 		// A return value cannot be propagated into a method
@@ -747,36 +740,6 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 		throw new RuntimeException("Failed to convert taint " + t);
 	}
 
-	/**
-	 * Converts an array of SootFields to an array of strings
-	 * 
-	 * @param fields The array of SootFields to convert
-	 * @return The array of strings corresponding to the given array of SootFields
-	 */
-	private String[] fieldArrayToStringArray(SootField[] fields) {
-		if (fields == null)
-			return null;
-		String[] stringFields = new String[fields.length];
-		for (int i = 0; i < fields.length; i++)
-			stringFields[i] = fields[i].toString();
-		return stringFields;
-	}
-
-	/**
-	 * Converts an array of Soot Types to an array of strings
-	 * 
-	 * @param fields The array of Soot Types to convert
-	 * @return The array of strings corresponding to the given array of Soot Types
-	 */
-	private String[] typeArrayToStringArray(Type[] types) {
-		if (types == null)
-			return null;
-		String[] stringTypes = new String[types.length];
-		for (int i = 0; i < types.length; i++)
-			stringTypes[i] = types[i].toString();
-		return stringTypes;
-	}
-
 	@Override
 	public Set<Abstraction> getTaintsForMethod(Stmt stmt, Abstraction d1, Abstraction taintedAbs) {
 		// We only care about method invocations
@@ -788,8 +751,8 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 		ByReferenceBoolean classSupported = new ByReferenceBoolean(false);
 
 		// Compute the wrapper taints for the current method
-		Set<AccessPath> res = computeTaintsForMethod(stmt, d1, taintedAbs, stmt.getInvokeExpr().getMethod(),
-				killIncomingTaint, classSupported);
+		final SootMethod callee = stmt.getInvokeExpr().getMethod();
+		Set<AccessPath> res = computeTaintsForMethod(stmt, d1, taintedAbs, callee, killIncomingTaint, classSupported);
 
 		// Create abstractions from the access paths
 		if (res != null && !res.isEmpty()) {
@@ -801,29 +764,37 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 
 		// If we have no data flows, we can abort early
 		if (!killIncomingTaint.value && (resAbs == null || resAbs.isEmpty())) {
-			wrapperMisses.incrementAndGet();
-			SootMethod method = stmt.getInvokeExpr().getMethod();
-
-			if (!classSupported.value)
-				reportMissingMethod(method);
-
-			if (classSupported.value || fallbackWrapper == null)
-				return Collections.singleton(taintedAbs);
-			else {
-				Set<Abstraction> fallbackTaints = fallbackWrapper.getTaintsForMethod(stmt, d1, taintedAbs);
-				return fallbackTaints;
+			// Is this method explicitly excluded?
+			if (!this.flows.isMethodExcluded(callee.getDeclaringClass().getName(), callee.getSubSignature())) {
+				wrapperMisses.incrementAndGet();
+
+				if (classSupported.value)
+					return Collections.singleton(taintedAbs);
+				else {
+					reportMissingMethod(callee);
+					if (fallbackWrapper == null)
+						return null;
+					else {
+						Set<Abstraction> fallbackTaints = fallbackWrapper.getTaintsForMethod(stmt, d1, taintedAbs);
+						return fallbackTaints;
+					}
+				}
 			}
 		}
 
 		// We always retain the incoming abstraction unless it is explicitly
 		// cleared
-		if (!killIncomingTaint.value)
+		if (!killIncomingTaint.value) {
+			if (resAbs == null)
+				return Collections.singleton(taintedAbs);
 			resAbs.add(taintedAbs);
+		}
 		return resAbs;
 	}
 
 	protected void reportMissingMethod(SootMethod method) {
-		if (reportMissingSummaries && SystemClassHandler.isClassInSystemPackage(method.getDeclaringClass().getName()))
+		if (reportMissingSummaries
+				&& SystemClassHandler.v().isClassInSystemPackage(method.getDeclaringClass().getName()))
 			System.out.println("Missing summary for class " + method.getDeclaringClass());
 	}
 
@@ -929,8 +900,8 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 			// implementations in the application code
 			if ((flowsInTarget == null || flowsInTarget.isEmpty()) && curGap != null) {
 				SootMethod callee = Scene.v().grabMethod(curGap.getSignature());
-				if (callee != null)
-					for (SootMethod implementor : getAllImplementors(callee))
+				if (callee != null) {
+					for (SootMethod implementor : getAllImplementors(callee)) {
 						if (implementor.getDeclaringClass().isConcrete() && !implementor.getDeclaringClass().isPhantom()
 								&& implementor.isConcrete()) {
 							Set<AccessPathPropagator> implementorPropagators = spawnAnalysisIntoClientCode(implementor,
@@ -938,10 +909,12 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 							if (implementorPropagators != null)
 								workList.addAll(implementorPropagators);
 						}
+					}
+				}
 			}
 
 			// Apply the flow summaries for other libraries
-			if (flowsInTarget != null && !flowsInTarget.isEmpty())
+			if (flowsInTarget != null && !flowsInTarget.isEmpty()) {
 				for (MethodFlow flow : flowsInTarget) {
 					// Apply the flow summary
 					AccessPathPropagator newPropagator = applyFlow(flow, curPropagator);
@@ -979,6 +952,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 							workList.add(backwardsPropagator);
 					}
 				}
+			}
 		}
 		return res;
 	}
@@ -1495,8 +1469,8 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 
 		// Compare the shared sub-path
 		for (int i = 0; i < taintedPath.getAccessPathLength() && i < flowSource.getAccessPathLength(); i++) {
-			String taintField = taintedPath.getAccessPath()[i];
-			String sourceField = flowSource.getAccessPath()[i];
+			String taintField = taintedPath.getAccessPath().getField(i);
+			String sourceField = flowSource.getAccessPath().getField(i);
 			if (!sourceField.equals(taintField))
 				return false;
 		}
@@ -1537,6 +1511,20 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 		return Scene.v().makeFieldRef(sc, fieldName, TypeUtils.getTypeFromString(type), false).resolve();
 	}
 
+	/**
+	 * Gets an array of fields with the specified signatures
+	 * 
+	 * @param accessPath The access path from which to retrieve the list of the
+	 *                   field signatures
+	 * @return The Array of fields with the given signature if all exists, otherwise
+	 *         null
+	 */
+	private SootField[] safeGetFields(AccessPathFragment accessPath) {
+		if (accessPath == null || accessPath.isEmpty())
+			return null;
+		return safeGetFields(accessPath.getFields());
+	}
+
 	/**
 	 * Gets an array of fields with the specified signatures
 	 * 
@@ -1556,6 +1544,21 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 		return fields;
 	}
 
+	/**
+	 * Gets an array of types with the specified class names
+	 * 
+	 * @param accessPath The access path from which to retrieve the field types
+	 * @param fields     The fields from which to get the types if we don't have any
+	 *                   explicit ones
+	 * @return The Array of fields with the given signature if all exists, otherwise
+	 *         null
+	 */
+	private Type[] safeGetTypes(AccessPathFragment accessPath, SootField[] fields) {
+		if (accessPath == null || accessPath.isEmpty())
+			return null;
+		return safeGetTypes(accessPath.getFieldTypes(), fields);
+	}
+
 	/**
 	 * Gets an array of types with the specified class names
 	 * 
@@ -1613,29 +1616,23 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 		final AbstractFlowSinkSource flowSource = flow.source();
 		final AbstractFlowSinkSource flowSink = flow.sink();
 		final boolean taintSubFields = flow.sink().taintSubFields();
-		final boolean checkTypes = flow.getTypeChecking();
-
-		final String[] remainingFields = flow.getCutSubFields() ? null : getRemainingFields(flowSource, taint);
-		final String[] remainingFieldTypes = flow.getCutSubFields() ? null : getRemainingFieldTypes(flowSource, taint);
+		final Boolean checkTypes = flow.getTypeChecking();
 
-		final String[] appendedFields = append(flowSink.getAccessPath(), remainingFields);
-		final String[] appendedFieldTypes = append(flowSink.getAccessPathTypes(), remainingFieldTypes, true);
+		AccessPathFragment remainingFields = cutSubFields(flow, getRemainingFields(flowSource, taint));
+		AccessPathFragment appendedFields = AccessPathFragment.append(flowSink.getAccessPath(), remainingFields);
 
 		int lastCommonAPIdx = Math.min(flowSource.getAccessPathLength(), taint.getAccessPathLength());
 
 		Type sinkType = TypeUtils.getTypeFromString(getAssignmentType(flowSink));
 		Type taintType = TypeUtils.getTypeFromString(getAssignmentType(taint, lastCommonAPIdx - 1));
 
-		if (checkTypes) {
-			// For type checking, we need types
-			if (sinkType == null || taintType == null)
-				return null;
-
+		// For type checking, we need types
+		if ((checkTypes == null || checkTypes.booleanValue()) && sinkType != null && taintType != null) {
 			// If we taint something in the base object, its type must match. We
 			// might have a taint for "a" in o.add(a) and need to check whether
 			// "o" matches the expected type in our summary.
 			if (!(sinkType instanceof PrimType) && !isCastCompatible(taintType, sinkType)
-					&& flowSink.getType() == SourceSinkType.Field && !checkTypes) {
+					&& flowSink.getType() == SourceSinkType.Field) {
 				// If the target is an array, the value might also flow into an
 				// element
 				boolean found = false;
@@ -1661,7 +1658,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 		// If we enter a gap with a type "GapBaseObject", we need to convert
 		// it to a regular field
 		SourceSinkType sourceSinkType = flowSink.getType();
-		if (flowSink.getType() == SourceSinkType.GapBaseObject && remainingFields != null && remainingFields.length > 0)
+		if (flowSink.getType() == SourceSinkType.GapBaseObject && remainingFields != null && !remainingFields.isEmpty())
 			sourceSinkType = SourceSinkType.Field;
 
 		// Compute the new base type
@@ -1673,16 +1670,51 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 		// Set the correct type. In case x -> b.x, the new type is not the type
 		// of b, but of the field x.
 		if (flowSink.hasAccessPath()) {
-			if (appendedFieldTypes != null)
-				appendedFieldTypes[flowSink.getAccessPathLength() - 1] = "" + newBaseType;
+			if (appendedFields != null)
+				appendedFields = appendedFields.updateFieldType(flowSink.getAccessPathLength() - 1, "" + newBaseType);
 			sBaseType = flowSink.getBaseType();
 		}
 
 		// Taint the correct fields
-		return new Taint(sourceSinkType, flowSink.getParameterIndex(), sBaseType, appendedFields, appendedFieldTypes,
+		return new Taint(sourceSinkType, flowSink.getParameterIndex(), sBaseType, appendedFields,
 				taintSubFields || taint.taintSubFields(), gap);
 	}
 
+	/**
+	 * Cuts the given access path if required for the given method flow. This method
+	 * can cut the incoming access path to shorter lengths or abandon the original
+	 * access path altogether.
+	 * 
+	 * @param flow       The method flow specification
+	 * @param accessPath The remaining fields from the original access path
+	 * @return The fields that shall be appended to the new access path. This is
+	 *         usually a prefix of the original remaining fields
+	 */
+	protected AccessPathFragment cutSubFields(MethodFlow flow, AccessPathFragment accessPath) {
+		if (isCutSubFields(flow))
+			return null;
+		else
+			return accessPath;
+	}
+
+	/**
+	 * Checks whether the following fields shall be deleted when applying the given
+	 * flow specification
+	 * 
+	 * @param flow The flow specification to check
+	 * @return true if the following fields shall be deleted, false otherwise
+	 */
+	protected boolean isCutSubFields(MethodFlow flow) {
+		Boolean cut = flow.getCutSubFields();
+		Boolean typeChecking = flow.getTypeChecking();
+		if (cut == null) {
+			if (typeChecking != null)
+				return !typeChecking.booleanValue();
+			return false;
+		}
+		return cut.booleanValue();
+	}
+
 	/**
 	 * Gets the type at the given position from a taint.
 	 * 
@@ -1694,7 +1726,13 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 	private String getAssignmentType(Taint taint, int idx) {
 		if (idx < 0)
 			return taint.getBaseType();
-		return taint.getAccessPathTypes() == null ? null : taint.getAccessPathTypes()[idx];
+
+		final AccessPathFragment accessPath = taint.getAccessPath();
+		if (accessPath == null)
+			return null;
+		final String[] fieldTypes = accessPath.getFieldTypes();
+
+		return fieldTypes == null ? null : fieldTypes[idx];
 	}
 
 	/**
@@ -1711,8 +1749,9 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 
 		// If we don't have explicit access path types, we use the declared
 		// types instead
-		if (srcSink.getAccessPathTypes() == null && srcSink.getAccessPath() != null) {
-			String[] ap = srcSink.getAccessPath();
+		final AccessPathFragment accessPath = srcSink.getAccessPath();
+		if (accessPath.getFieldTypes() == null && accessPath.getFields() != null) {
+			String[] ap = accessPath.getFields();
 			String apElement = ap[srcSink.getAccessPathLength() - 1];
 
 			Pattern pattern = Pattern.compile("^\\s*<(.*?):\\s*(.*?)>\\s*$");
@@ -1722,47 +1761,8 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 			}
 		}
 
-		return srcSink.getAccessPathTypes() == null ? null
-				: srcSink.getAccessPathTypes()[srcSink.getAccessPathLength() - 1];
-	}
-
-	/**
-	 * Concatenates the two given arrays to one bigger array
-	 * 
-	 * @param fields          The first array
-	 * @param remainingFields The second array
-	 * @return The concatenated array containing all elements from both given arrays
-	 */
-	private String[] append(String[] fields, String[] remainingFields) {
-		return append(fields, remainingFields, false);
-	}
-
-	/**
-	 * Concatenates the two given arrays to one bigger array
-	 * 
-	 * @param fields          The first array
-	 * @param remainingFields The second array
-	 * @return The concatenated array containing all elements from both given arrays
-	 */
-	private String[] append(String[] fields, String[] remainingFields, boolean alwaysCopy) {
-		if (fields == null) {
-			if (alwaysCopy && remainingFields != null)
-				return Arrays.copyOf(remainingFields, remainingFields.length);
-			else
-				return remainingFields;
-		}
-		if (remainingFields == null) {
-			if (alwaysCopy && fields != null)
-				return Arrays.copyOf(fields, fields.length);
-			else
-				return fields;
-		}
-
-		int cnt = fields.length + remainingFields.length;
-		String[] appended = new String[cnt];
-		System.arraycopy(fields, 0, appended, 0, fields.length);
-		System.arraycopy(remainingFields, 0, appended, fields.length, remainingFields.length);
-		return appended;
+		return accessPath.getFieldTypes() == null ? null
+				: accessPath.getFieldTypes()[srcSink.getAccessPathLength() - 1];
 	}
 
 	/**
@@ -1774,7 +1774,7 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 	 * @return The remaining fields which are tainted in the given access path, but
 	 *         which are not covered by the given flow summary source
 	 */
-	private String[] getRemainingFields(AbstractFlowSinkSource flowSource, Taint taintedPath) {
+	private AccessPathFragment getRemainingFields(AbstractFlowSinkSource flowSource, Taint taintedPath) {
 		if (!flowSource.hasAccessPath())
 			return taintedPath.getAccessPath();
 
@@ -1782,32 +1782,16 @@ public class SummaryTaintWrapper implements IReversibleTaintWrapper {
 		if (fieldCnt <= 0)
 			return null;
 
-		String[] fields = new String[fieldCnt];
-		System.arraycopy(taintedPath.getAccessPath(), flowSource.getAccessPathLength(), fields, 0, fieldCnt);
-		return fields;
-	}
-
-	/**
-	 * Gets the types of the remaining fields which are tainted, but not covered by
-	 * the given flow summary source
-	 * 
-	 * @param flowSource  The flow summary source
-	 * @param taintedPath The tainted access path
-	 * @return The types of the remaining fields which are tainted in the given
-	 *         access path, but which are not covered by the given flow summary
-	 *         source
-	 */
-	private String[] getRemainingFieldTypes(AbstractFlowSinkSource flowSource, Taint taintedPath) {
-		if (!flowSource.hasAccessPath())
-			return taintedPath.getAccessPathTypes();
-
-		int fieldCnt = taintedPath.getAccessPathLength() - flowSource.getAccessPathLength();
-		if (fieldCnt <= 0)
-			return null;
+		final AccessPathFragment taintedAP = taintedPath.getAccessPath();
+		String[] oldFields = taintedAP.getFields();
+		String[] oldFieldTypes = taintedAP.getFieldTypes();
 
 		String[] fields = new String[fieldCnt];
-		System.arraycopy(taintedPath.getAccessPathTypes(), flowSource.getAccessPathLength(), fields, 0, fieldCnt);
-		return fields;
+		String[] fieldTypes = new String[fieldCnt];
+		System.arraycopy(oldFields, flowSource.getAccessPathLength(), fields, 0, fieldCnt);
+		System.arraycopy(oldFieldTypes, flowSource.getAccessPathLength(), fieldTypes, 0, fieldCnt);
+
+		return new AccessPathFragment(fields, fieldTypes);
 	}
 
 	/**
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/Taint.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/Taint.java
index c7361b1..2a57b3d 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/Taint.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/taintWrappers/Taint.java
@@ -16,19 +16,19 @@ public class Taint extends FlowSink implements Cloneable {
 		super(type, paramterIdx, baseType, taintSubFields);
 	}
 
-	public Taint(SourceSinkType type, int paramterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public Taint(SourceSinkType type, int paramterIdx, String baseType, AccessPathFragment accessPath,
 			boolean taintSubFields) {
-		super(type, paramterIdx, baseType, fields, fieldTypes, taintSubFields);
+		super(type, paramterIdx, baseType, accessPath, taintSubFields);
 	}
 
-	public Taint(SourceSinkType type, int paramterIdx, String baseType, String[] fields, String[] fieldTypes,
+	public Taint(SourceSinkType type, int paramterIdx, String baseType, AccessPathFragment accessPath,
 			boolean taintSubFields, GapDefinition gap) {
-		super(type, paramterIdx, baseType, fields, fieldTypes, taintSubFields, gap);
+		super(type, paramterIdx, baseType, accessPath, taintSubFields, gap);
 	}
 
 	@Override
 	public Taint clone() {
-		return new Taint(type, parameterIdx, baseType, accessPath, accessPathTypes, taintSubFields);
+		return new Taint(type, parameterIdx, baseType, accessPath, taintSubFields);
 	}
 
 }
\ No newline at end of file
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/MetaDataReader.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/MetaDataReader.java
index 7564da4..044ff95 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/MetaDataReader.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/MetaDataReader.java
@@ -23,7 +23,7 @@ public class MetaDataReader extends AbstractXMLReader {
 	private static final String XSD_FILE_PATH = "schema/SummaryMetaData.xsd";
 
 	private enum State {
-		summaryMetaData, exclusiveModels, exclusiveModel
+		summaryMetaData, exclusiveModels, exclusiveModel, hierarchy, clazz
 	}
 
 	/**
@@ -43,6 +43,7 @@ public class MetaDataReader extends AbstractXMLReader {
 
 			String name = "";
 			String type = "";
+			String superclass = "";
 
 			State state = State.summaryMetaData;
 			while (xmlreader.hasNext()) {
@@ -86,6 +87,32 @@ public class MetaDataReader extends AbstractXMLReader {
 						state = State.summaryMetaData;
 					else
 						throw new SummaryXMLException();
+				} else if (localName.equals(XMLMetaDataConstants.TREE_HIERARCHY) && xmlreader.isStartElement()) {
+					if (state == State.summaryMetaData)
+						state = State.hierarchy;
+					else
+						throw new SummaryXMLException();
+				} else if (localName.equals(XMLMetaDataConstants.TREE_CLASS) && xmlreader.isStartElement()) {
+					if (state == State.hierarchy) {
+						state = State.clazz;
+
+						name = getAttributeByName(xmlreader, XMLMetaDataConstants.ATTRIBUTE_NAME);
+						superclass = getAttributeByName(xmlreader, XMLMetaDataConstants.ATTRIBUTE_SUPERCLASS);
+					} else
+						throw new SummaryXMLException();
+				} else if (localName.equals(XMLMetaDataConstants.TREE_CLASS) && xmlreader.isEndElement()) {
+					if (state == State.clazz) {
+						state = State.hierarchy;
+
+						// Record the hierarchy element
+						metaData.setSuperclass(name, superclass);
+					} else
+						throw new SummaryXMLException();
+				} else if (localName.equals(XMLMetaDataConstants.TREE_HIERARCHY) && xmlreader.isEndElement()) {
+					if (state == State.hierarchy)
+						state = State.summaryMetaData;
+					else
+						throw new SummaryXMLException();
 				}
 			}
 
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/SummaryReader.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/SummaryReader.java
index e074f6a..b020fbb 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/SummaryReader.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/SummaryReader.java
@@ -32,6 +32,7 @@ import soot.jimple.infoflow.methodSummary.data.summary.MethodClear;
 import soot.jimple.infoflow.methodSummary.data.summary.MethodFlow;
 import soot.jimple.infoflow.methodSummary.data.summary.MethodSummaries;
 import soot.jimple.infoflow.methodSummary.data.summary.SourceSinkType;
+import soot.jimple.infoflow.methodSummary.taintWrappers.AccessPathFragment;
 
 public class SummaryReader extends AbstractXMLReader {
 
@@ -67,8 +68,8 @@ public class SummaryReader extends AbstractXMLReader {
 			String currentMethod = "";
 			int currentID = -1;
 			boolean isAlias = false;
-			boolean typeChecking = true;
-			boolean cutSubfields = false;
+			Boolean typeChecking = null;
+			Boolean cutSubfields = null;
 
 			State state = State.summary;
 			while (xmlreader.hasNext()) {
@@ -78,7 +79,11 @@ public class SummaryReader extends AbstractXMLReader {
 					continue;
 
 				final String localName = xmlreader.getLocalName();
-				if (localName.equals(XMLConstants.TREE_METHODS) && xmlreader.isStartElement()) {
+				if (localName.equals(XMLConstants.TREE_SUMMARY) && xmlreader.isStartElement()) {
+					String isInterface = getAttributeByName(xmlreader, XMLConstants.ATTRIBUTE_IS_INTERFACE);
+					if (isInterface != null)
+						summaries.setInterface(isInterface.equals(XMLConstants.VALUE_TRUE));
+				} else if (localName.equals(XMLConstants.TREE_METHODS) && xmlreader.isStartElement()) {
 					if (state == State.summary)
 						state = State.methods;
 					else
@@ -86,6 +91,9 @@ public class SummaryReader extends AbstractXMLReader {
 				} else if (localName.equals(TREE_METHOD) && xmlreader.isStartElement()) {
 					if (state == State.methods) {
 						currentMethod = getAttributeByName(xmlreader, XMLConstants.ATTRIBUTE_METHOD_SIG);
+						String sIsExcluded = getAttributeByName(xmlreader, XMLConstants.ATTRIBUTE_IS_EXCLUDED);
+						if (sIsExcluded != null && sIsExcluded.equals(XMLConstants.VALUE_TRUE))
+							summary.addExcludedMethod(currentMethod);
 						state = State.method;
 					} else
 						throw new SummaryXMLException();
@@ -101,12 +109,14 @@ public class SummaryReader extends AbstractXMLReader {
 						state = State.flow;
 						String sAlias = getAttributeByName(xmlreader, XMLConstants.ATTRIBUTE_IS_ALIAS);
 						isAlias = sAlias != null && sAlias.equals(XMLConstants.VALUE_TRUE);
+
 						String sTypeChecking = getAttributeByName(xmlreader, XMLConstants.ATTRIBUTE_TYPE_CHECKING);
-						if (sTypeChecking != null)
+						if (sTypeChecking != null && !sTypeChecking.isEmpty())
 							typeChecking = sTypeChecking.equals(XMLConstants.VALUE_TRUE);
+
 						String sCutSubfields = getAttributeByName(xmlreader, XMLConstants.ATTRIBUTE_CUT_SUBFIELDS);
-						if (sCutSubfields != null)
-							cutSubfields = sTypeChecking.equals(XMLConstants.VALUE_TRUE);
+						if (sCutSubfields != null && !sCutSubfields.isEmpty())
+							cutSubfields = sCutSubfields.equals(XMLConstants.VALUE_TRUE);
 					} else
 						throw new SummaryXMLException();
 				} else if (localName.equals(TREE_CLEAR) && xmlreader.isStartElement()) {
@@ -203,9 +213,7 @@ public class SummaryReader extends AbstractXMLReader {
 			// bogus stuff
 			if (validateSummariesOnRead)
 				summary.validate();
-		} finally
-
-		{
+		} finally {
 			if (xmlreader != null)
 				xmlreader.close();
 		}
@@ -245,12 +253,13 @@ public class SummaryReader extends AbstractXMLReader {
 	private FlowSource createSource(MethodSummaries summary, Map<String, String> attributes)
 			throws SummaryXMLException {
 		if (isField(attributes)) {
-			return new FlowSource(SourceSinkType.Field, getBaseType(attributes), getAccessPath(attributes),
-					getAccessPathTypes(attributes), getGapDefinition(attributes, summary), isMatchStrict(attributes));
+			return new FlowSource(SourceSinkType.Field, getBaseType(attributes),
+					new AccessPathFragment(getAccessPath(attributes), getAccessPathTypes(attributes)),
+					getGapDefinition(attributes, summary), isMatchStrict(attributes));
 		} else if (isParameter(attributes)) {
 			return new FlowSource(SourceSinkType.Parameter, parameterIdx(attributes), getBaseType(attributes),
-					getAccessPath(attributes), getAccessPathTypes(attributes), getGapDefinition(attributes, summary),
-					isMatchStrict(attributes));
+					new AccessPathFragment(getAccessPath(attributes), getAccessPathTypes(attributes)),
+					getGapDefinition(attributes, summary), isMatchStrict(attributes));
 		} else if (isGapBaseObject(attributes)) {
 			return new FlowSource(SourceSinkType.GapBaseObject, getBaseType(attributes),
 					getGapDefinition(attributes, summary), isMatchStrict(attributes));
@@ -260,8 +269,9 @@ public class SummaryReader extends AbstractXMLReader {
 				throw new SummaryXMLException(
 						"Return values can only be " + "sources if they have a gap specification");
 
-			return new FlowSource(SourceSinkType.Return, getBaseType(attributes), getAccessPath(attributes),
-					getAccessPathTypes(attributes), getGapDefinition(attributes, summary), isMatchStrict(attributes));
+			return new FlowSource(SourceSinkType.Return, getBaseType(attributes),
+					new AccessPathFragment(getAccessPath(attributes), getAccessPathTypes(attributes)),
+					getGapDefinition(attributes, summary), isMatchStrict(attributes));
 		}
 		throw new SummaryXMLException("Invalid flow source definition");
 	}
@@ -276,17 +286,17 @@ public class SummaryReader extends AbstractXMLReader {
 	 */
 	private FlowSink createSink(MethodSummaries summary, Map<String, String> attributes) throws SummaryXMLException {
 		if (isField(attributes)) {
-			return new FlowSink(SourceSinkType.Field, getBaseType(attributes), getAccessPath(attributes),
-					getAccessPathTypes(attributes), taintSubFields(attributes), getGapDefinition(attributes, summary),
-					isMatchStrict(attributes));
+			return new FlowSink(SourceSinkType.Field, getBaseType(attributes),
+					new AccessPathFragment(getAccessPath(attributes), getAccessPathTypes(attributes)),
+					taintSubFields(attributes), getGapDefinition(attributes, summary), isMatchStrict(attributes));
 		} else if (isParameter(attributes)) {
 			return new FlowSink(SourceSinkType.Parameter, parameterIdx(attributes), getBaseType(attributes),
-					getAccessPath(attributes), getAccessPathTypes(attributes), taintSubFields(attributes),
-					getGapDefinition(attributes, summary), isMatchStrict(attributes));
+					new AccessPathFragment(getAccessPath(attributes), getAccessPathTypes(attributes)),
+					taintSubFields(attributes), getGapDefinition(attributes, summary), isMatchStrict(attributes));
 		} else if (isReturn(attributes)) {
-			return new FlowSink(SourceSinkType.Return, getBaseType(attributes), getAccessPath(attributes),
-					getAccessPathTypes(attributes), taintSubFields(attributes), getGapDefinition(attributes, summary),
-					isMatchStrict(attributes));
+			return new FlowSink(SourceSinkType.Return, getBaseType(attributes),
+					new AccessPathFragment(getAccessPath(attributes), getAccessPathTypes(attributes)),
+					taintSubFields(attributes), getGapDefinition(attributes, summary), isMatchStrict(attributes));
 		} else if (isGapBaseObject(attributes)) {
 			return new FlowSink(SourceSinkType.GapBaseObject, -1, getBaseType(attributes), false,
 					getGapDefinition(attributes, summary), isMatchStrict(attributes));
@@ -304,11 +314,13 @@ public class SummaryReader extends AbstractXMLReader {
 	 */
 	private FlowClear createClear(MethodSummaries summary, Map<String, String> attributes) throws SummaryXMLException {
 		if (isField(attributes)) {
-			return new FlowClear(SourceSinkType.Field, getBaseType(attributes), getAccessPath(attributes),
-					getAccessPathTypes(attributes), getGapDefinition(attributes, summary));
+			return new FlowClear(SourceSinkType.Field, getBaseType(attributes),
+					new AccessPathFragment(getAccessPath(attributes), getAccessPathTypes(attributes)),
+					getGapDefinition(attributes, summary));
 		} else if (isParameter(attributes)) {
 			return new FlowClear(SourceSinkType.Parameter, parameterIdx(attributes), getBaseType(attributes),
-					getAccessPath(attributes), getAccessPathTypes(attributes), getGapDefinition(attributes, summary));
+					new AccessPathFragment(getAccessPath(attributes), getAccessPathTypes(attributes)),
+					getGapDefinition(attributes, summary));
 		} else if (isGapBaseObject(attributes)) {
 			return new FlowClear(SourceSinkType.GapBaseObject, getBaseType(attributes),
 					getGapDefinition(attributes, summary));
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/SummaryWriter.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/SummaryWriter.java
index 93ece60..e931647 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/SummaryWriter.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/SummaryWriter.java
@@ -30,11 +30,12 @@ import soot.jimple.infoflow.methodSummary.data.summary.ClassSummaries;
 import soot.jimple.infoflow.methodSummary.data.summary.GapDefinition;
 import soot.jimple.infoflow.methodSummary.data.summary.MethodFlow;
 import soot.jimple.infoflow.methodSummary.data.summary.MethodSummaries;
+import soot.jimple.infoflow.methodSummary.taintWrappers.AccessPathFragment;
 import soot.jimple.infoflow.util.SootMethodRepresentationParser;
 
 public class SummaryWriter {
 
-	private final int FILE_FORMAT_VERSION = 102;
+	private final int FILE_FORMAT_VERSION = 103;
 
 	public SummaryWriter() {
 
@@ -77,6 +78,9 @@ public class SummaryWriter {
 		writer.writeStartDocument();
 		writer.writeStartElement(XMLConstants.TREE_SUMMARY);
 		writer.writeAttribute(XMLConstants.ATTRIBUTE_FORMAT_VERSION, FILE_FORMAT_VERSION + "");
+		if (summary.hasInterfaceInfo())
+			writer.writeAttribute(XMLConstants.ATTRIBUTE_IS_INTERFACE,
+					summary.isInterface() ? XMLConstants.VALUE_TRUE : XMLConstants.VALUE_FALSE);
 
 		MethodSummaries methodSummaries = summary.getMethodSummaries();
 
@@ -217,9 +221,12 @@ public class SummaryWriter {
 			throw new RuntimeException("Unsupported source or sink type " + currentFlow.getType());
 
 		writer.writeAttribute(ATTRIBUTE_BASETYPE, currentFlow.getBaseType());
-		if (currentFlow.hasAccessPath() && currentFlow.getAccessPath() != null) {
-			writer.writeAttribute(ATTRIBUTE_ACCESSPATH, Arrays.toString(currentFlow.getAccessPath()));
-			writer.writeAttribute(ATTRIBUTE_ACCESSPATHTYPES, Arrays.toString(currentFlow.getAccessPathTypes()));
+		if (currentFlow.hasAccessPath()) {
+			final AccessPathFragment accessPath = currentFlow.getAccessPath();
+			if (accessPath != null && !accessPath.isEmpty()) {
+				writer.writeAttribute(ATTRIBUTE_ACCESSPATH, Arrays.toString(accessPath.getFields()));
+				writer.writeAttribute(ATTRIBUTE_ACCESSPATHTYPES, Arrays.toString(accessPath.getFieldTypes()));
+			}
 		}
 		if (currentFlow.getGap() != null)
 			writer.writeAttribute(XMLConstants.ATTRIBUTE_GAP, currentFlow.getGap().getID() + "");
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/XMLConstants.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/XMLConstants.java
index b307a3b..c81d94d 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/XMLConstants.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/XMLConstants.java
@@ -22,8 +22,10 @@ public class XMLConstants {
 	public static final String TREE_INTERFACE = "interface";
 
 	public static final String ATTRIBUTE_FORMAT_VERSION = "fileFormatVersion";
+	public static final String ATTRIBUTE_IS_INTERFACE = "isInterface";
 	public static final String ATTRIBUTE_ID = "num";
 	public static final String ATTRIBUTE_METHOD_SIG = "id";
+	public static final String ATTRIBUTE_IS_EXCLUDED = "isExcluded";
 	public static final String ATTRIBUTE_FLOWTYPE = "sourceSinkType";
 	public static final String ATTRIBUTE_PARAMTER_INDEX = "ParameterIndex";
 	public static final String ATTRIBUTE_ACCESSPATH = "AccessPath";
diff --git a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/XMLMetaDataConstants.java b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/XMLMetaDataConstants.java
index 56b24e1..1163b97 100644
--- a/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/XMLMetaDataConstants.java
+++ b/soot-infoflow-summaries/src/soot/jimple/infoflow/methodSummary/xml/XMLMetaDataConstants.java
@@ -10,9 +10,13 @@ public class XMLMetaDataConstants {
 	public static final String TREE_EXCLUSIVE_MODELS = "exclusiveModels";
 	public static final String TREE_EXCLUSIVE_MODEL = "exclusiveModel";
 
+	public static final String TREE_HIERARCHY = "hierarchy";
+	public static final String TREE_CLASS = "class";
+
 	public static final String ATTRIBUTE_FORMAT_VERSION = "fileFormatVersion";
 	public static final String ATTRIBUTE_TYPE = "type";
 	public static final String ATTRIBUTE_NAME = "name";
+	public static final String ATTRIBUTE_SUPERCLASS = "superClass";
 
 	public static final String VALUE_CLASS = "class";
 	public static final String VALUE_PACKAGE = "package";
diff --git a/soot-infoflow-summaries/summariesManual/SummaryMetaData.xml b/soot-infoflow-summaries/summariesManual/SummaryMetaData.xml
index 560af53..de35bac 100644
--- a/soot-infoflow-summaries/summariesManual/SummaryMetaData.xml
+++ b/soot-infoflow-summaries/summariesManual/SummaryMetaData.xml
@@ -7,7 +7,10 @@
 		<exclusiveModel type="package" name="com.flurry" />
 		<exclusiveModel type="package" name="it.sephiroth.android.library" />
 		
-		<exclusiveModel type="package" name="java.lang.reflect" />
+		<!--
+			This breaks reflection support
+			<exclusiveModel type="package" name="java.lang.reflect" />
+		-->
 		
 		<exclusiveModel type="package" name="org.apache.commons.codec" />
 		<exclusiveModel type="package" name="org.apache.http" />
@@ -22,4 +25,9 @@
 		<exclusiveModel type="class" name="java.util.Timer" />
 		<exclusiveModel type="class" name="java.text.SimpleDateFormat" />
 	</exclusiveModels>
+	<hierarchy>
+		<class
+			name="org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer$MvcMatchersAuthorizedUrl"
+			superClass="org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer$AuthorizedUrl" />
+	</hierarchy>
 </summaryMetaData>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/summariesManual/android.database.Cursor.xml b/soot-infoflow-summaries/summariesManual/android.database.Cursor.xml
new file mode 100644
index 0000000..8dd66a4
--- /dev/null
+++ b/soot-infoflow-summaries/summariesManual/android.database.Cursor.xml
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<summary fileFormatVersion="101">
+    <methods>
+        <method id="java.lang.String getString(int)">
+            <flows>
+                <flow isAlias="true" typeChecking="false">
+                    <from sourceSinkType="Field"/>
+                    <to sourceSinkType="Return"/>
+                </flow>
+            </flows>
+        </method>
+        <method id="byte[] getBlob(int)">
+            <flows>
+                <flow isAlias="true" typeChecking="false">
+                    <from sourceSinkType="Field"/>
+                    <to sourceSinkType="Return"/>
+                </flow>
+            </flows>
+        </method>
+        <method id="double getDouble(int)">
+            <flows>
+                <flow isAlias="true" typeChecking="false">
+                    <from sourceSinkType="Field"/>
+                    <to sourceSinkType="Return"/>
+                </flow>
+            </flows>
+        </method>
+        <method id="float getFloat(int)">
+            <flows>
+                <flow isAlias="true" typeChecking="false">
+                    <from sourceSinkType="Field"/>
+                    <to sourceSinkType="Return"/>
+                </flow>
+            </flows>
+        </method>
+        <method id="int getInt(int)">
+            <flows>
+                <flow isAlias="true" typeChecking="false">
+                    <from sourceSinkType="Field"/>
+                    <to sourceSinkType="Return"/>
+                </flow>
+            </flows>
+        </method>
+        <method id="long getLong(int)">
+            <flows>
+                <flow isAlias="true" typeChecking="false">
+                    <from sourceSinkType="Field"/>
+                    <to sourceSinkType="Return"/>
+                </flow>
+            </flows>
+        </method>
+        <method id="short getShort(int)">
+            <flows>
+                <flow isAlias="true" typeChecking="false">
+                    <from sourceSinkType="Field"/>
+                    <to sourceSinkType="Return"/>
+                </flow>
+            </flows>
+        </method>
+        <method id="android.os.Bundle getExtras()">
+            <flows>
+                <flow isAlias="true" typeChecking="false">
+                    <from sourceSinkType="Field"/>
+                    <to sourceSinkType="Return"/>
+                </flow>
+            </flows>
+        </method>
+        <method id="void copyStringToBuffer(int,android.database.CharArrayBuffer)">
+            <flows>
+                <flow isAlias="true" typeChecking="false">
+                    <from sourceSinkType="Field"/>
+                    <to sourceSinkType="Parameter" ParameterIndex="1" BaseType="android.database.CharArrayBuffer"/>
+                </flow>
+            </flows>
+        </method>
+        <method id="void close()">
+            <clears>
+                <clear sourceSinkType="Field"/>
+            </clears>
+        </method>
+    </methods>
+</summary>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/summariesManual/android.os.Parcel.xml b/soot-infoflow-summaries/summariesManual/android.os.Parcel.xml
index f110107..e317bea 100644
--- a/soot-infoflow-summaries/summariesManual/android.os.Parcel.xml
+++ b/soot-infoflow-summaries/summariesManual/android.os.Parcel.xml
@@ -5,8 +5,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" />
 				</flow>
 			</flows>
@@ -15,8 +15,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return"
 						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
 						AccessPathTypes="[java.lang.Object[]]" />
@@ -27,8 +27,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -37,8 +37,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
 						AccessPathTypes="[java.lang.Object[]]" />
@@ -49,8 +49,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -59,11 +59,11 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" 
 						AccessPath="[android.os.Bundle: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -71,8 +71,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" />
 				</flow>
 			</flows>
@@ -81,8 +81,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -91,8 +91,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -101,8 +101,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" />
 				</flow>
 			</flows>
@@ -111,8 +111,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -121,8 +121,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" />
 				</flow>
 			</flows>
@@ -131,8 +131,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -141,16 +141,16 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return"
 						AccessPath="[java.util.Map: java.lang.Object[] keys]"
 						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return"
 						AccessPath="[java.util.Map: java.lang.Object[] values]"
 						AccessPathTypes="[java.lang.Object[]]" />
@@ -161,8 +161,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" />
 				</flow>
 			</flows>
@@ -171,8 +171,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -181,8 +181,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
 						AccessPathTypes="[java.lang.Object[]]" />
@@ -193,8 +193,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" />
 				</flow>
 			</flows>
@@ -203,8 +203,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -213,16 +213,16 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[java.util.Map: java.lang.Object[] keys]"
 						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[java.util.Map: java.lang.Object[] values]"
 						AccessPathTypes="[java.lang.Object[]]" />
@@ -233,11 +233,11 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" BaseType="android.os.Parcelable"
 						AccessPath="[android.os.Parcelable: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -245,11 +245,11 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" BaseType="android.os.Parcelable"
 						AccessPath="[android.os.Parcelable: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -257,11 +257,11 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" BaseType="android.os.PersistableBundle"
 						AccessPath="[android.os.PersistableBundle: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -269,11 +269,11 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" BaseType="android.os.PersistableBundle"
 						AccessPath="[android.os.PersistableBundle: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -281,11 +281,11 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" BaseType="java.io.Serializable"
 						AccessPath="[java.io.Serializable: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -293,16 +293,16 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" BaseType="android.util.Size"
 						AccessPath="[android.util.Size: int width]"
 						AccessPathTypes="[int]" />
 				</flow>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" BaseType="android.util.Size"
 						AccessPath="[android.util.Size: int height]"
 						AccessPathTypes="[int]" />
@@ -313,11 +313,11 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" BaseType="android.util.SparseArray"
 						AccessPath="[android.util.SparseArray: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -325,8 +325,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" BaseType="android.util.SparseBooleanArray"
 						AccessPath="[android.util.SparseBooleanArray: boolean[] data]"
 						AccessPathTypes="[boolean[]]" />
@@ -337,8 +337,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" />
 				</flow>
 			</flows>
@@ -347,8 +347,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -357,8 +357,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="1"
 						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
 						AccessPathTypes="[java.lang.Object[]]" />
@@ -369,8 +369,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" />
 				</flow>
 			</flows>
@@ -379,8 +379,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -389,8 +389,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Parameter" ParameterIndex="0" />
 				</flow>
 			</flows>
@@ -399,8 +399,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" />
 				</flow>
 			</flows>
@@ -409,19 +409,19 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Return" />
 				</flow>
 			</flows>
 		</method>
 		<method id="void unmarshall(byte[],int,int)">
 			<flows>
-				<flow isAlias="false">
+				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -430,8 +430,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -440,8 +440,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -450,8 +450,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -460,8 +460,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -470,10 +470,10 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[android.os.Bundle: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -482,8 +482,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -492,8 +492,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -502,8 +502,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -512,8 +512,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -522,8 +522,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -532,8 +532,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -542,8 +542,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -552,8 +552,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -562,8 +562,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -572,8 +572,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -582,8 +582,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -592,8 +592,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -602,8 +602,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -614,8 +614,8 @@
 						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
 						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -624,8 +624,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -634,8 +634,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -646,16 +646,16 @@
 						AccessPath="[java.util.Map: java.lang.Object[] keys]"
 						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[java.util.Map: java.lang.Object[] values]"
 						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -664,10 +664,10 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[android.os.Parcelable: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -676,10 +676,10 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[android.os.Parcelable: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Field" BaseType="android.os.Parcel"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -688,10 +688,10 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[android.os.PersistableBundle: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Field" BaseType="android.os.PersistableBundle"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -700,10 +700,10 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[java.io.Serializable: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -714,16 +714,16 @@
 						AccessPath="[android.util.Size: int width]"
 						AccessPathTypes="[int]" />
 					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[android.util.Size: int height]"
 						AccessPathTypes="[int]" />
 					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -734,16 +734,16 @@
 						AccessPath="[android.util.SizeF: float width]"
 						AccessPathTypes="[float]" />
 					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[android.util.SizeF: float height]"
 						AccessPathTypes="[float]" />
 					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -752,10 +752,10 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[android.util.SparseArray: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPathTypes="[java.lang.Object[]]" />
 					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -766,8 +766,8 @@
 						AccessPath="[android.util.SparseBooleanArray: boolean[] data]"
 						AccessPathTypes="[boolean[]]" />
 					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -776,8 +776,8 @@
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -785,19 +785,21 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[android.os.Parcel: byte[] data]"
-						AccessPathTypes="[byte[]]" />
+					<to sourceSinkType="Field"
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
 		<method id="void writeStringList(java.util.List)">
 			<flows>
 				<flow isAlias="false">
-					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Field" BaseType="java.io.Serializable"
+					<from sourceSinkType="Parameter" ParameterIndex="0"
 						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
 						AccessPathTypes="[java.lang.Object[]]" />
+					<to sourceSinkType="Field" BaseType="android.os.Parcel"
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
@@ -805,8 +807,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
+					<to sourceSinkType="Field" BaseType="android.os.Parcel"
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
 						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
@@ -815,8 +817,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
+					<to sourceSinkType="Field" BaseType="android.os.Parcel"
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
 						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
@@ -825,8 +827,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
+					<to sourceSinkType="Field" BaseType="android.os.Parcel"
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
 						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
@@ -835,8 +837,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
+					<to sourceSinkType="Field" BaseType="android.os.Parcel"
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
 						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
@@ -845,8 +847,8 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
+					<to sourceSinkType="Field" BaseType="android.os.Parcel"
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
 						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
@@ -855,11 +857,21 @@
 			<flows>
 				<flow isAlias="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Field" BaseType="java.io.Serializable"
-						AccessPath="[java.util.Collection: java.lang.Object[] innerArray]"
+					<to sourceSinkType="Field" BaseType="android.os.Parcel"
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
 						AccessPathTypes="[java.lang.Object[]]" />
 				</flow>
 			</flows>
 		</method>
+		<method id="byte[] marshall()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="android.os.Parcel"
+						AccessPath="[android.os.Parcel: java.lang.Object[] data]"
+						AccessPathTypes="[java.lang.Object[]]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
 	</methods>
 </summary>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/summariesManual/android.text.format.Formatter.xml b/soot-infoflow-summaries/summariesManual/android.text.format.Formatter.xml
new file mode 100644
index 0000000..d991057
--- /dev/null
+++ b/soot-infoflow-summaries/summariesManual/android.text.format.Formatter.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<summary fileFormatVersion="101">
+	<methods>
+		<method id="java.lang.String formatFileSize(android.content.Context,long)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="1" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.lang.String formatIpAddress(long)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.lang.String formatShortFileSize(android.content.Context,long)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="1" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+	</methods>
+</summary>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.Boolean.xml b/soot-infoflow-summaries/summariesManual/java.lang.Boolean.xml
index 1f6c800..5030336 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.Boolean.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.Boolean.xml
@@ -58,17 +58,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Boolean: boolean value]"
-						AccessPathTypes="[boolean]" />
-				</flow>
-			</flows>
-		</method>
-		<method id="java.lang.Boolean valueOf(boolean)">
-			<flows>
-				<flow isAlias="false" typeChecking="false">
-					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Boolean: boolean value]"
-						AccessPathTypes="[boolean]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Boolean: java.lang.Boolean value]"
+						AccessPathTypes="[java.lang.Boolean]" />
 				</flow>
 			</flows>
 		</method>
@@ -76,8 +67,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Boolean: boolean value]"
-						AccessPathTypes="[boolean]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Boolean: java.lang.Boolean value]"
+						AccessPathTypes="[java.lang.Boolean]" />
 				</flow>
 			</flows>
 		</method>
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.Byte.xml b/soot-infoflow-summaries/summariesManual/java.lang.Byte.xml
index cf6f192..adb3499 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.Byte.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.Byte.xml
@@ -121,8 +121,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Byte: byte value]"
-						AccessPathTypes="[byte]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Byte: java.lang.Byte value]"
+						AccessPathTypes="[java.lang.Byte]" />
 				</flow>
 			</flows>
 		</method>
@@ -130,8 +130,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Byte: byte value]"
-						AccessPathTypes="[byte]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Byte: java.lang.Byte value]"
+						AccessPathTypes="[java.lang.Byte]" />
 				</flow>
 			</flows>
 		</method>
@@ -139,8 +139,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Byte: byte value]"
-						AccessPathTypes="[byte]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Byte: java.lang.Byte value]"
+						AccessPathTypes="[java.lang.Byte]" />
 				</flow>
 			</flows>
 		</method>
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.Double.xml b/soot-infoflow-summaries/summariesManual/java.lang.Double.xml
index b090043..8467727 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.Double.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.Double.xml
@@ -136,8 +136,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Double: double value]"
-						AccessPathTypes="[byte]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Double: java.lang.Double value]"
+						AccessPathTypes="[java.lang.Double]" />
 				</flow>
 			</flows>
 		</method>
@@ -145,8 +145,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Double: double value]"
-						AccessPathTypes="[double]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Double: java.lang.Double value]"
+						AccessPathTypes="[java.lang.Double]" />
 				</flow>
 			</flows>
 		</method>
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.Float.xml b/soot-infoflow-summaries/summariesManual/java.lang.Float.xml
index 0fcbeb0..c42190e 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.Float.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.Float.xml
@@ -145,8 +145,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Float: float value]"
-						AccessPathTypes="[float]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Float: java.lang.Float value]"
+						AccessPathTypes="[java.lang.Float]" />
 				</flow>
 			</flows>
 		</method>
@@ -154,8 +154,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Float: float value]"
-						AccessPathTypes="[float]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Float: java.lang.Float value]"
+						AccessPathTypes="[java.lang.Float]" />
 				</flow>
 			</flows>
 		</method>
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.Integer.xml b/soot-infoflow-summaries/summariesManual/java.lang.Integer.xml
index 5f5193b..2bb488e 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.Integer.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.Integer.xml
@@ -185,8 +185,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Integer: int value]"
-						AccessPathTypes="[int]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Integer: java.lang.Integer value]"
+						AccessPathTypes="[java.lang.Integer]" />
 				</flow>
 			</flows>
 		</method>
@@ -194,8 +194,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Integer: int value]"
-						AccessPathTypes="[int]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Integer: java.lang.Integer value]"
+						AccessPathTypes="[java.lang.Integer]" />
 				</flow>
 			</flows>
 		</method>
@@ -203,8 +203,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Integer: int value]"
-						AccessPathTypes="[int]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Integer: java.lang.Integer value]"
+						AccessPathTypes="[java.lang.Integer]" />
 				</flow>
 			</flows>
 		</method>
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.Long.xml b/soot-infoflow-summaries/summariesManual/java.lang.Long.xml
index 55b5736..2f40b81 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.Long.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.Long.xml
@@ -188,8 +188,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Long: long value]"
-						AccessPathTypes="[long]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Long: java.lang.Long value]"
+						AccessPathTypes="[java.lang.Long]" />
 				</flow>
 			</flows>
 		</method>
@@ -197,8 +197,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Long: long value]"
-						AccessPathTypes="[long]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Long: java.lang.Long value]"
+						AccessPathTypes="[java.lang.Long]" />
 				</flow>
 			</flows>
 		</method>
@@ -206,8 +206,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Long: long value]"
-						AccessPathTypes="[long]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Long: java.lang.Long value]"
+						AccessPathTypes="[java.lang.Long]" />
 				</flow>
 			</flows>
 		</method>
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.ProcessBuilder.xml b/soot-infoflow-summaries/summariesManual/java.lang.ProcessBuilder.xml
new file mode 100644
index 0000000..4e66bdb
--- /dev/null
+++ b/soot-infoflow-summaries/summariesManual/java.lang.ProcessBuilder.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" ?>
+<summary fileFormatVersion="101">
+	<methods>
+		<method id="void &lt;init&gt;(java.util.List)">
+			<flows>
+				<flow isAlias="true" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" AccessPath="[java.lang.ProcessBuilder: java.lang.Object value]"
+						AccessPathTypes="[java.lang.Object]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void &lt;init&gt;(java.lang.String[])">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" AccessPath="[java.lang.ProcessBuilder: java.lang.Object value]"
+						AccessPathTypes="[java.lang.Object]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.util.List command()">
+			<flows>
+				<flow isAlias="true" typeChecking="false">
+					<from sourceSinkType="Field" AccessPath="[java.lang.ProcessBuilder: java.lang.Object value]"
+						AccessPathTypes="[java.lang.Object]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.lang.ProcessBuilder command(java.lang.String[])>">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" AccessPath="[java.lang.ProcessBuilder: java.lang.Object value]"
+						AccessPathTypes="[java.lang.Object]" />
+				</flow>
+                                <flow isAlias="true" typeChecking="false">
+                                        <from sourceSinkType="Field" />
+                                        <to sourceSinkType="Return" />
+                                </flow>
+			</flows>
+		</method>
+		<method id="java.lang.ProcessBuilder command(java.util.List)>">
+			<flows>
+				<flow isAlias="true" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" AccessPath="[java.lang.ProcessBuilder: java.lang.Object value]"
+						AccessPathTypes="[java.lang.Object]" />
+				</flow>
+                                <flow isAlias="true" typeChecking="false">
+                                        <from sourceSinkType="Field" />
+                                        <to sourceSinkType="Return" />
+                                </flow>
+			</flows>
+		</method>
+  </methods>
+</summary>
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.Short.xml b/soot-infoflow-summaries/summariesManual/java.lang.Short.xml
index 370a39c..a99a585 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.Short.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.Short.xml
@@ -129,8 +129,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Short: short value]"
-						AccessPathTypes="[short]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Short: java.lang.Short value]"
+						AccessPathTypes="[java.lang.Short]" />
 				</flow>
 			</flows>
 		</method>
@@ -138,8 +138,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Short: short value]"
-						AccessPathTypes="[short]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Short: java.lang.Short value]"
+						AccessPathTypes="[java.lang.Short]" />
 				</flow>
 			</flows>
 		</method>
@@ -147,8 +147,8 @@
 			<flows>
 				<flow isAlias="false" typeChecking="false">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
-					<to sourceSinkType="Return" AccessPath="[java.lang.Short: short value]"
-						AccessPathTypes="[short]" />
+					<to sourceSinkType="Return" AccessPath="[java.lang.Short: java.lang.Short value]"
+						AccessPathTypes="[java.lang.Short]" />
 				</flow>
 			</flows>
 		</method>
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.String.xml b/soot-infoflow-summaries/summariesManual/java.lang.String.xml
index e785bfa..89eea00 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.String.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.String.xml
@@ -562,5 +562,6 @@
 				</flow>
 			</flows>
 		</method>
+		<method id="boolean equals(java.lang.Object)" isExcluded="true" />
 	</methods>
 </summary>
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.ref.PhantomReference.xml b/soot-infoflow-summaries/summariesManual/java.lang.ref.PhantomReference.xml
index b027e01..540b259 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.ref.PhantomReference.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.ref.PhantomReference.xml
@@ -3,7 +3,7 @@
 	<methods>
 		<method id="void &lt;init&gt;(java.lang.Object)">
 			<flows>
-				<flow isAlias="true" typeChecking="false">
+				<flow isAlias="true">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="java.lang.ref.Reference"
 						AccessPath="[java.lang.ref.Reference: java.lang.Object referent]"
@@ -13,7 +13,7 @@
 		</method>
 		<method id="void &lt;init&gt;(java.lang.Object,java.lang.ref.ReferenceQueue)">
 			<flows>
-				<flow isAlias="true" typeChecking="false">
+				<flow isAlias="true">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="java.lang.ref.Reference"
 						AccessPath="[java.lang.ref.Reference: java.lang.Object referent]"
@@ -23,7 +23,7 @@
 		</method>
 		<method id="java.lang.Object get()">
 			<flows>
-				<flow isAlias="true" typeChecking="false">
+				<flow isAlias="true">
 					<from sourceSinkType="Field" BaseType="java.lang.ref.Reference"
 						AccessPath="[java.lang.ref.Reference: java.lang.Object referent]"
 						AccessPathTypes="[java.lang.Object]" />
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.ref.SoftReference.xml b/soot-infoflow-summaries/summariesManual/java.lang.ref.SoftReference.xml
index b027e01..540b259 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.ref.SoftReference.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.ref.SoftReference.xml
@@ -3,7 +3,7 @@
 	<methods>
 		<method id="void &lt;init&gt;(java.lang.Object)">
 			<flows>
-				<flow isAlias="true" typeChecking="false">
+				<flow isAlias="true">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="java.lang.ref.Reference"
 						AccessPath="[java.lang.ref.Reference: java.lang.Object referent]"
@@ -13,7 +13,7 @@
 		</method>
 		<method id="void &lt;init&gt;(java.lang.Object,java.lang.ref.ReferenceQueue)">
 			<flows>
-				<flow isAlias="true" typeChecking="false">
+				<flow isAlias="true">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="java.lang.ref.Reference"
 						AccessPath="[java.lang.ref.Reference: java.lang.Object referent]"
@@ -23,7 +23,7 @@
 		</method>
 		<method id="java.lang.Object get()">
 			<flows>
-				<flow isAlias="true" typeChecking="false">
+				<flow isAlias="true">
 					<from sourceSinkType="Field" BaseType="java.lang.ref.Reference"
 						AccessPath="[java.lang.ref.Reference: java.lang.Object referent]"
 						AccessPathTypes="[java.lang.Object]" />
diff --git a/soot-infoflow-summaries/summariesManual/java.lang.ref.WeakReference.xml b/soot-infoflow-summaries/summariesManual/java.lang.ref.WeakReference.xml
index b027e01..540b259 100644
--- a/soot-infoflow-summaries/summariesManual/java.lang.ref.WeakReference.xml
+++ b/soot-infoflow-summaries/summariesManual/java.lang.ref.WeakReference.xml
@@ -3,7 +3,7 @@
 	<methods>
 		<method id="void &lt;init&gt;(java.lang.Object)">
 			<flows>
-				<flow isAlias="true" typeChecking="false">
+				<flow isAlias="true">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="java.lang.ref.Reference"
 						AccessPath="[java.lang.ref.Reference: java.lang.Object referent]"
@@ -13,7 +13,7 @@
 		</method>
 		<method id="void &lt;init&gt;(java.lang.Object,java.lang.ref.ReferenceQueue)">
 			<flows>
-				<flow isAlias="true" typeChecking="false">
+				<flow isAlias="true">
 					<from sourceSinkType="Parameter" ParameterIndex="0" />
 					<to sourceSinkType="Field" BaseType="java.lang.ref.Reference"
 						AccessPath="[java.lang.ref.Reference: java.lang.Object referent]"
@@ -23,7 +23,7 @@
 		</method>
 		<method id="java.lang.Object get()">
 			<flows>
-				<flow isAlias="true" typeChecking="false">
+				<flow isAlias="true">
 					<from sourceSinkType="Field" BaseType="java.lang.ref.Reference"
 						AccessPath="[java.lang.ref.Reference: java.lang.Object referent]"
 						AccessPathTypes="[java.lang.Object]" />
diff --git a/soot-infoflow-summaries/summariesManual/java.net.URLConnection.xml b/soot-infoflow-summaries/summariesManual/java.net.URLConnection.xml
index 9aa6357..74d47b9 100644
--- a/soot-infoflow-summaries/summariesManual/java.net.URLConnection.xml
+++ b/soot-infoflow-summaries/summariesManual/java.net.URLConnection.xml
@@ -202,6 +202,10 @@
 						AccessPathTypes="[java.net.URL]" />
 				</flow>
 			</flows>
+            <flow isAlias="true" typeChecking="false">
+                <from sourceSinkType="Field"/>
+                <to sourceSinkType="Return"/>
+            </flow>
 		</method>
 		<method id="int getReadTimeout()">
 			<flows>
diff --git a/soot-infoflow-summaries/summariesManual/javax.ejb.EntityBean.xml b/soot-infoflow-summaries/summariesManual/javax.ejb.EntityBean.xml
new file mode 100644
index 0000000..5dbc319
--- /dev/null
+++ b/soot-infoflow-summaries/summariesManual/javax.ejb.EntityBean.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<summary fileFormatVersion="103" isInterface="true">
+	<hierarchy>
+		<interface name="javax.ejb.EnterpriseBean" />
+	</hierarchy>
+</summary>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/summariesManual/javax.ejb.MessageDrivenBean.xml b/soot-infoflow-summaries/summariesManual/javax.ejb.MessageDrivenBean.xml
new file mode 100644
index 0000000..5dbc319
--- /dev/null
+++ b/soot-infoflow-summaries/summariesManual/javax.ejb.MessageDrivenBean.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<summary fileFormatVersion="103" isInterface="true">
+	<hierarchy>
+		<interface name="javax.ejb.EnterpriseBean" />
+	</hierarchy>
+</summary>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/summariesManual/javax.ejb.SessionBean.xml b/soot-infoflow-summaries/summariesManual/javax.ejb.SessionBean.xml
new file mode 100644
index 0000000..5dbc319
--- /dev/null
+++ b/soot-infoflow-summaries/summariesManual/javax.ejb.SessionBean.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<summary fileFormatVersion="103" isInterface="true">
+	<hierarchy>
+		<interface name="javax.ejb.EnterpriseBean" />
+	</hierarchy>
+</summary>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/summariesManual/javax.servlet.GenericServlet.xml b/soot-infoflow-summaries/summariesManual/javax.servlet.GenericServlet.xml
new file mode 100644
index 0000000..7c5964c
--- /dev/null
+++ b/soot-infoflow-summaries/summariesManual/javax.servlet.GenericServlet.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<summary fileFormatVersion="101">
+	<hierarchy superClass="java.lang.Object">
+		<interface name="java.io.Serializable" />
+		<interface name="javax.servlet.Servlet" />
+		<interface name="javax.servlet.ServletConfig" />
+	</hierarchy>
+</summary>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/summariesManual/javax.servlet.ServletConfig.xml b/soot-infoflow-summaries/summariesManual/javax.servlet.ServletConfig.xml
new file mode 100644
index 0000000..ac070dd
--- /dev/null
+++ b/soot-infoflow-summaries/summariesManual/javax.servlet.ServletConfig.xml
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<summary fileFormatVersion="103" isInterface="true">
+</summary>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/summariesManual/javax.servlet.http.HttpServlet.xml b/soot-infoflow-summaries/summariesManual/javax.servlet.http.HttpServlet.xml
new file mode 100644
index 0000000..b8f68e3
--- /dev/null
+++ b/soot-infoflow-summaries/summariesManual/javax.servlet.http.HttpServlet.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<summary fileFormatVersion="101">
+	<hierarchy superClass="javax.servlet.GenericServlet">
+	</hierarchy>
+</summary>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ApiTests.java b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ApiTests.java
index 32b8f1d..c12e704 100644
--- a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ApiTests.java
+++ b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ApiTests.java
@@ -562,6 +562,21 @@ public class ApiTests extends ApiTestHelper {
 				-1, null));
 	}
 
+	@Test(timeout = 100000)
+	public void transferNoStringThroughDataClass() {
+		String mSig = "<" + className
+				+ ": java.lang.String transferNoStringThroughDataClass(soot.jimple.infoflow.test.methodSummary.IGapClass,java.lang.String)>";
+		Set<MethodFlow> res = createSummaries(mSig).getAllFlows();
+
+		final String gapSig = makeGapClassSignature(
+				"soot.jimple.infoflow.test.methodSummary.Data dataThroughGap(soot.jimple.infoflow.test.methodSummary.Data)");
+
+		assertTrue(containsFlow(res, Parameter, 1, null, null, Parameter, 0, new String[] { DATACLASS_STRING_FIELD },
+				gapSig));
+		assertTrue(containsFlow(res, Return, -1, new String[] { DATACLASS_STRING_FIELD2 }, gapSig, Return, -1, null,
+				null));
+	}
+
 	@Test(timeout = 100000)
 	public void makeStringUserCodeClass() {
 		String mSig = "<" + className
diff --git a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/FieldToParaTests.java b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/FieldToParaTests.java
index 49b2e82..4e4a13d 100644
--- a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/FieldToParaTests.java
+++ b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/FieldToParaTests.java
@@ -220,7 +220,7 @@ public class FieldToParaTests extends TestHelper {
 
 	@Override
 	protected SummaryGenerator getSummary() {
-		SummaryGenerator sg = new SummaryGenerator();
+		SummaryGenerator sg = super.getSummary();
 		List<String> sub = new LinkedList<String>();
 		sub.add("java.util.ArrayList");
 		sg.setSubstitutedWith(sub);
diff --git a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/FieldToReturnTests.java b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/FieldToReturnTests.java
index 7803325..b8728b0 100644
--- a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/FieldToReturnTests.java
+++ b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/FieldToReturnTests.java
@@ -159,7 +159,7 @@ public class FieldToReturnTests extends TestHelper {
 
 	@Override
 	protected SummaryGenerator getSummary() {
-		SummaryGenerator sg = new SummaryGenerator();
+		SummaryGenerator sg = super.getSummary();
 		List<String> sub = new LinkedList<String>();
 		sub.add("java.util.LinkedList");
 		sg.setSubstitutedWith(sub);
diff --git a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/JDKTests.java b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/JDKTests.java
index 1aaed8a..676e2e5 100644
--- a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/JDKTests.java
+++ b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/JDKTests.java
@@ -10,7 +10,6 @@ import org.junit.Test;
 import soot.jimple.infoflow.methodSummary.data.summary.ClassSummaries;
 import soot.jimple.infoflow.methodSummary.data.summary.MethodFlow;
 import soot.jimple.infoflow.methodSummary.generator.SummaryGenerator;
-import soot.jimple.infoflow.methodSummary.generator.SummaryGeneratorFactory;
 
 public class JDKTests extends TestHelper {
 
@@ -44,10 +43,9 @@ public class JDKTests extends TestHelper {
 		Assert.assertNotNull(flow);
 	}
 
-	@Test(timeout = 100000)
+	@Test(timeout = 150000)
 	public void arrayListTest() {
-		SummaryGenerator generator = new SummaryGeneratorFactory().initSummaryGenerator();
-		ClassSummaries summaries = generator.createMethodSummaries(libPath,
+		ClassSummaries summaries = getSummary().createMethodSummaries(libPath,
 				Collections.singleton("java.util.ArrayList"));
 		Set<MethodFlow> flow = summaries.getAllFlows();
 		Assert.assertNotNull(flow);
@@ -69,8 +67,7 @@ public class JDKTests extends TestHelper {
 
 	@Test(timeout = 100000)
 	public void gapTest2() {
-		SummaryGenerator generator = new SummaryGeneratorFactory().initSummaryGenerator();
-		ClassSummaries summaries = generator.createMethodSummaries(libPath,
+		ClassSummaries summaries = getSummary().createMethodSummaries(libPath,
 				Collections.singleton("java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet"));
 		Set<MethodFlow> flow = summaries.getAllFlows();
 		Assert.assertNotNull(flow);
@@ -78,8 +75,7 @@ public class JDKTests extends TestHelper {
 
 	@Test(timeout = 300000)
 	public void gapTest3() {
-		SummaryGenerator generator = new SummaryGeneratorFactory().initSummaryGenerator();
-		ClassSummaries summaries = generator.createMethodSummaries(libPath,
+		ClassSummaries summaries = getSummary().createMethodSummaries(libPath,
 				Collections.singleton("java.util.HashMap$EntrySet"));
 		Set<MethodFlow> flow = summaries.getAllFlows();
 		Assert.assertNotNull(flow);
@@ -87,8 +83,7 @@ public class JDKTests extends TestHelper {
 
 	@Test(timeout = 300000)
 	public void gapTest4() {
-		SummaryGenerator generator = new SummaryGeneratorFactory().initSummaryGenerator();
-		ClassSummaries summaries = generator.createMethodSummaries(libPath,
+		ClassSummaries summaries = getSummary().createMethodSummaries(libPath,
 				Collections.singleton("java.util.concurrent.ConcurrentHashMap$Values"));
 		Set<MethodFlow> flow = summaries.getAllFlows();
 		Assert.assertNotNull(flow);
@@ -96,8 +91,7 @@ public class JDKTests extends TestHelper {
 
 	@Test(timeout = 300000)
 	public void gapTest5() {
-		SummaryGenerator generator = new SummaryGeneratorFactory().initSummaryGenerator();
-		ClassSummaries summaries = generator.createMethodSummaries(libPath,
+		ClassSummaries summaries = getSummary().createMethodSummaries(libPath,
 				Collections.singleton("java.lang.ProcessEnvironment$StringKeySet"));
 		Set<MethodFlow> flow = summaries.getAllFlows();
 		Assert.assertNotNull(flow);
@@ -105,8 +99,7 @@ public class JDKTests extends TestHelper {
 
 	@Test(timeout = 600000)
 	public void gapTest6() {
-		SummaryGenerator generator = new SummaryGeneratorFactory().initSummaryGenerator();
-		ClassSummaries summaries = generator.createMethodSummaries(libPath,
+		ClassSummaries summaries = getSummary().createMethodSummaries(libPath,
 				Collections.singleton("java.util.PriorityQueue"));
 		Set<MethodFlow> flow = summaries.getAllFlows();
 		Assert.assertNotNull(flow);
@@ -170,7 +163,7 @@ public class JDKTests extends TestHelper {
 
 	@Override
 	protected SummaryGenerator getSummary() {
-		SummaryGenerator sg = new SummaryGenerator();
+		SummaryGenerator sg = super.getSummary();
 		sg.getConfig().getAccessPathConfiguration().setAccessPathLength(4);
 		sg.getConfig().getAccessPathConfiguration().setUseRecursiveAccessPaths(true);
 		sg.getConfig().setLoadFullJAR(false);
diff --git a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToFieldTests.java b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToFieldTests.java
index 46b646d..accb7ed 100644
--- a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToFieldTests.java
+++ b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToFieldTests.java
@@ -194,7 +194,7 @@ public class ParaToFieldTests extends TestHelper {
 
 	@Override
 	protected SummaryGenerator getSummary() {
-		SummaryGenerator sg = new SummaryGenerator();
+		SummaryGenerator sg = super.getSummary();
 		List<String> sub = new LinkedList<String>();
 		sub.add("java.util.LinkedList");
 		sg.setSubstitutedWith(sub);
diff --git a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToParaTests.java b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToParaTests.java
index cc0743c..f5a8f43 100644
--- a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToParaTests.java
+++ b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToParaTests.java
@@ -92,7 +92,7 @@ public class ParaToParaTests extends TestHelper {
 
 	@Override
 	protected SummaryGenerator getSummary() {
-		SummaryGenerator sg = new SummaryGenerator();
+		SummaryGenerator sg = super.getSummary();
 		List<String> sub = new LinkedList<String>();
 		sub.add("java.util.LinkedList");
 		sg.setSubstitutedWith(sub);
diff --git a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToReturnTests.java b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToReturnTests.java
index 2c4d34f..178a410 100644
--- a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToReturnTests.java
+++ b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/ParaToReturnTests.java
@@ -118,7 +118,7 @@ public class ParaToReturnTests extends TestHelper {
 
 	@Override
 	protected SummaryGenerator getSummary() {
-		SummaryGenerator sg = new SummaryGenerator();
+		SummaryGenerator sg = super.getSummary();
 		List<String> sub = new LinkedList<String>();
 		sub.add("java.util.LinkedList");
 		sg.setSubstitutedWith(sub);
diff --git a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/SummaryTaintWrapperTests.java b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/SummaryTaintWrapperTests.java
index 2fbab40..7799aa1 100644
--- a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/SummaryTaintWrapperTests.java
+++ b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/SummaryTaintWrapperTests.java
@@ -125,7 +125,7 @@ public class SummaryTaintWrapperTests {
 		testFlowForMethod("<soot.jimple.infoflow.test.methodSummary.ApiClassClient: void apl3Flow()>");
 	}
 
-	@Test // (timeout = 30000)
+	@Test(timeout = 30000)
 	public void gapFlow1() {
 		testFlowForMethod("<soot.jimple.infoflow.test.methodSummary.ApiClassClient: void gapFlow1()>");
 	}
diff --git a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/TestHelper.java b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/TestHelper.java
index 5156154..f29aa45 100644
--- a/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/TestHelper.java
+++ b/soot-infoflow-summaries/test/soot/jimple/infoflow/test/methodSummary/junit/TestHelper.java
@@ -43,6 +43,8 @@ public abstract class TestHelper {
 	protected final static String LINKEDLIST_LAST = "<java.util.LinkedList: java.util.LinkedList$Node last>";
 	protected final static String LINKEDLIST_ITEM = "<java.util.LinkedList$Node: java.lang.Object item>";
 
+	protected static final String GAPCLASS_SIG = "soot.jimple.infoflow.test.methodSummary.IGapClass";
+
 	@BeforeClass
 	public static void setUp() throws IOException {
 		final String sep = System.getProperty("path.separator");
@@ -196,10 +198,10 @@ public abstract class TestHelper {
 		if (!s.hasAccessPath() && fields != null && fields.length > 0)
 			return false;
 
-		if (s.getAccessPath().length != fields.length)
+		if (s.getAccessPath().length() != fields.length)
 			return false;
 		for (int i = 0; i < fields.length; i++) {
-			if (!s.getAccessPath()[i].replaceAll("[<>]", "").equals(fields[i].replaceAll("[<>]", "")))
+			if (!s.getAccessPath().getField(i).replaceAll("[<>]", "").equals(fields[i].replaceAll("[<>]", "")))
 				return false;
 		}
 
@@ -212,7 +214,11 @@ public abstract class TestHelper {
 	 * 
 	 * @return The {@link SummaryGenerator} instance
 	 */
-	protected abstract SummaryGenerator getSummary();
+	protected SummaryGenerator getSummary() {
+		SummaryGenerator sg = new SummaryGenerator();
+		sg.getConfig().setUseDefaultSummaries(false);
+		return sg;
+	}
 
 	/**
 	 * Gets the classpath to use for creating summaries
@@ -234,4 +240,15 @@ public abstract class TestHelper {
 		return getSummary().createMethodSummary(getClasspath(), methodSignature);
 	}
 
+	/**
+	 * Converts the given method subsignature into a full method signature under the
+	 * assumption that the given method is part of the gap class.
+	 * 
+	 * @param subsignature The method subsignature
+	 * @return The full method signature
+	 */
+	protected String makeGapClassSignature(String subsignature) {
+		return String.format("<%s: %s>", GAPCLASS_SIG, subsignature);
+	}
+
 }
diff --git a/soot-infoflow-summaries/testSummaries/java.util.ArrayList.xml b/soot-infoflow-summaries/testSummaries/java.util.ArrayList.xml
index 5bab62c..0785614 100644
--- a/soot-infoflow-summaries/testSummaries/java.util.ArrayList.xml
+++ b/soot-infoflow-summaries/testSummaries/java.util.ArrayList.xml
@@ -1 +1,402 @@
-<?xml version="1.0" ?><summary fileFormatVersion="101"><methods><method id="boolean add(java.lang.Object)"><flows><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow></flows></method><method id="java.util.List subList(int,int)"><flows><flow isAlias="false"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="1" BaseType="int"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: int parentOffset&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: int offset&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: java.util.AbstractList parent&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to></flow></flows></method><method id="int lastIndexOf(java.lang.Object)"><flows><flow isAlias="false"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Return" BaseType="int" taintSubFields="true"></to></flow></flows></method><method id="boolean addAll(java.util.Collection)"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow></flows></method><method id="java.lang.Object[] toArray()"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Return" BaseType="java.lang.Object[]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Return" BaseType="java.lang.Object[]" taintSubFields="true"></to></flow></flows></method><method id="boolean equals(java.lang.Object)"><flows><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object"></from><to sourceSinkType="GapBaseObject" BaseType="java.lang.Object" gap="10"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ListIterator" gap="13"></from><to sourceSinkType="GapBaseObject" BaseType="java.util.ListIterator" gap="11"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ListIterator" gap="11"></from><to sourceSinkType="GapBaseObject" BaseType="java.util.ListIterator" gap="13"></to></flow><flow isAlias="true"><from sourceSinkType="Return" BaseType="java.lang.Object" gap="13"></from><to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="14" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.lang.Object" gap="14"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.List" gap="10"></from><to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.List" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Return" BaseType="java.util.ListIterator" gap="10"></from><to sourceSinkType="GapBaseObject" BaseType="java.util.ListIterator" gap="11"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="GapBaseObject" BaseType="java.lang.Object" gap="14"></to></flow></flows></method><method id="java.lang.Object get(int)"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Return" BaseType="java.lang.Object" taintSubFields="true"></to></flow></flows></method><method id="void &lt;init&gt;(java.util.Collection)"><flows><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow></flows></method><method id="void removeRange(int,int)"><flows><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="1" BaseType="int"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow></flows></method><method id="void add(int,java.lang.Object)"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="1" BaseType="java.lang.Object"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow></flows></method><method id="java.lang.Object set(int,java.lang.Object)"><flows><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="1" BaseType="java.lang.Object"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="1" BaseType="java.lang.Object"></from><to sourceSinkType="Return" BaseType="java.lang.Object" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Return" BaseType="java.lang.Object" taintSubFields="true"></to></flow></flows></method><method id="java.lang.Object remove(int)"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Return" BaseType="java.lang.Object" taintSubFields="true"></to></flow></flows></method><method id="java.util.ListIterator listIterator(int)"><flows><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$ListItr" AccessPath="[&lt;java.util.ArrayList$Itr: int cursor&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: int expectedModCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$ListItr" AccessPath="[&lt;java.util.ArrayList$ListItr: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to></flow></flows></method><method id="boolean removeAll(java.util.Collection)"><flows><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="8"></from><to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="8" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="GapBaseObject" BaseType="java.lang.Object" gap="8"></to></flow><flow isAlias="false"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.lang.Object" gap="8"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow></flows></method><method id="boolean retainAll(java.util.Collection)"><flows><flow isAlias="false"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="9" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="9"></from><to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.lang.Object" gap="9"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="GapBaseObject" BaseType="java.lang.Object" gap="9"></to></flow></flows></method><method id="java.util.ListIterator listIterator()"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$ListItr" AccessPath="[&lt;java.util.ArrayList$ListItr: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: int expectedModCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to></flow></flows></method><method id="int size()"><flows><flow isAlias="false"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Return" BaseType="int" taintSubFields="true"></to></flow></flows></method><method id="java.lang.String toString()"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;, &lt;java.lang.String: char[] value&gt;]" AccessPathTypes="[java.lang.Object[], char[]]"></from><to sourceSinkType="Return" BaseType="java.lang.String" AccessPath="[&lt;java.lang.String: char[] value&gt;]" AccessPathTypes="[char[]]" taintSubFields="true"></to></flow></flows></method><method id="java.util.Iterator iterator()"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to></flow><flow isAlias="false"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: int expectedModCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow></flows></method><method id="java.lang.Object[] toArray(java.lang.Object[])"><flows><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object[]"></from><to sourceSinkType="Return" BaseType="java.lang.Object[]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Return" BaseType="java.lang.Object[]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Return" BaseType="java.lang.Object[]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object[]" taintSubFields="true"></to></flow></flows></method><method id="void trimToSize()"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow></flows></method><method id="void ensureCapacity(int)"><flows><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow></flows></method><method id="boolean addAll(int,java.util.Collection)"><flows><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="1" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="1" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow></flows></method><method id="java.lang.Object clone()"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from><to sourceSinkType="Return" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow></flows></method><method id="boolean containsAll(java.util.Collection)"><flows><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="GapBaseObject" BaseType="java.lang.Object" gap="15"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from><to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="15" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="15"></from><to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow><flow isAlias="true"><from sourceSinkType="Field" BaseType="java.lang.Object" gap="15"></from><to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to></flow></flows></method></methods><gaps><gap num="13" id="&lt;java.util.ListIterator: java.lang.Object next()&gt;"></gap><gap num="8" id="&lt;java.lang.Object: boolean equals(java.lang.Object)&gt;"></gap><gap num="9" id="&lt;java.lang.Object: boolean equals(java.lang.Object)&gt;"></gap><gap num="10" id="&lt;java.util.List: java.util.ListIterator listIterator()&gt;"></gap><gap num="15" id="&lt;java.lang.Object: boolean equals(java.lang.Object)&gt;"></gap><gap num="14" id="&lt;java.lang.Object: boolean equals(java.lang.Object)&gt;"></gap><gap num="11" id="&lt;java.util.ListIterator: boolean hasNext()&gt;"></gap></gaps></summary>
\ No newline at end of file
+<?xml version="1.0" ?>
+<summary fileFormatVersion="101">
+    <methods>
+        <method id="boolean add(java.lang.Object)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.util.List subList(int,int)">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="1" BaseType="int"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: int parentOffset&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: int offset&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$SubList" AccessPath="[&lt;java.util.ArrayList$SubList: java.util.AbstractList parent&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="int lastIndexOf(java.lang.Object)">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Return" BaseType="int" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="boolean addAll(java.util.Collection)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.lang.Object[] toArray()">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.Object[]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.Object[]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="boolean equals(java.lang.Object)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object"></from>
+                    <to sourceSinkType="GapBaseObject" BaseType="java.lang.Object" gap="10"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ListIterator" gap="13"></from>
+                    <to sourceSinkType="GapBaseObject" BaseType="java.util.ListIterator" gap="11"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ListIterator" gap="11"></from>
+                    <to sourceSinkType="GapBaseObject" BaseType="java.util.ListIterator" gap="13"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Return" BaseType="java.lang.Object" gap="13"></from>
+                    <to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="14" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.lang.Object" gap="14"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.List" gap="10"></from>
+                    <to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.List" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Return" BaseType="java.util.ListIterator" gap="10"></from>
+                    <to sourceSinkType="GapBaseObject" BaseType="java.util.ListIterator" gap="11"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="GapBaseObject" BaseType="java.lang.Object" gap="14"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.lang.Object get(int)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.Object" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="void &lt;init&gt;(java.util.Collection)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="void removeRange(int,int)">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="1" BaseType="int"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="void add(int,java.lang.Object)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="1" BaseType="java.lang.Object"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.lang.Object set(int,java.lang.Object)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="1" BaseType="java.lang.Object"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="1" BaseType="java.lang.Object"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.Object" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.Object" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.lang.Object remove(int)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.Object" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.util.ListIterator listIterator(int)">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$ListItr" AccessPath="[&lt;java.util.ArrayList$Itr: int cursor&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: int expectedModCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$ListItr" AccessPath="[&lt;java.util.ArrayList$ListItr: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="boolean removeAll(java.util.Collection)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="8"></from>
+                    <to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="8" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="GapBaseObject" BaseType="java.lang.Object" gap="8"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.lang.Object" gap="8"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="boolean retainAll(java.util.Collection)">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="9" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="9"></from>
+                    <to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.lang.Object" gap="9"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="GapBaseObject" BaseType="java.lang.Object" gap="9"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.util.ListIterator listIterator()">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$ListItr" AccessPath="[&lt;java.util.ArrayList$ListItr: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: int expectedModCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="int size()">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Return" BaseType="int" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.lang.String toString()">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;, &lt;java.lang.String: char[] value&gt;]" AccessPathTypes="[java.lang.Object[], char[]]"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.String" AccessPath="[&lt;java.lang.String: char[] value&gt;]" AccessPathTypes="[char[]]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.util.Iterator iterator()">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: java.util.ArrayList this$0&gt;]" AccessPathTypes="[java.util.ArrayList]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="false">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.AbstractList: int modCount&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList$Itr" AccessPath="[&lt;java.util.ArrayList$Itr: int expectedModCount&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.lang.Object[] toArray(java.lang.Object[])">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object[]"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.Object[]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.Object[]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.Object[]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object[]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="void trimToSize()">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="void ensureCapacity(int)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="int"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="boolean addAll(int,java.util.Collection)">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="1" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="1" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.lang.Object clone()">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: int size&gt;]" AccessPathTypes="[int]"></from>
+                    <to sourceSinkType="Return" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="boolean containsAll(java.util.Collection)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="GapBaseObject" BaseType="java.lang.Object" gap="15"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]"></from>
+                    <to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="15" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.Object" gap="15"></from>
+                    <to sourceSinkType="Field" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="java.lang.Object" gap="15"></from>
+                    <to sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.util.ArrayList" AccessPath="[&lt;java.util.ArrayList: java.lang.Object[] elementData&gt;]" AccessPathTypes="[java.lang.Object[]]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+    </methods>
+    <gaps>
+        <gap num="13" id="&lt;java.util.ListIterator: java.lang.Object next()&gt;"></gap>
+        <gap num="8" id="&lt;java.lang.Object: boolean equals(java.lang.Object)&gt;"></gap>
+        <gap num="9" id="&lt;java.lang.Object: boolean equals(java.lang.Object)&gt;"></gap>
+        <gap num="10" id="&lt;java.util.List: java.util.ListIterator listIterator()&gt;"></gap>
+        <gap num="15" id="&lt;java.lang.Object: boolean equals(java.lang.Object)&gt;"></gap>
+        <gap num="14" id="&lt;java.lang.Object: boolean equals(java.lang.Object)&gt;"></gap>
+        <gap num="11" id="&lt;java.util.ListIterator: boolean hasNext()&gt;"></gap>
+    </gaps>
+</summary>
\ No newline at end of file
diff --git a/soot-infoflow-summaries/testSummaries/soot.jimple.infoflow.test.methodSummary.GapClass.xml b/soot-infoflow-summaries/testSummaries/soot.jimple.infoflow.test.methodSummary.GapClass.xml
index f9f063c..ff7b383 100644
--- a/soot-infoflow-summaries/testSummaries/soot.jimple.infoflow.test.methodSummary.GapClass.xml
+++ b/soot-infoflow-summaries/testSummaries/soot.jimple.infoflow.test.methodSummary.GapClass.xml
@@ -1 +1,62 @@
-<?xml version="1.0" ?><summary fileFormatVersion="101"><methods><method id="java.lang.String retrieveString()"><flows><flow isAlias="false"><from sourceSinkType="Field" BaseType="soot.jimple.infoflow.test.methodSummary.GapClass" AccessPath="[&lt;soot.jimple.infoflow.test.methodSummary.GapClass: java.lang.String stringField&gt;]" AccessPathTypes="[java.lang.String]"></from><to sourceSinkType="Return" BaseType="java.lang.String" taintSubFields="true"></to></flow></flows></method><method id="void storeData(soot.jimple.infoflow.test.methodSummary.Data)"><flows><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="soot.jimple.infoflow.test.methodSummary.Data"></from><to sourceSinkType="Field" BaseType="soot.jimple.infoflow.test.methodSummary.GapClass" AccessPath="[&lt;soot.jimple.infoflow.test.methodSummary.GapClass: soot.jimple.infoflow.test.methodSummary.Data dataField&gt;]" AccessPathTypes="[soot.jimple.infoflow.test.methodSummary.Data]" taintSubFields="true"></to></flow></flows></method><method id="void fillDataString(java.lang.String,soot.jimple.infoflow.test.methodSummary.Data)"><flows><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.String"></from><to sourceSinkType="Parameter" ParameterIndex="1" BaseType="soot.jimple.infoflow.test.methodSummary.Data" AccessPath="[&lt;soot.jimple.infoflow.test.methodSummary.Data: java.lang.String stringField&gt;]" AccessPathTypes="[java.lang.String]" taintSubFields="true"></to></flow></flows></method><method id="soot.jimple.infoflow.test.methodSummary.Data dataThroughGap(soot.jimple.infoflow.test.methodSummary.Data)"><flows><flow isAlias="true"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="soot.jimple.infoflow.test.methodSummary.Data"></from><to sourceSinkType="Return" BaseType="soot.jimple.infoflow.test.methodSummary.Data" taintSubFields="true"></to></flow></flows></method><method id="java.lang.String callTheGap(java.lang.String)"><flows><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.String"></from><to sourceSinkType="Return" BaseType="java.lang.String" taintSubFields="true"></to></flow></flows></method><method id="void storeString(java.lang.String)"><flows><flow isAlias="false"><from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.String"></from><to sourceSinkType="Field" BaseType="soot.jimple.infoflow.test.methodSummary.GapClass" AccessPath="[&lt;soot.jimple.infoflow.test.methodSummary.GapClass: java.lang.String stringField&gt;]" AccessPathTypes="[java.lang.String]" taintSubFields="true"></to></flow></flows></method><method id="soot.jimple.infoflow.test.methodSummary.Data retrieveData()"><flows><flow isAlias="true"><from sourceSinkType="Field" BaseType="soot.jimple.infoflow.test.methodSummary.GapClass" AccessPath="[&lt;soot.jimple.infoflow.test.methodSummary.GapClass: soot.jimple.infoflow.test.methodSummary.Data dataField&gt;]" AccessPathTypes="[soot.jimple.infoflow.test.methodSummary.Data]"></from><to sourceSinkType="Return" BaseType="soot.jimple.infoflow.test.methodSummary.Data" taintSubFields="true"></to></flow></flows></method></methods><gaps></gaps></summary>
\ No newline at end of file
+<?xml version="1.0" ?>
+<summary fileFormatVersion="101">
+    <methods>
+        <method id="java.lang.String retrieveString()">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Field" BaseType="soot.jimple.infoflow.test.methodSummary.GapClass" AccessPath="[&lt;soot.jimple.infoflow.test.methodSummary.GapClass: java.lang.String stringField&gt;]" AccessPathTypes="[java.lang.String]"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.String" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="void storeData(soot.jimple.infoflow.test.methodSummary.Data)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="soot.jimple.infoflow.test.methodSummary.Data"></from>
+                    <to sourceSinkType="Field" BaseType="soot.jimple.infoflow.test.methodSummary.GapClass" AccessPath="[&lt;soot.jimple.infoflow.test.methodSummary.GapClass: soot.jimple.infoflow.test.methodSummary.Data dataField&gt;]" AccessPathTypes="[soot.jimple.infoflow.test.methodSummary.Data]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="void fillDataString(java.lang.String,soot.jimple.infoflow.test.methodSummary.Data)">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.String"></from>
+                    <to sourceSinkType="Parameter" ParameterIndex="1" BaseType="soot.jimple.infoflow.test.methodSummary.Data" AccessPath="[&lt;soot.jimple.infoflow.test.methodSummary.Data: java.lang.String stringField&gt;]" AccessPathTypes="[java.lang.String]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="soot.jimple.infoflow.test.methodSummary.Data dataThroughGap(soot.jimple.infoflow.test.methodSummary.Data)">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="soot.jimple.infoflow.test.methodSummary.Data"></from>
+                    <to sourceSinkType="Return" BaseType="soot.jimple.infoflow.test.methodSummary.Data" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="java.lang.String callTheGap(java.lang.String)">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.String"></from>
+                    <to sourceSinkType="Return" BaseType="java.lang.String" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="void storeString(java.lang.String)">
+            <flows>
+                <flow isAlias="false">
+                    <from sourceSinkType="Parameter" ParameterIndex="0" BaseType="java.lang.String"></from>
+                    <to sourceSinkType="Field" BaseType="soot.jimple.infoflow.test.methodSummary.GapClass" AccessPath="[&lt;soot.jimple.infoflow.test.methodSummary.GapClass: java.lang.String stringField&gt;]" AccessPathTypes="[java.lang.String]" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+        <method id="soot.jimple.infoflow.test.methodSummary.Data retrieveData()">
+            <flows>
+                <flow isAlias="true">
+                    <from sourceSinkType="Field" BaseType="soot.jimple.infoflow.test.methodSummary.GapClass" AccessPath="[&lt;soot.jimple.infoflow.test.methodSummary.GapClass: soot.jimple.infoflow.test.methodSummary.Data dataField&gt;]" AccessPathTypes="[soot.jimple.infoflow.test.methodSummary.Data]"></from>
+                    <to sourceSinkType="Return" BaseType="soot.jimple.infoflow.test.methodSummary.Data" taintSubFields="true"></to>
+                </flow>
+            </flows>
+        </method>
+    </methods>
+    <gaps></gaps>
+</summary>
\ No newline at end of file
diff --git a/soot-infoflow/.classpath b/soot-infoflow/.classpath
index 0e55320..a936c9c 100644
--- a/soot-infoflow/.classpath
+++ b/soot-infoflow/.classpath
@@ -1,9 +1,23 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="test"/>
-	<classpathentry kind="src" path="securiBench"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" output="build/classes" path="src">
+		<attributes>
+			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" output="build/testclasses" path="test">
+		<attributes>
+			<attribute name="test" value="true"/>
+			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
 	<classpathentry combineaccessrules="false" kind="src" path="/soot"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/heros"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
@@ -14,5 +28,5 @@
 	</classpathentry>
 	<classpathentry kind="lib" path="lib/cos.jar"/>
 	<classpathentry kind="lib" path="lib/j2ee.jar"/>
-	<classpathentry kind="output" path="bin"/>
+	<classpathentry kind="output" path="build/classes"/>
 </classpath>
diff --git a/soot-infoflow/.settings/org.eclipse.core.resources.prefs b/soot-infoflow/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..104c8ec
--- /dev/null
+++ b/soot-infoflow/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,4 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
+encoding/src=UTF-8
+encoding/test=UTF-8
diff --git a/soot-infoflow/.settings/org.eclipse.jdt.core.prefs b/soot-infoflow/.settings/org.eclipse.jdt.core.prefs
index dde12a6..94e5100 100644
--- a/soot-infoflow/.settings/org.eclipse.jdt.core.prefs
+++ b/soot-infoflow/.settings/org.eclipse.jdt.core.prefs
@@ -78,4 +78,5 @@ org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disa
 org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
 org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
+org.eclipse.jdt.core.compiler.release=disabled
 org.eclipse.jdt.core.compiler.source=1.8
diff --git a/soot-infoflow/META-INF/MANIFEST.MF b/soot-infoflow/META-INF/MANIFEST.MF
index e1c62bc..382e329 100644
--- a/soot-infoflow/META-INF/MANIFEST.MF
+++ b/soot-infoflow/META-INF/MANIFEST.MF
@@ -5,4 +5,4 @@ Bundle-SymbolicName: soot-infoflow
 Bundle-Version: 1.0.0.qualifier
 Bundle-ClassPath: soot-infoflow.jar
 Require-Bundle: org.junit
-Bundle-RequiredExecutionEnvironment: JavaSE-1.7
+Bundle-RequiredExecutionEnvironment: JavaSE-1.8
diff --git a/soot-infoflow/pom.xml b/soot-infoflow/pom.xml
index 3f2d241..44f86f5 100644
--- a/soot-infoflow/pom.xml
+++ b/soot-infoflow/pom.xml
@@ -1,266 +1,287 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-    <groupId>de.tud.sse</groupId>
-    <artifactId>soot-infoflow</artifactId>
-    <name>soot-infoflow</name>
-    <version>2.7.2-SNAPSHOT</version>
-    <description>Soot extending data flow tracking components for Java</description>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+	<modelVersion>4.0.0</modelVersion>
+	<groupId>de.tud.sse</groupId>
+	<artifactId>soot-infoflow</artifactId>
+	<name>soot-infoflow</name>
+	<version>2.7.3-SNAPSHOT</version>
+	<description>Soot extending data flow tracking components for Java</description>
     <packaging>jar</packaging>
-    <url>https://github.com/secure-software-engineering/FlowDroid</url>
-    <organization>
-        <name>Fraunhofer SIT</name>
-        <url>https://www.sit.fraunhofer.de/</url>
-    </organization>
-    <licenses>
-        <license>
-            <name>GNU LESSER GENERAL PUBLIC LICENSE 2.1</name>
-            <url>https://www.gnu.org/licenses/lgpl-2.1.txt</url>
-            <distribution>repo</distribution>
-        </license>
-    </licenses>
-    <developers>
-        <developer>
-            <name>Steven Arzt</name>
-            <email>steven.arzt@sit.fraunhofer.de</email>
-            <organization>Fraunhofer SIT</organization>
-            <organizationUrl>https://www.sit.fraunhofer.de/en/</organizationUrl>
-        </developer>
-    </developers>
-    <scm>
-        <connection>scm:git:git@github.com:secure-software-engineering/FlowDroid.git</connection>
-        <developerConnection>scm:git:git@github.com:secure-software-engineering/FlowDroid.git</developerConnection>
-        <url>https://github.com/secure-software-engineering/FlowDroid/tree/develop</url>
-    </scm>
+	<url>https://github.com/secure-software-engineering/FlowDroid</url>
 
+	<organization>
+		<name>Fraunhofer SIT</name>
+		<url>https://www.sit.fraunhofer.de/</url>
+	</organization>
 
-    <properties>
-        <maven.compiler.source>1.8</maven.compiler.source>
-        <maven.compiler.target>1.8</maven.compiler.target>
-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-        <maven-gpg-plugin.version>1.6</maven-gpg-plugin.version>
-        <maven-nexus-staging-plugin.version>1.6.8</maven-nexus-staging-plugin.version>
-        <maven-source-plugin.version>3.0.1</maven-source-plugin.version>
-        <maven-javadoc-plugin.version>3.0.0</maven-javadoc-plugin.version>
-        <maven-jar-plugin.version>3.0.2</maven-jar-plugin.version>
-        <maven-surefire-plugin.version>2.20.1</maven-surefire-plugin.version>
-        <maven-assembly-plugin.version>3.1.0</maven-assembly-plugin.version>
-    </properties>
+	<licenses>
+		<license>
+			<name>GNU LESSER GENERAL PUBLIC LICENSE 2.1</name>
+			<url>https://www.gnu.org/licenses/lgpl-2.1.txt</url>
+			<distribution>repo</distribution>
+		</license>
+	</licenses>
 
-    <build>
-        <finalName>soot-infoflow-classes</finalName>
-        <sourceDirectory>src</sourceDirectory>
-        <testSourceDirectory>test</testSourceDirectory>
-        <outputDirectory>build/classes</outputDirectory>
-        <testOutputDirectory>build/testclasses</testOutputDirectory>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.2</version>
-            </plugin>
+	<developers>
+		<developer>
+			<name>Steven Arzt</name>
+			<email>steven.arzt@sit.fraunhofer.de</email>
+			<organization>Fraunhofer SIT</organization>
+			<organizationUrl>https://www.sit.fraunhofer.de/en/</organizationUrl>
+		</developer>
+	</developers>
 
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-surefire-plugin</artifactId>
-                <version>${maven-surefire-plugin.version}</version>
-                <configuration>
-                    <includes>
-                        <include>soot/jimple/infoflow/test/junit/**</include>
-                    </includes>
-                </configuration>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-assembly-plugin</artifactId>
-                <version>${maven-assembly-plugin.version}</version>
-                <configuration>
-                    <descriptorRefs>
-                        <descriptorRef>jar-with-dependencies</descriptorRef>
-                    </descriptorRefs>
-                    <finalName>soot-infoflow-trunk</finalName>
-                    <appendAssemblyId>false</appendAssemblyId>
-                </configuration>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-jar-plugin</artifactId>
-                <version>${maven-jar-plugin.version}</version>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>test-jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-source-plugin</artifactId>
-                <version>${maven-source-plugin.version}</version>
-            </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-javadoc-plugin</artifactId>
-                <version>${maven-javadoc-plugin.version}</version>
-                <configuration>
-                    <failOnError>false</failOnError>
-                </configuration>
-            </plugin>
-        </plugins>
+	<scm>
+		<connection>scm:git:git@github.com:secure-software-engineering/FlowDroid.git</connection>
+		<developerConnection>scm:git:git@github.com:secure-software-engineering/FlowDroid.git</developerConnection>
+		<url>https://github.com/secure-software-engineering/FlowDroid/tree/develop</url>
+	</scm>
 
-        <resources>
-            <resource>
-                <directory>.</directory>
-                <includes>
-                    <include>EasyTaintWrapperSource.txt</include>
-                </includes>
-            </resource>
-        </resources>
-    </build>
 
-    <dependencies>
-        <dependency>
-            <groupId>de.upb.cs.swt</groupId>
-            <artifactId>heros</artifactId>
-            <version>1.1.0</version>
-        </dependency>
-        <dependency>
-            <groupId>ca.mcgill.sable</groupId>
-            <artifactId>soot</artifactId>
-            <version>3.3.0</version>
-        </dependency>
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <version>4.12</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.hamcrest</groupId>
-            <artifactId>hamcrest-core</artifactId>
-            <version>1.3</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>javax.servlet</groupId>
-            <artifactId>javax.servlet-api</artifactId>
-            <version>3.0.1</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>net.sf.trove4j</groupId>
-            <artifactId>trove4j</artifactId>
-            <version>3.0.3</version>
-        </dependency>
-        <dependency>
-            <groupId>com.google.guava</groupId>
-            <artifactId>guava</artifactId>
-            <version>25.1-jre</version>
-        </dependency>
-    </dependencies>
+	<properties>
+		<maven.compiler.source>1.8</maven.compiler.source>
+		<maven.compiler.target>1.8</maven.compiler.target>
+		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+		<maven-gpg-plugin.version>1.6</maven-gpg-plugin.version>
+		<maven-nexus-staging-plugin.version>1.6.8</maven-nexus-staging-plugin.version>
+		<maven-source-plugin.version>3.0.1</maven-source-plugin.version>
+		<maven-javadoc-plugin.version>3.0.0</maven-javadoc-plugin.version>
+		<maven-jar-plugin.version>3.0.2</maven-jar-plugin.version>
+		<maven-surefire-plugin.version>2.20.1</maven-surefire-plugin.version>
+		<maven-assembly-plugin.version>3.1.0</maven-assembly-plugin.version>
+	</properties>
 
-    <repositories>
-        <repository>
-            <id>sonatype-snapshot</id>
-            <url>https://oss.sonatype.org/content/repositories/snapshots</url>
-            <releases>
-                <enabled>false</enabled>
-            </releases>
-            <snapshots>
-                <enabled>true</enabled>
-            </snapshots>
-        </repository>
-    </repositories>
-    <distributionManagement>
-        <snapshotRepository>
-            <id>ossrh</id>
-            <url>https://oss.sonatype.org/content/repositories/snapshots</url>
-        </snapshotRepository>
-    </distributionManagement>
-    <profiles>
-        <profile>
-            <id>deploy</id>
-            <activation>
-                <property>
-                    <name>deploy</name>
-                    <value>true</value>
-                </property>
-            </activation>
-            <build>
-                <plugins>
-                    <plugin>
-                        <groupId>org.sonatype.plugins</groupId>
-                        <artifactId>nexus-staging-maven-plugin</artifactId>
-                        <version>${maven-nexus-staging-plugin.version}</version>
-                        <extensions>true</extensions>
-                        <configuration>
-                            <serverId>ossrh</serverId>
-                            <nexusUrl>https://oss.sonatype.org/</nexusUrl>
-                            <autoReleaseAfterClose>true</autoReleaseAfterClose>
-                        </configuration>
-                    </plugin>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-gpg-plugin</artifactId>
-                        <version>${maven-gpg-plugin.version}</version>
-                        <executions>
-                            <execution>
-                                <id>sign-artifacts</id>
-                                <phase>verify</phase>
-                                <goals>
-                                    <goal>sign</goal>
-                                </goals>
-                                <configuration>
-                                    <!-- This is necessary for gpg to not try to use the pinentry programs -->
-                                    <gpgArguments>
-                                        <arg>--pinentry-mode</arg>
-                                        <arg>loopback</arg>
-                                    </gpgArguments>
-                                </configuration>
-                            </execution>
-                        </executions>
-                    </plugin>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-source-plugin</artifactId>
-                        <executions>
-                            <execution>
-                                <id>attach-sources</id>
-                                <goals>
-                                    <goal>jar</goal>
-                                </goals>
-                            </execution>
-                        </executions>
-                    </plugin>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-javadoc-plugin</artifactId>
-                        <executions>
-                            <execution>
-                                <id>attach-javadocs</id>
-                                <goals>
-                                    <goal>jar</goal>
-                                </goals>
-                            </execution>
-                        </executions>
-                    </plugin>
-                    <plugin>
-                        <groupId>org.apache.maven.plugins</groupId>
-                        <artifactId>maven-assembly-plugin</artifactId>
-                        <executions>
-                            <execution>
-                                <id>simple-command</id>
-                                <phase>package</phase>
-                                <goals>
-                                    <goal>single</goal>
-                                </goals>
+	<build>
+		<finalName>soot-infoflow-classes</finalName>
+		<sourceDirectory>src</sourceDirectory>
+		<testSourceDirectory>test</testSourceDirectory>
+		<outputDirectory>build/classes</outputDirectory>
+		<testOutputDirectory>build/testclasses</testOutputDirectory>
+		<plugins>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-compiler-plugin</artifactId>
+				<version>3.2</version>
+			</plugin>
+
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-surefire-plugin</artifactId>
+				<version>${maven-surefire-plugin.version}</version>
+				<configuration>
+					<includes>
+						<include>soot/jimple/infoflow/test/junit/**</include>
+					</includes>
+				</configuration>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-assembly-plugin</artifactId>
+				<version>${maven-assembly-plugin.version}</version>
+				<configuration>
+					<descriptorRefs>
+						<descriptorRef>jar-with-dependencies</descriptorRef>
+					</descriptorRefs>
+					<finalName>soot-infoflow-trunk</finalName>
+					<appendAssemblyId>false</appendAssemblyId>
+				</configuration>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-jar-plugin</artifactId>
+				<version>${maven-jar-plugin.version}</version>
+				<executions>
+					<execution>
+						<goals>
+							<goal>test-jar</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-source-plugin</artifactId>
+				<version>${maven-source-plugin.version}</version>
+				<executions>
+					<execution>
+						<id>attach-sources</id>
+						<goals>
+							<goal>jar</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+			<plugin>
+				<groupId>org.apache.maven.plugins</groupId>
+				<artifactId>maven-javadoc-plugin</artifactId>
+				<version>${maven-javadoc-plugin.version}</version>
+				<configuration>
+					<failOnError>false</failOnError>
+				</configuration>
+				<executions>
+					<execution>
+						<id>attach-javadocs</id>
+						<goals>
+							<goal>jar</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+		</plugins>
+
+		<resources>
+			<resource>
+				<directory>.</directory>
+				<includes>
+					<include>EasyTaintWrapperSource.txt</include>
+				</includes>
+			</resource>
+		</resources>
+	</build>
+
+	<dependencies>
+		<dependency>
+			<groupId>de.upb.cs.swt</groupId>
+			<artifactId>heros</artifactId>
+			<version>1.2.0</version>
+		</dependency>
+		<dependency>
+			<groupId>ca.mcgill.sable</groupId>
+			<artifactId>soot</artifactId>
+			<version>4.1.0-SNAPSHOT</version>
+		</dependency>
+		<dependency>
+			<groupId>junit</groupId>
+			<artifactId>junit</artifactId>
+			<version>4.12</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.hamcrest</groupId>
+			<artifactId>hamcrest-core</artifactId>
+			<version>1.3</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>javax.servlet</groupId>
+			<artifactId>javax.servlet-api</artifactId>
+			<version>3.0.1</version>
+			<scope>test</scope>
+		</dependency>
+		<dependency>
+			<groupId>net.sf.trove4j</groupId>
+			<artifactId>trove4j</artifactId>
+			<version>3.0.3</version>
+		</dependency>
+		<dependency>
+			<groupId>com.google.guava</groupId>
+			<artifactId>guava</artifactId>
+			<version>25.1-jre</version>
+		</dependency>
+	</dependencies>
+
+	<repositories>
+		<repository>
+			<id>sonatype-snapshot</id>
+			<url>https://oss.sonatype.org/content/repositories/snapshots</url>
+			<releases>
+				<enabled>false</enabled>
+			</releases>
+			<snapshots>
+				<enabled>true</enabled>
+			</snapshots>
+		</repository>
+	</repositories>
+	<distributionManagement>
+		<snapshotRepository>
+			<id>ossrh</id>
+			<url>https://oss.sonatype.org/content/repositories/snapshots</url>
+		</snapshotRepository>
+	</distributionManagement>
+	<profiles>
+		<profile>
+			<id>deploy</id>
+			<activation>
+				<property>
+					<name>deploy</name>
+					<value>true</value>
+				</property>
+			</activation>
+			<build>
+				<plugins>
+					<plugin>
+						<groupId>org.sonatype.plugins</groupId>
+						<artifactId>nexus-staging-maven-plugin</artifactId>
+						<version>${maven-nexus-staging-plugin.version}</version>
+						<extensions>true</extensions>
+						<configuration>
+							<serverId>ossrh</serverId>
+							<nexusUrl>https://oss.sonatype.org/</nexusUrl>
+							<autoReleaseAfterClose>true</autoReleaseAfterClose>
+						</configuration>
+					</plugin>
+					<plugin>
+						<groupId>org.apache.maven.plugins</groupId>
+						<artifactId>maven-gpg-plugin</artifactId>
+						<version>${maven-gpg-plugin.version}</version>
+						<executions>
+							<execution>
+								<id>sign-artifacts</id>
+								<phase>verify</phase>
+								<goals>
+									<goal>sign</goal>
+								</goals>
+								<configuration>
+									<!-- This is necessary for gpg to not try to use the pinentry programs -->
+									<gpgArguments>
+										<arg>--pinentry-mode</arg>
+										<arg>loopback</arg>
+									</gpgArguments>
+								</configuration>
                             </execution>
                         </executions>
                     </plugin>
-                </plugins>
-            </build>
-        </profile>
-    </profiles>
+<!--                    <plugin>-->
+<!--                        <groupId>org.apache.maven.plugins</groupId>-->
+<!--                        <artifactId>maven-source-plugin</artifactId>-->
+<!--                        <executions>-->
+<!--                            <execution>-->
+<!--                                <id>attach-sources</id>-->
+<!--                                <goals>-->
+<!--                                    <goal>jar</goal>-->
+<!--                                </goals>-->
+<!--                            </execution>-->
+<!--                        </executions>-->
+<!--                    </plugin>-->
+<!--                    <plugin>-->
+<!--                        <groupId>org.apache.maven.plugins</groupId>-->
+<!--                        <artifactId>maven-javadoc-plugin</artifactId>-->
+<!--                        <executions>-->
+<!--                            <execution>-->
+<!--                                <id>attach-javadocs</id>-->
+<!--                                <goals>-->
+<!--                                    <goal>jar</goal>-->
+<!--                                </goals>-->
+<!--							</execution>-->
+<!--						</executions>-->
+<!--					</plugin>-->
+					<plugin>
+						<groupId>org.apache.maven.plugins</groupId>
+						<artifactId>maven-assembly-plugin</artifactId>
+						<executions>
+							<execution>
+								<id>simple-command</id>
+								<phase>package</phase>
+								<goals>
+									<goal>single</goal>
+								</goals>
+							</execution>
+						</executions>
+					</plugin>
+				</plugins>
+			</build>
+		</profile>
+	</profiles>
 </project>
diff --git a/soot-infoflow/src/soot/jimple/infoflow/AbstractInfoflow.java b/soot-infoflow/src/soot/jimple/infoflow/AbstractInfoflow.java
index 0f05918..a34f065 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/AbstractInfoflow.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/AbstractInfoflow.java
@@ -67,15 +67,15 @@ public abstract class AbstractInfoflow implements IInfoflow {
 	/**
 	 * Creates a new instance of the abstract info flow problem
 	 * 
-	 * @param icfgFactory
-	 *            The interprocedural CFG to be used by the InfoFlowProblem
-	 * @param androidPath
-	 *            If forceAndroidJar is false, this is the base directory of the
-	 *            platform files in the Android SDK. If forceAndroidJar is true,
-	 *            this is the full path of a single android.jar file.
-	 * @param forceAndroidJar
-	 *            True if a single platform JAR file shall be forced, false if Soot
-	 *            shall pick the appropriate platform version
+	 * @param icfgFactory     The interprocedural CFG to be used by the
+	 *                        InfoFlowProblem
+	 * @param androidPath     If forceAndroidJar is false, this is the base
+	 *                        directory of the platform files in the Android SDK. If
+	 *                        forceAndroidJar is true, this is the full path of a
+	 *                        single android.jar file.
+	 * @param forceAndroidJar True if a single platform JAR file shall be forced,
+	 *                        false if Soot shall pick the appropriate platform
+	 *                        version
 	 */
 	public AbstractInfoflow(BiDirICFGFactory icfgFactory, String androidPath, boolean forceAndroidJar) {
 		if (icfgFactory == null) {
@@ -145,10 +145,8 @@ public abstract class AbstractInfoflow implements IInfoflow {
 	/**
 	 * Appends two elements to build a classpath
 	 * 
-	 * @param appPath
-	 *            The first entry of the classpath
-	 * @param libPath
-	 *            The second entry of the classpath
+	 * @param appPath The first entry of the classpath
+	 * @param libPath The second entry of the classpath
 	 * @return The concatenated classpath
 	 */
 	private String appendClasspath(String appPath, String libPath) {
@@ -165,13 +163,11 @@ public abstract class AbstractInfoflow implements IInfoflow {
 	/**
 	 * Initializes Soot.
 	 * 
-	 * @param appPath
-	 *            The application path containing the analysis client
-	 * @param libPath
-	 *            The Soot classpath containing the libraries
-	 * @param classes
-	 *            The set of classes that shall be checked for data flow analysis
-	 *            seeds. All sources in these classes are used as seeds.
+	 * @param appPath The application path containing the analysis client
+	 * @param libPath The Soot classpath containing the libraries
+	 * @param classes The set of classes that shall be checked for data flow
+	 *                analysis seeds. All sources in these classes are used as
+	 *                seeds.
 	 */
 	protected void initializeSoot(String appPath, String libPath, Collection<String> classes) {
 		initializeSoot(appPath, libPath, classes, "");
@@ -180,14 +176,12 @@ public abstract class AbstractInfoflow implements IInfoflow {
 	/**
 	 * Initializes Soot.
 	 * 
-	 * @param appPath
-	 *            The application path containing the analysis client
-	 * @param libPath
-	 *            The Soot classpath containing the libraries
-	 * @param classes
-	 *            The set of classes that shall be checked for data flow analysis
-	 *            seeds. All sources in these classes are used as seeds. If a
-	 *            non-empty extra seed is given, this one is used too.
+	 * @param appPath The application path containing the analysis client
+	 * @param libPath The Soot classpath containing the libraries
+	 * @param classes The set of classes that shall be checked for data flow
+	 *                analysis seeds. All sources in these classes are used as
+	 *                seeds. If a non-empty extra seed is given, this one is used
+	 *                too.
 	 */
 	protected void initializeSoot(String appPath, String libPath, Collection<String> classes, String extraSeed) {
 		// reset Soot:
@@ -348,7 +342,7 @@ public abstract class AbstractInfoflow implements IInfoflow {
 			tr.onBeforeCallgraphConstruction();
 
 		// Patch the system libraries we need for callgraph construction
-		LibraryClassPatcher patcher = new LibraryClassPatcher();
+		LibraryClassPatcher patcher = getLibraryClassPatcher();
 		patcher.patchLibraries();
 
 		// To cope with broken APK files, we convert all classes that are still
@@ -375,4 +369,8 @@ public abstract class AbstractInfoflow implements IInfoflow {
 			tr.onAfterCallgraphConstruction();
 	}
 
+	protected LibraryClassPatcher getLibraryClassPatcher() {
+		return new LibraryClassPatcher();
+	}
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/Infoflow.java b/soot-infoflow/src/soot/jimple/infoflow/Infoflow.java
index 0947d2a..cf9064f 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/Infoflow.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/Infoflow.java
@@ -69,6 +69,7 @@ import soot.jimple.infoflow.memory.ISolverTerminationReason;
 import soot.jimple.infoflow.memory.reasons.AbortRequestedReason;
 import soot.jimple.infoflow.memory.reasons.OutOfMemoryReason;
 import soot.jimple.infoflow.memory.reasons.TimeoutReason;
+import soot.jimple.infoflow.problems.AbstractInfoflowProblem;
 import soot.jimple.infoflow.problems.BackwardsInfoflowProblem;
 import soot.jimple.infoflow.problems.InfoflowProblem;
 import soot.jimple.infoflow.problems.TaintPropagationResults;
@@ -81,9 +82,11 @@ import soot.jimple.infoflow.results.ResultSinkInfo;
 import soot.jimple.infoflow.results.ResultSourceInfo;
 import soot.jimple.infoflow.solver.IInfoflowSolver;
 import soot.jimple.infoflow.solver.PredecessorShorteningMode;
+import soot.jimple.infoflow.solver.SolverPeerGroup;
 import soot.jimple.infoflow.solver.cfg.BackwardsInfoflowCFG;
 import soot.jimple.infoflow.solver.cfg.IInfoflowCFG;
 import soot.jimple.infoflow.solver.executors.InterruptableExecutor;
+import soot.jimple.infoflow.solver.gcSolver.GCSolverPeerGroup;
 import soot.jimple.infoflow.solver.memory.DefaultMemoryManagerFactory;
 import soot.jimple.infoflow.solver.memory.IMemoryManager;
 import soot.jimple.infoflow.solver.memory.IMemoryManagerFactory;
@@ -124,6 +127,10 @@ public class Infoflow extends AbstractInfoflow {
 	protected SootMethod dummyMainMethod = null;
 	protected Collection<SootMethod> additionalEntryPointMethods = null;
 
+	private boolean throwExceptions;
+
+	protected SolverPeerGroup solverPeerGroup;
+
 	/**
 	 * Creates a new instance of the InfoFlow class for analyzing plain Java code
 	 * without any references to APKs or the Android SDK.
@@ -247,10 +254,11 @@ public class Infoflow extends AbstractInfoflow {
 	 *                        if they are not sources
 	 */
 	private void runAnalysis(final ISourceSinkManager sourcesSinks, final Set<String> additionalSeeds) {
-		final InfoflowPerformanceData performanceData = new InfoflowPerformanceData();
+		final InfoflowPerformanceData performanceData = createPerformanceDataClass();
 		try {
 			// Clear the data from previous runs
 			results = new InfoflowResults();
+			results.setPerformanceData(performanceData);
 
 			// Print and check our configuration
 			checkAndFixConfiguration();
@@ -346,6 +354,9 @@ public class Infoflow extends AbstractInfoflow {
 				// Initialize the data flow manager
 				manager = initializeInfoflowManager(sourcesSinks, iCfg, globalTaintManager);
 
+				// Create the solver peer group
+				solverPeerGroup = new GCSolverPeerGroup();
+
 				// Initialize the alias analysis
 				Abstraction zeroValue = null;
 				IAliasingStrategy aliasingStrategy = createAliasAnalysis(sourcesSinks, iCfg, executor, memoryManager);
@@ -356,7 +367,7 @@ public class Infoflow extends AbstractInfoflow {
 				}
 
 				// Initialize the aliasing infrastructure
-				Aliasing aliasing = new Aliasing(aliasingStrategy, manager);
+				Aliasing aliasing = createAliasController(aliasingStrategy);
 				if (dummyMainMethod != null)
 					aliasing.excludeMethodFromMustAlias(dummyMainMethod);
 				manager.setAliasing(aliasing);
@@ -469,6 +480,7 @@ public class Infoflow extends AbstractInfoflow {
 					// Create the path builder
 					final IAbstractionPathBuilder builder = new BatchPathBuilder(manager,
 							pathBuilderFactory.createPathBuilder(manager, resultExecutor));
+//					final IAbstractionPathBuilder builder = new DebuggingPathBuilder(pathBuilderFactory, manager);
 
 					// If we want incremental result reporting, we have to
 					// initialize it before we start the taint tracking
@@ -480,6 +492,7 @@ public class Infoflow extends AbstractInfoflow {
 						performanceData.setTaintPropagationSeconds(0);
 					long beforeTaintPropagation = System.nanoTime();
 
+					onBeforeTaintPropagation(forwardSolver, backwardSolver);
 					forwardSolver.solve();
 
 					// Not really nice, but sometimes Heros returns before all
@@ -513,7 +526,7 @@ public class Infoflow extends AbstractInfoflow {
 
 					// Give derived classes a chance to do whatever they need before we remove stuff
 					// from memory
-					onTaintPropagationCompleted();
+					onTaintPropagationCompleted(forwardSolver, backwardSolver);
 
 					// Get the result abstractions
 					Set<AbstractionAtSink> res = propagationResults.getResults();
@@ -527,10 +540,12 @@ public class Infoflow extends AbstractInfoflow {
 					if (nativeCallHandler != null)
 						nativeCallHandler.shutdown();
 
-					logger.info("IFDS problem with {} forward and {} backward edges solved, processing {} results...",
-							forwardSolver.getPropagationCount(), aliasingStrategy.getSolver() == null ? 0
+					logger.info(
+							"IFDS problem with {} forward and {} backward edges solved in {} seconds, processing {} results...",
+							forwardSolver.getPropagationCount(),
+							aliasingStrategy.getSolver() == null ? 0
 									: aliasingStrategy.getSolver().getPropagationCount(),
-							res == null ? 0 : res.size());
+							taintPropagationSeconds, res == null ? 0 : res.size());
 
 					// Update the statistics
 					{
@@ -558,10 +573,14 @@ public class Infoflow extends AbstractInfoflow {
 					forwardSolver = null;
 					forwardProblem = null;
 
+					solverPeerGroup = null;
+
 					// Remove the alias analysis from memory
 					aliasing = null;
-					if (aliasingStrategy.getSolver() != null)
+					if (aliasingStrategy.getSolver() != null) {
+						aliasingStrategy.getSolver().terminate();
 						memoryWatcher.removeSolver((IMemoryBoundedSolver) aliasingStrategy.getSolver());
+					}
 					aliasingStrategy.cleanup();
 					aliasingStrategy = null;
 
@@ -634,9 +653,6 @@ public class Infoflow extends AbstractInfoflow {
 						}
 
 						// Get the results once the path builder is done
-						if (this.results == null)
-							this.results = builder.getResults();
-						else
 							this.results.addAll(builder.getResults());
 					}
 					resultExecutor.shutdown();
@@ -656,6 +672,12 @@ public class Infoflow extends AbstractInfoflow {
 					if (pathTimeoutWatcher != null)
 						pathTimeoutWatcher.stop();
 
+					if (aliasingStrategy != null) {
+						IInfoflowSolver solver = aliasingStrategy.getSolver();
+						if (solver != null)
+							solver.terminate();
+					}
+
 					// Do we have any more sources?
 					hasMoreSources = oneSourceAtATime != null && oneSourceAtATime.hasNextSource();
 
@@ -726,14 +748,50 @@ public class Infoflow extends AbstractInfoflow {
 			ex.printStackTrace(pw);
 			results.addException(ex.getClass().getName() + ": " + ex.getMessage() + "\n" + stacktrace.toString());
 			logger.error("Exception during data flow analysis", ex);
+			if (throwExceptions)
+				throw ex;
 		}
 	}
 
+	/**
+	 * Factory method for creating the data object that will receive the data flow
+	 * solver's performance data
+	 *
+	 * @return The data object for the performance data
+	 */
+	protected InfoflowPerformanceData createPerformanceDataClass() {
+		return new InfoflowPerformanceData();
+	}
+
+	/**
+	 * Creates the controller object that handles aliasing operations. Derived
+	 * classes can override this method to supply custom aliasing implementations.
+	 *
+	 * @param aliasingStrategy The aliasing strategy to use
+	 * @return The new alias controller object
+	 */
+	protected Aliasing createAliasController(IAliasingStrategy aliasingStrategy) {
+		return new Aliasing(aliasingStrategy, manager);
+	}
+
+	/**
+	 * Callback that is invoked when the main taint propagation is about to start
+	 *
+	 * @param forwardSolver  The forward data flow solver
+	 * @param backwardSolver The backward data flow solver
+	 */
+	protected void onBeforeTaintPropagation(IInfoflowSolver forwardSolver, IInfoflowSolver backwardSolver) {
+		//
+	}
+
 	/**
 	 * Callback that is invoked when the main taint propagation has completed. This
 	 * method is called before memory cleanup happens.
+	 *
+	 * @param forwardSolver  The forward data flow solver
+	 * @param backwardSolver The backward data flow solver
 	 */
-	protected void onTaintPropagationCompleted() {
+	protected void onTaintPropagationCompleted(IInfoflowSolver forwardSolver, IInfoflowSolver backwardSolver) {
 		//
 	}
 
@@ -859,17 +917,7 @@ public class Infoflow extends AbstractInfoflow {
 
 			// We need to create the right data flow solver
 			SolverConfiguration solverConfig = config.getSolverConfiguration();
-			switch (solverConfig.getDataFlowSolver()) {
-			case ContextFlowSensitive:
-				backSolver = new soot.jimple.infoflow.solver.fastSolver.InfoflowSolver(backProblem, executor);
-				break;
-			case FlowInsensitive:
-				backSolver = new soot.jimple.infoflow.solver.fastSolver.flowInsensitive.InfoflowSolver(backProblem,
-						executor);
-				break;
-			default:
-				throw new RuntimeException("Unsupported data flow solver");
-			}
+			backSolver = createDataFlowSolver(executor, backProblem, solverConfig);
 
 			backSolver.setMemoryManager(memoryManager);
 			backSolver.setPredecessorShorteningMode(
@@ -970,19 +1018,7 @@ public class Infoflow extends AbstractInfoflow {
 		// different solver object
 		IInfoflowSolver forwardSolver;
 		SolverConfiguration solverConfig = config.getSolverConfiguration();
-		switch (solverConfig.getDataFlowSolver()) {
-		case ContextFlowSensitive:
-			logger.info("Using context- and flow-sensitive solver");
-			forwardSolver = new soot.jimple.infoflow.solver.fastSolver.InfoflowSolver(forwardProblem, executor);
-			break;
-		case FlowInsensitive:
-			logger.info("Using context-sensitive, but flow-insensitive solver");
-			forwardSolver = new soot.jimple.infoflow.solver.fastSolver.flowInsensitive.InfoflowSolver(forwardProblem,
-					executor);
-			break;
-		default:
-			throw new RuntimeException("Unsupported data flow solver");
-		}
+		forwardSolver = createDataFlowSolver(executor, forwardProblem, solverConfig);
 
 		// Configure the solver
 		forwardSolver.setSolverId(true);
@@ -995,6 +1031,34 @@ public class Infoflow extends AbstractInfoflow {
 		return forwardSolver;
 	}
 
+	/**
+	 * Creates the instance of the data flow solver
+	 *
+	 * @param executor     The executor on which the solver shall run its tasks
+	 * @param problem      The problem to be solved by the new solver
+	 * @param solverConfig The solver configuration
+	 * @return The new data flow solver
+	 */
+	protected IInfoflowSolver createDataFlowSolver(InterruptableExecutor executor, AbstractInfoflowProblem problem,
+			SolverConfiguration solverConfig) {
+		switch (solverConfig.getDataFlowSolver()) {
+		case ContextFlowSensitive:
+			logger.info("Using context- and flow-sensitive solver");
+			return new soot.jimple.infoflow.solver.fastSolver.InfoflowSolver(problem, executor);
+		case FlowInsensitive:
+			logger.info("Using context-sensitive, but flow-insensitive solver");
+			return new soot.jimple.infoflow.solver.fastSolver.flowInsensitive.InfoflowSolver(problem, executor);
+		case GarbageCollecting:
+			logger.info("Using garbage-collecting solver");
+			IInfoflowSolver solver = new soot.jimple.infoflow.solver.gcSolver.InfoflowSolver(problem, executor);
+			solverPeerGroup.addSolver(solver);
+			solver.setPeerGroup(solverPeerGroup);
+			return solver;
+		default:
+			throw new RuntimeException("Unsupported data flow solver");
+		}
+	}
+
 	/**
 	 * Gets the memory used by FlowDroid at the moment
 	 * 
@@ -1010,7 +1074,7 @@ public class Infoflow extends AbstractInfoflow {
 	 * 
 	 * @param sourcesSinks The SourceSinkManager
 	 */
-	private void eliminateDeadCode(ISourceSinkManager sourcesSinks) {
+	protected void eliminateDeadCode(ISourceSinkManager sourcesSinks) {
 		InfoflowManager dceManager = new InfoflowManager(config, null,
 				icfgFactory.buildBiDirICFG(config.getCallgraphAlgorithm(), config.getEnableExceptionTracking()), null,
 				null, null, new AccessPathFactory(config), null);
@@ -1077,10 +1141,13 @@ public class Infoflow extends AbstractInfoflow {
 	protected boolean isValidSeedMethod(SootMethod sm) {
 		if (sm == dummyMainMethod)
 			return false;
+		if (dummyMainMethod != null && sm.getDeclaringClass() == dummyMainMethod.getDeclaringClass())
+			return false;
 
 		// Exclude system classes
-		if (config.getIgnoreFlowsInSystemPackages()
-				&& SystemClassHandler.isClassInSystemPackage(sm.getDeclaringClass().getName()))
+		final String className = sm.getDeclaringClass().getName();
+		if (config.getIgnoreFlowsInSystemPackages() && SystemClassHandler.v().isClassInSystemPackage(className)
+				&& !isUserCodeClass(className))
 			return false;
 
 		// Exclude library classes
@@ -1090,6 +1157,17 @@ public class Infoflow extends AbstractInfoflow {
 		return true;
 	}
 
+	/**
+	 * Checks whether the given class is user code and should not be filtered out.
+	 * By default, this method assumes that all code is potentially user code.
+	 *
+	 * @param className The name of the class to check
+	 * @return True if the given class is user code, false otherwise
+	 */
+	protected boolean isUserCodeClass(String className) {
+		return false;
+	}
+
 	/**
 	 * Scans the given method for sources and sinks contained in it. Sinks are just
 	 * counted, sources are added to the InfoflowProblem as seeds.
@@ -1124,13 +1202,13 @@ public class Infoflow extends AbstractInfoflow {
 					forwardProblem.addInitialSeeds(u, Collections.singleton(forwardProblem.zeroValue()));
 					if (getConfig().getLogSourcesAndSinks())
 						collectedSources.add(s);
-					logger.debug("Source found: {}", u);
+					logger.debug("Source found: {} in {}", u, m.getSignature());
 				}
 				if (sourcesSinks.getSinkInfo(s, manager, null) != null) {
 					sinkCount++;
 					if (getConfig().getLogSourcesAndSinks())
 						collectedSinks.add(s);
-					logger.debug("Sink found: {}", u);
+					logger.debug("Sink found: {} in {}", u, m.getSignature());
 				}
 			}
 
@@ -1214,4 +1292,8 @@ public class Infoflow extends AbstractInfoflow {
 		}
 	}
 
+	public void setThrowExceptions(boolean b) {
+		this.throwExceptions = b;
+	}
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/InfoflowConfiguration.java b/soot-infoflow/src/soot/jimple/infoflow/InfoflowConfiguration.java
index a1702b8..929e1b9 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/InfoflowConfiguration.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/InfoflowConfiguration.java
@@ -10,7 +10,6 @@ import org.slf4j.LoggerFactory;
  *
  */
 public class InfoflowConfiguration {
-
 	protected final static Logger logger = LoggerFactory.getLogger(InfoflowConfiguration.class);
 
 	/**
@@ -78,7 +77,12 @@ public class InfoflowConfiguration {
 		/**
 		 * Use a context-sensitive, but flow-insensitive solver
 		 */
-		FlowInsensitive
+		FlowInsensitive,
+
+		/**
+		 * Use the garbage-collecting solver
+		 */
+		GarbageCollecting
 	}
 
 	/**
@@ -210,6 +214,267 @@ public class InfoflowConfiguration {
 		None
 	}
 
+	/**
+	 * The default mode how the filter shall treat source or sink categories that
+	 * have not been configured explicitly
+	 * 
+	 * @author Steven Arzt
+	 *
+	 */
+	public static enum SourceSinkFilterMode {
+		/**
+		 * Include all categories that have not been excluded explicitly
+		 */
+		UseAllButExcluded,
+
+		/**
+		 * Only include those categories that have been included explicitly and ignore
+		 * all others
+		 */
+		UseOnlyIncluded
+	}
+
+	/**
+	 * The modes (included or excludes) that a category can have for the data flow
+	 * analysis
+	 * 
+	 * @author Steven Arzt
+	 *
+	 */
+	public static enum CategoryMode {
+		/**
+		 * The sources and sinks from the current category shall be included in the data
+		 * flow analysis
+		 */
+		Include,
+
+		/**
+		 * The sources and sinks from the current category shall be excluded from the
+		 * data flow analysis
+		 */
+		Exclude
+	}
+
+	/**
+	 * Methods for deciding whether a parameter of a system callback is to be
+	 * treated as a source or not
+	 * 
+	 * @author Steven Arzt
+	 *
+	 */
+	public static enum CallbackSourceMode {
+		/**
+		 * Callback parameters are never treated as sources
+		 */
+		NoParametersAsSources,
+		/**
+		 * All callback parameters are sources
+		 */
+		AllParametersAsSources,
+		/**
+		 * Only parameters from callback methods explicitly defined as sources are
+		 * treated as sources
+		 */
+		SourceListOnly
+	}
+
+	/**
+	 * Possible modes for matching layout components as data flow sources
+	 * 
+	 * @author Steven Arzt
+	 */
+	public static enum LayoutMatchingMode {
+		/**
+		 * Do not use Android layout components as sources
+		 */
+		NoMatch,
+
+		/**
+		 * Use all layout components as sources
+		 */
+		MatchAll,
+
+		/**
+		 * Only use sensitive layout components (e.g. password fields) as sources
+		 */
+		MatchSensitiveOnly
+	}
+
+	/**
+	 * The configuration for the source and sink manager
+	 * 
+	 * @author Steven Arzt
+	 *
+	 */
+	public static class SourceSinkConfiguration {
+
+		private CallbackSourceMode callbackSourceMode = CallbackSourceMode.SourceListOnly;
+		private boolean enableLifecycleSources = false;
+		private LayoutMatchingMode layoutMatchingMode = LayoutMatchingMode.MatchSensitiveOnly;
+
+		private SourceSinkFilterMode sourceFilterMode = SourceSinkFilterMode.UseAllButExcluded;
+		private SourceSinkFilterMode sinkFilterMode = SourceSinkFilterMode.UseAllButExcluded;
+
+		/**
+		 * Copies the settings of the given configuration into this configuration object
+		 * 
+		 * @param iccConfig The other configuration object
+		 */
+		public void merge(SourceSinkConfiguration ssConfig) {
+			this.callbackSourceMode = ssConfig.callbackSourceMode;
+			this.enableLifecycleSources = ssConfig.enableLifecycleSources;
+			this.layoutMatchingMode = ssConfig.layoutMatchingMode;
+
+			this.sourceFilterMode = ssConfig.sourceFilterMode;
+			this.sinkFilterMode = ssConfig.sinkFilterMode;
+		}
+
+		/**
+		 * Sets the default mode for handling sources that have not been configured
+		 * explicitly
+		 * 
+		 * @param sourceFilterMode The default mode for handling sources that have not
+		 *                         been configured explicitly
+		 */
+		public void setSourceFilterMode(SourceSinkFilterMode sourceFilterMode) {
+			this.sourceFilterMode = sourceFilterMode;
+		}
+
+		/**
+		 * Gets the default mode for handling sinks that have not been configured
+		 * explicitly
+		 * 
+		 * @return The default mode for handling sinks that have not been configured
+		 *         explicitly
+		 */
+		public SourceSinkFilterMode getSinkFilterMode() {
+			return sinkFilterMode;
+		}
+
+		/**
+		 * Sets the default mode for handling sinks that have not been configured
+		 * explicitly
+		 * 
+		 * @param sourceFilterMode The default mode for handling sinks that have not
+		 *                         been configured explicitly
+		 */
+		public void setSinkFilterMode(SourceSinkFilterMode sinkFilterMode) {
+			this.sinkFilterMode = sinkFilterMode;
+		}
+
+		/**
+		 * Sets under which circumstances the parameters of callback methods shall be
+		 * treated as sources.
+		 * 
+		 * @param callbackSourceMode The strategy for deciding whether a certain
+		 *                           callback parameter is a data flow source or not
+		 */
+		public void setCallbackSourceMode(CallbackSourceMode callbackSourceMode) {
+			this.callbackSourceMode = callbackSourceMode;
+		}
+
+		/**
+		 * Sets under which circumstances the parameters of callback methods shall be
+		 * treated as sources.
+		 * 
+		 * @return The strategy for deciding whether a certain callback parameter is a
+		 *         data flow source or not
+		 */
+		public CallbackSourceMode getCallbackSourceMode() {
+			return this.callbackSourceMode;
+		}
+
+		/**
+		 * Sets whether the parameters of lifecycle methods shall be considered as
+		 * sources
+		 * 
+		 * @param enableLifecycleSoures True if the parameters of lifecycle methods
+		 *                              shall be considered as sources, otherwise false
+		 */
+		public void setEnableLifecycleSources(boolean enableLifecycleSources) {
+			this.enableLifecycleSources = enableLifecycleSources;
+		}
+
+		/**
+		 * Gets whether the parameters of lifecycle methods shall be considered as
+		 * sources
+		 * 
+		 * @return True if the parameters of lifecycle methods shall be considered as
+		 *         sources, otherwise false
+		 */
+		public boolean getEnableLifecycleSources() {
+			return this.enableLifecycleSources;
+		}
+
+		/**
+		 * Sets the mode to be used when deciding whether a UI control is a source or
+		 * not
+		 * 
+		 * @param mode The mode to be used for classifying UI controls as sources
+		 */
+		public void setLayoutMatchingMode(LayoutMatchingMode mode) {
+			this.layoutMatchingMode = mode;
+		}
+
+		/**
+		 * Gets the mode to be used when deciding whether a UI control is a source or
+		 * not
+		 * 
+		 * @return The mode to be used for classifying UI controls as sources
+		 */
+		public LayoutMatchingMode getLayoutMatchingMode() {
+			return this.layoutMatchingMode;
+		}
+
+		/**
+		 * Gets the default mode for handling sources that have not been configured
+		 * explicitly
+		 * 
+		 * @return The default mode for handling sources that have not been configured
+		 *         explicitly
+		 */
+		public SourceSinkFilterMode getSourceFilterMode() {
+			return sourceFilterMode;
+		}
+
+		@Override
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + ((callbackSourceMode == null) ? 0 : callbackSourceMode.hashCode());
+			result = prime * result + (enableLifecycleSources ? 1231 : 1237);
+			result = prime * result + ((layoutMatchingMode == null) ? 0 : layoutMatchingMode.hashCode());
+			result = prime * result + ((sinkFilterMode == null) ? 0 : sinkFilterMode.hashCode());
+			result = prime * result + ((sourceFilterMode == null) ? 0 : sourceFilterMode.hashCode());
+			return result;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (obj == null)
+				return false;
+			if (getClass() != obj.getClass())
+				return false;
+			SourceSinkConfiguration other = (SourceSinkConfiguration) obj;
+			if (callbackSourceMode != other.callbackSourceMode)
+				return false;
+			if (enableLifecycleSources != other.enableLifecycleSources)
+				return false;
+			if (layoutMatchingMode != other.layoutMatchingMode)
+				return false;
+			if (sinkFilterMode != other.sinkFilterMode)
+				return false;
+			if (sourceFilterMode != other.sourceFilterMode)
+				return false;
+			return true;
+		}
+
+	}
+
+	private final SourceSinkConfiguration sourceSinkConfig = new SourceSinkConfiguration();
+
 	/**
 	 * The configuration that defines how FlowDroid shall handle between sources and
 	 * sinks
@@ -953,6 +1218,8 @@ public class InfoflowConfiguration {
 	private boolean writeOutputFiles = false;
 	private boolean logSourcesAndSinks = false;
 	private boolean enableReflection = false;
+	private boolean enableLineNumbers = false;
+	private boolean enableOriginalNames = false;
 
 	private boolean inspectSources = false;
 	private boolean inspectSinks = false;
@@ -992,6 +1259,8 @@ public class InfoflowConfiguration {
 		this.writeOutputFiles = config.writeOutputFiles;
 		this.logSourcesAndSinks = config.logSourcesAndSinks;
 		this.enableReflection = config.enableReflection;
+		this.enableLineNumbers = config.enableLineNumbers;
+		this.enableOriginalNames = config.enableOriginalNames;
 
 		this.pathConfiguration.merge(config.pathConfiguration);
 		this.outputConfiguration.merge(config.outputConfiguration);
@@ -1001,15 +1270,11 @@ public class InfoflowConfiguration {
 		this.callgraphAlgorithm = config.callgraphAlgorithm;
 		this.aliasingAlgorithm = config.aliasingAlgorithm;
 		this.codeEliminationMode = config.codeEliminationMode;
+		this.staticFieldTrackingMode = config.staticFieldTrackingMode;
 
 		this.inspectSources = config.inspectSources;
 		this.inspectSinks = config.inspectSinks;
 
-		this.callgraphAlgorithm = config.callgraphAlgorithm;
-		this.aliasingAlgorithm = config.aliasingAlgorithm;
-		this.codeEliminationMode = config.codeEliminationMode;
-		this.staticFieldTrackingMode = config.staticFieldTrackingMode;
-
 		this.taintAnalysisEnabled = config.writeOutputFiles;
 		this.incrementalResultReporting = config.incrementalResultReporting;
 		this.dataFlowTimeout = config.dataFlowTimeout;
@@ -1481,6 +1746,47 @@ public class InfoflowConfiguration {
 		this.enableReflection = enableReflections;
 	}
 
+	/**
+	 * Gets whether line numbers associated with sources and sinks should be output
+	 * in XML results
+	 * 
+	 * @return True if line number should be output, otherwise false
+	 */
+	public boolean getEnableLineNumbers() {
+		return this.enableLineNumbers;
+	}
+
+	/**
+	 * Sets whether line numbers associated with sources and sinks should be output
+	 * in XML results
+	 * 
+	 * @param enableLineNumbers True if line numbers associated with sources and
+	 *                          sinks should be output in XML results, otherwise
+	 *                          false
+	 */
+	public void setEnableLineNumbers(boolean enableLineNumbers) {
+		this.enableLineNumbers = enableLineNumbers;
+	}
+
+	/**
+	 * Gets whether the usage of original variablenames (if available) is enabled
+	 * 
+	 * @return True if the usage is enabled, otherwise false
+	 */
+	public boolean getEnableOriginalNames() {
+		return this.enableOriginalNames;
+	}
+
+	/**
+	 * Sets whether the usage of original variablenames (if available) is enabled
+	 * 
+	 * @param enableOriginalNames True if the usage of original variablenames (if
+	 *                            available) is enabled, otherwise false
+	 */
+	public void setEnableOriginalNames(boolean enableOriginalNames) {
+		this.enableOriginalNames = enableOriginalNames;
+	}
+
 	/**
 	 * Gets whether the taint analysis is enabled. If it is disabled, FlowDroid will
 	 * initialize the Soot instance and then return immediately.
@@ -1680,6 +1986,8 @@ public class InfoflowConfiguration {
 		result = prime * result + (enableArrays ? 1231 : 1237);
 		result = prime * result + (enableExceptions ? 1231 : 1237);
 		result = prime * result + (enableReflection ? 1231 : 1237);
+		result = prime * result + (enableLineNumbers ? 1231 : 1237);
+		result = prime * result + (enableOriginalNames ? 1231 : 1237);
 		result = prime * result + (enableTypeChecking ? 1231 : 1237);
 		result = prime * result + (excludeSootLibraryClasses ? 1231 : 1237);
 		result = prime * result + (flowSensitiveAliasing ? 1231 : 1237);
@@ -1734,6 +2042,10 @@ public class InfoflowConfiguration {
 			return false;
 		if (enableReflection != other.enableReflection)
 			return false;
+		if (enableLineNumbers != other.enableLineNumbers)
+			return false;
+		if (enableOriginalNames != other.enableOriginalNames)
+			return false;
 		if (enableTypeChecking != other.enableTypeChecking)
 			return false;
 		if (excludeSootLibraryClasses != other.excludeSootLibraryClasses)
@@ -1784,4 +2096,13 @@ public class InfoflowConfiguration {
 		return true;
 	}
 
+	/**
+	 * Gets the configuration of the source/sink manager
+	 * 
+	 * @return The configuration of the source/sink manager
+	 */
+	public SourceSinkConfiguration getSourceSinkConfig() {
+		return sourceSinkConfig;
+	}
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/aliasing/Aliasing.java b/soot-infoflow/src/soot/jimple/infoflow/aliasing/Aliasing.java
index e9df9ba..5a81506 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/aliasing/Aliasing.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/aliasing/Aliasing.java
@@ -15,6 +15,8 @@ import soot.ArrayType;
 import soot.Local;
 import soot.PrimType;
 import soot.RefLikeType;
+import soot.Scene;
+import soot.SootClass;
 import soot.SootField;
 import soot.SootMethod;
 import soot.Type;
@@ -79,7 +81,7 @@ public class Aliasing {
 	public void computeAliases(final Abstraction d1, final Stmt src, final Value targetValue, Set<Abstraction> taintSet,
 			SootMethod method, Abstraction newAbs) {
 		// Can we have aliases at all?
-		if (!canHaveAliases(newAbs.getAccessPath()))
+		if (!canHaveAliases(newAbs.getAccessPath()) && !isStringConstructorCall(src))
 			return;
 
 		// If we are not in a conditionally-called method, we run the
@@ -300,7 +302,7 @@ public class Aliasing {
 	 * @return True if the analysis must look for aliases for the newly constructed
 	 *         taint, otherwise false
 	 */
-	public static boolean canHaveAliases(Stmt stmt, Value val, Abstraction source) {
+	public boolean canHaveAliases(Stmt stmt, Value val, Abstraction source) {
 		if (stmt instanceof DefinitionStmt) {
 			DefinitionStmt defStmt = (DefinitionStmt) stmt;
 			// If the left side is overwritten completely, we do not need to
@@ -321,13 +323,33 @@ public class Aliasing {
 		if (val instanceof Constant)
 			return false;
 
-		// String cannot have aliases
-		if (TypeUtils.isStringType(val.getType()) && !source.getAccessPath().getCanHaveImmutableAliases())
+		// String cannot have aliases, unless we process a delayed constructor call
+		if (TypeUtils.isStringType(val.getType()) && !isStringConstructorCall(stmt)
+				&& !source.getAccessPath().getCanHaveImmutableAliases())
 			return false;
 
 		return val instanceof FieldRef || (val instanceof Local && ((Local) val).getType() instanceof ArrayType);
 	}
 
+	/**
+	 * Checks whether the given statement is a call to a String constructor
+	 * 
+	 * @param iStmt The statement to check
+	 * @return True if the given statement is a call to a String constructor, false
+	 *         otherwise
+	 */
+	public boolean isStringConstructorCall(Stmt iStmt) {
+		SootClass scString = Scene.v().getSootClassUnsafe("java.lang.String");
+		Collection<SootMethod> callees = manager.getICFG().getCalleesOfCallAt(iStmt);
+		if (callees != null && !callees.isEmpty()) {
+			for (SootMethod callee : callees) {
+				if (callee.getDeclaringClass() == scString && callee.isConstructor())
+					return true;
+			}
+		}
+		return false;
+	}
+
 	/**
 	 * Gets whether the given access path can have aliases
 	 * 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/callbacks/CallbackDefinition.java b/soot-infoflow/src/soot/jimple/infoflow/callbacks/CallbackDefinition.java
new file mode 100644
index 0000000..5c3fd05
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/callbacks/CallbackDefinition.java
@@ -0,0 +1,83 @@
+package soot.jimple.infoflow.callbacks;
+
+import soot.SootMethod;
+
+/**
+ * A base class for callbacks.
+ * 
+ * @author Steven Arzt, Marc Miltenberger
+ */
+public class CallbackDefinition {
+
+	protected final SootMethod targetMethod;
+	protected final SootMethod parentMethod;
+
+	/**
+	 * Creates a new instance of the {@link CallbackDefinition} class
+	 * 
+	 * @param targetMethod The callback method
+	 * @param parentMethod The parent method in the Android framework, e.g., in the
+	 *                     callback interface method
+	 */
+	public CallbackDefinition(SootMethod targetMethod, SootMethod parentMethod) {
+		this.targetMethod = targetMethod;
+		this.parentMethod = parentMethod;
+	}
+
+	/**
+	 * Gets the callback method represented by this data object
+	 * 
+	 * @return The callback method represented by this data object
+	 */
+	public SootMethod getTargetMethod() {
+		return this.targetMethod;
+	}
+
+	/**
+	 * Gets the parent method in the Android framework that causes the target method
+	 * to be a callback. The parent is usually the method in the framework's
+	 * callback interface.
+	 * 
+	 * @return The parent method in the Android framework
+	 */
+	public SootMethod getParentMethod() {
+		return this.parentMethod;
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((targetMethod == null) ? 0 : targetMethod.hashCode());
+		result = prime * result + ((parentMethod == null) ? 0 : parentMethod.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		CallbackDefinition other = (CallbackDefinition) obj;
+		if (targetMethod == null) {
+			if (other.targetMethod != null)
+				return false;
+		} else if (!targetMethod.equals(other.targetMethod))
+			return false;
+		if (parentMethod == null) {
+			if (other.parentMethod != null)
+				return false;
+		} else if (!parentMethod.equals(other.parentMethod))
+			return false;
+		return true;
+	}
+
+	@Override
+	public String toString() {
+		return targetMethod.toString();
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/codeOptimization/DeadCodeEliminator.java b/soot-infoflow/src/soot/jimple/infoflow/codeOptimization/DeadCodeEliminator.java
index 47c4d1e..1f597d6 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/codeOptimization/DeadCodeEliminator.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/codeOptimization/DeadCodeEliminator.java
@@ -45,24 +45,22 @@ public class DeadCodeEliminator implements ICodeOptimizer {
 		// inter-procedural one
 		for (QueueReader<MethodOrMethodContext> rdr = Scene.v().getReachableMethods().listener(); rdr.hasNext();) {
 			MethodOrMethodContext sm = rdr.next();
-			if (sm.method() == null || !sm.method().hasActiveBody())
+			SootMethod method = sm.method();
+
+			if (method == null || !method.hasActiveBody())
 				continue;
 
 			// Exclude the dummy main method
-			if (entryPoints.contains(sm.method()))
+			if (entryPoints.contains(method))
 				continue;
 
-			List<Unit> callSites = getCallsInMethod(sm.method());
+			List<Unit> callSites = getCallsInMethod(method);
 
-			ConstantPropagatorAndFolder.v().transform(sm.method().getActiveBody());
-			DeadAssignmentEliminator.v().transform(sm.method().getActiveBody());
+			ConstantPropagatorAndFolder.v().transform(method.getActiveBody());
+			DeadAssignmentEliminator.v().transform(method.getActiveBody());
 
 			// Remove the dead callgraph edges
-			List<Unit> newCallSites = getCallsInMethod(sm.method());
-			if (callSites != null)
-				for (Unit u : callSites)
-					if (newCallSites == null || !newCallSites.contains(u))
-						Scene.v().getCallGraph().removeAllEdgesOutOf(u);
+			removeDeadCallgraphEdges(method, callSites);
 		}
 
 		// Perform an inter-procedural constant propagation and code cleanup
@@ -78,35 +76,48 @@ public class DeadCodeEliminator implements ICodeOptimizer {
 		for (QueueReader<MethodOrMethodContext> rdr = Scene.v().getReachableMethods().listener(); rdr.hasNext();) {
 			MethodOrMethodContext sm = rdr.next();
 
-			if (sm.method() == null || !sm.method().hasActiveBody())
+			SootMethod method = sm.method();
+
+			if (method == null || !method.hasActiveBody())
 				continue;
 			if (config.getIgnoreFlowsInSystemPackages()
-					&& SystemClassHandler.isClassInSystemPackage(sm.method().getDeclaringClass().getName()))
+					&& SystemClassHandler.v().isClassInSystemPackage(sm.method().getDeclaringClass().getName()))
 				continue;
 
-			ConditionalBranchFolder.v().transform(sm.method().getActiveBody());
+			ConditionalBranchFolder.v().transform(method.getActiveBody());
 
 			// Delete all dead code. We need to be careful and patch the cfg so
 			// that it does not retain edges for call statements we have deleted
-			List<Unit> callSites = getCallsInMethod(sm.method());
-			UnreachableCodeEliminator.v().transform(sm.method().getActiveBody());
-			List<Unit> newCallSites = getCallsInMethod(sm.method());
-			if (callSites != null)
-				for (Unit u : callSites)
-					if (newCallSites == null || !newCallSites.contains(u))
-						Scene.v().getCallGraph().removeAllEdgesOutOf(u);
+			List<Unit> callSites = getCallsInMethod(method);
+			UnreachableCodeEliminator.v().transform(method.getActiveBody());
+			removeDeadCallgraphEdges(method, callSites);
 		}
 	}
 
+	/**
+	 * Collects all callsites of the given method and removes all edges from the callgraph that correspond to callsites
+	 * which are not in the given set of previously contained callsites.
+	 *
+	 * @param method The method which's outgoing callgraph edges should be sanitized
+	 * @param oldCallSites A list of callsites that where previously contained by the method's body and have to be
+	 *                     checked if still existent
+	 */
+	static void removeDeadCallgraphEdges(SootMethod method, List<Unit> oldCallSites) {
+		List<Unit> newCallSites = getCallsInMethod(method);
+		if (oldCallSites != null)
+			for (Unit u : oldCallSites)
+				if (newCallSites == null || !newCallSites.contains(u))
+					Scene.v().getCallGraph().removeAllEdgesOutOf(u);
+	}
+
 	/**
 	 * Gets a list of all units that invoke other methods in the given method
 	 * 
-	 * @param method
-	 *            The method from which to get all invocations
+	 * @param method The method from which to get all invocations
 	 * @return The list of units calling other methods in the given method if there
 	 *         is at least one such unit. Otherwise null.
 	 */
-	private List<Unit> getCallsInMethod(SootMethod method) {
+	static List<Unit> getCallsInMethod(SootMethod method) {
 		List<Unit> callSites = null;
 		for (Unit u : method.getActiveBody().getUnits())
 			if (((Stmt) u).containsInvokeExpr()) {
diff --git a/soot-infoflow/src/soot/jimple/infoflow/codeOptimization/InterproceduralConstantValuePropagator.java b/soot-infoflow/src/soot/jimple/infoflow/codeOptimization/InterproceduralConstantValuePropagator.java
index d9a946f..fb7f257 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/codeOptimization/InterproceduralConstantValuePropagator.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/codeOptimization/InterproceduralConstantValuePropagator.java
@@ -57,6 +57,7 @@ import soot.jimple.ThrowStmt;
 import soot.jimple.infoflow.InfoflowManager;
 import soot.jimple.infoflow.entryPointCreators.BaseEntryPointCreator;
 import soot.jimple.infoflow.entryPointCreators.IEntryPointCreator;
+import soot.jimple.infoflow.entryPointCreators.SimulatedCodeElementTag;
 import soot.jimple.infoflow.sourcesSinks.manager.ISourceSinkManager;
 import soot.jimple.infoflow.taintWrappers.ITaintPropagationWrapper;
 import soot.jimple.infoflow.util.SystemClassHandler;
@@ -167,7 +168,7 @@ public class InterproceduralConstantValuePropagator extends SceneTransformer {
 		// If this callee is excluded, we do not propagate out of it
 		if (excludedMethods != null && excludedMethods.contains(sm))
 			return;
-		if (excludeSystemClasses && SystemClassHandler.isClassInSystemPackage(sm.getDeclaringClass().getName()))
+		if (excludeSystemClasses && SystemClassHandler.v().isClassInSystemPackage(sm.getDeclaringClass()))
 			return;
 
 		if (sm.getReturnType() != VoidType.v() || sm.getParameterCount() > 0) {
@@ -208,12 +209,18 @@ public class InterproceduralConstantValuePropagator extends SceneTransformer {
 			MethodOrMethodContext mom = rdr.next();
 			SootMethod sm = mom.method();
 			if (sm.hasActiveBody()) {
+				List<Unit> oldCallSites = DeadCodeEliminator.getCallsInMethod(sm);
+
 				Body body = sm.retrieveActiveBody();
 				ConditionalBranchFolder.v().transform(body);
 				UnconditionalBranchFolder.v().transform(body);
 				DeadAssignmentEliminator.v().transform(body);
 				UnreachableCodeEliminator.v().transform(body);
 				UnusedLocalEliminator.v().transform(body);
+
+				// We need to be careful and patch the cfg so
+				// that it does not retain edges for call statements we have deleted
+				DeadCodeEliminator.removeDeadCallgraphEdges(sm, oldCallSites);
 			}
 		}
 
@@ -408,10 +415,8 @@ public class InterproceduralConstantValuePropagator extends SceneTransformer {
 				if (callSite instanceof AssignStmt) {
 					AssignStmt assign = (AssignStmt) callSite;
 
-					// If we have a taint wrapper, we need to keep the stub
-					// untouched since we
-					// don't know what artificial taint the wrapper will come up
-					// with
+					// If we have a taint wrapper, we need to keep the stub untouched since we don't
+					// know what artificial taint the wrapper will come up with
 					if (taintWrapper != null && taintWrapper.supportsCallee(assign))
 						continue;
 
@@ -423,18 +428,17 @@ public class InterproceduralConstantValuePropagator extends SceneTransformer {
 					// Make sure that we don't access anything we have already
 					// removed
 					SootMethod caller = manager.getICFG().getMethodOf(assign);
-					if (!caller.getActiveBody().getUnits().contains(assign))
+					if (caller == null || !caller.getActiveBody().getUnits().contains(assign))
 						continue;
 
 					// If the call site has multiple callees, we cannot
-					// propagate a
-					// single constant
-					if (manager.getICFG().getCalleesOfCallAt(callSite).size() > 1)
+					// propagate a single constant
+					Collection<SootMethod> callees = manager.getICFG().getCalleesOfCallAt(callSite);
+					if (callees != null && callees.size() > 1)
 						continue;
 
-					// If the call has no side effects, we can remove it
-					// altogether,
-					// otherwise we can just propagate the return value
+					// If the call has no side effects, we can remove it altogether, otherwise we
+					// can just propagate the return value
 					Unit assignConst = Jimple.v().newAssignStmt(assign.getLeftOp(), value);
 					if (!hasSideEffectsOrCallsSink(sm)) {
 						// If this method threw an exception, we have to make up
@@ -529,6 +533,7 @@ public class InterproceduralConstantValuePropagator extends SceneTransformer {
 							body.getUnits().add(throwNewEx);
 
 							body.getUnits().add(afterEx);
+							mainMethod.addTag(SimulatedCodeElementTag.TAG);
 							return mainMethod;
 						}
 
@@ -575,6 +580,7 @@ public class InterproceduralConstantValuePropagator extends SceneTransformer {
 
 				// Call the exception thrower after the old call site
 				Stmt throwCall = Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(thrower.makeRef()));
+				throwCall.addTag(SimulatedCodeElementTag.TAG);
 				caller.getActiveBody().getUnits().insertBefore(throwCall, callSite);
 			}
 	}
@@ -753,7 +759,7 @@ public class InterproceduralConstantValuePropagator extends SceneTransformer {
 	 */
 	private boolean methodIsAndroidStub(SootMethod method) {
 		if (!(Options.v().src_prec() == Options.src_prec_apk && method.getDeclaringClass().isLibraryClass()
-				&& SystemClassHandler.isClassInSystemPackage(method.getDeclaringClass().getName())))
+				&& SystemClassHandler.v().isClassInSystemPackage(method.getDeclaringClass())))
 			return false;
 
 		// Check whether there is only a single throw statement
diff --git a/soot-infoflow/src/soot/jimple/infoflow/collect/ConcurrentCountingMap.java b/soot-infoflow/src/soot/jimple/infoflow/collect/ConcurrentCountingMap.java
index a83d7c5..2b6a16f 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/collect/ConcurrentCountingMap.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/collect/ConcurrentCountingMap.java
@@ -1,11 +1,13 @@
 package soot.jimple.infoflow.collect;
 
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.stream.Collectors;
 
 /**
@@ -18,7 +20,26 @@ import java.util.stream.Collectors;
  */
 public class ConcurrentCountingMap<T> implements ConcurrentMap<T, Integer> {
 
+	public enum LockingMode {
+		/**
+		 * Perform no locking at all. The map is fully synchronous
+		 */
+		NoLocking,
+		/**
+		 * Perform fast locking. This will make the map mostly consistent across
+		 * threads.
+		 */
+		Fast,
+		/**
+		 * Always lock. This will make the map behave like a fully synchronized map.
+		 */
+		Safe
+	}
+
 	private final ConcurrentMap<T, AtomicInteger> map;
+	private final ReentrantLock lock = new ReentrantLock();
+	private LockingMode lockingMode = LockingMode.NoLocking;
+	private AtomicInteger changeCounter = new AtomicInteger();
 
 	public class Entry implements Map.Entry<T, Integer> {
 
@@ -41,8 +62,22 @@ public class ConcurrentCountingMap<T> implements ConcurrentMap<T, Integer> {
 
 		@Override
 		public Integer setValue(Integer value) {
-			AtomicInteger i = parentEntry.setValue(new AtomicInteger(value));
-			return i == null ? 0 : i.get();
+			try {
+				switch (lockingMode) {
+				case Fast:
+					if (lock.isLocked())
+						lock.lock();
+					break;
+				case Safe:
+					lock.lock();
+				}
+
+				AtomicInteger i = parentEntry.setValue(new AtomicInteger(value));
+				return i == null ? 0 : i.get();
+			} finally {
+				if (lock.isHeldByCurrentThread())
+					lock.unlock();
+			}
 		}
 
 	}
@@ -51,6 +86,10 @@ public class ConcurrentCountingMap<T> implements ConcurrentMap<T, Integer> {
 		this.map = new ConcurrentHashMap<>();
 	}
 
+	public ConcurrentCountingMap(int size) {
+		this.map = new ConcurrentHashMap<>(size);
+	}
+
 	public ConcurrentCountingMap(Map<T, AtomicInteger> map) {
 		this.map = new ConcurrentHashMap<>(map);
 	}
@@ -87,27 +126,91 @@ public class ConcurrentCountingMap<T> implements ConcurrentMap<T, Integer> {
 
 	@Override
 	public Integer put(T key, Integer value) {
-		AtomicInteger old = map.put(key, value == null ? null : new AtomicInteger(value));
-		return old == null ? 0 : old.get();
+		try {
+			switch (lockingMode) {
+			case Fast:
+				if (lock.isLocked())
+					lock.lock();
+				break;
+			case Safe:
+				lock.lock();
+				break;
+			}
+
+			AtomicInteger old = map.put(key, value == null ? null : new AtomicInteger(value));
+			changeCounter.incrementAndGet();
+			return old == null ? 0 : old.get();
+		} finally {
+			if (lock.isHeldByCurrentThread())
+				lock.unlock();
+		}
 	}
 
 	@Override
 	public Integer remove(Object key) {
-		AtomicInteger old = map.remove(key);
-		return old == null ? 0 : old.get();
+		try {
+			switch (lockingMode) {
+			case Fast:
+				if (lock.isLocked())
+					lock.lock();
+				break;
+			case Safe:
+				lock.lock();
+				break;
+			}
+
+			AtomicInteger old = map.remove(key);
+			changeCounter.incrementAndGet();
+			return old == null ? 0 : old.get();
+		} finally {
+			if (lock.isHeldByCurrentThread())
+				lock.unlock();
+		}
 	}
 
 	@Override
 	public void putAll(Map<? extends T, ? extends Integer> m) {
-		for (T t : m.keySet()) {
-			Integer i = m.get(t);
-			map.put(t, i == null ? null : new AtomicInteger(i));
+		try {
+			switch (lockingMode) {
+			case Fast:
+				if (lock.isLocked())
+					lock.lock();
+				break;
+			case Safe:
+				lock.lock();
+				break;
+			}
+
+			for (T t : m.keySet()) {
+				Integer i = m.get(t);
+				map.put(t, i == null ? null : new AtomicInteger(i));
+				changeCounter.incrementAndGet();
+			}
+		} finally {
+			if (lock.isHeldByCurrentThread())
+				lock.unlock();
 		}
 	}
 
 	@Override
 	public void clear() {
-		map.clear();
+		try {
+			switch (lockingMode) {
+			case Fast:
+				if (lock.isLocked())
+					lock.lock();
+				break;
+			case Safe:
+				lock.lock();
+				break;
+			}
+
+			map.clear();
+			changeCounter.incrementAndGet();
+		} finally {
+			if (lock.isHeldByCurrentThread())
+				lock.unlock();
+		}
 	}
 
 	@Override
@@ -127,30 +230,100 @@ public class ConcurrentCountingMap<T> implements ConcurrentMap<T, Integer> {
 
 	@Override
 	public Integer putIfAbsent(T key, Integer value) {
-		AtomicInteger i = map.putIfAbsent(key, new AtomicInteger(value));
-		return i == null ? 0 : i.get();
+		try {
+			switch (lockingMode) {
+			case Fast:
+				if (lock.isLocked())
+					lock.lock();
+				break;
+			case Safe:
+				lock.lock();
+				break;
+			}
+
+			AtomicInteger i = map.computeIfAbsent(key, k -> new AtomicInteger(value));
+			if (i == null) {
+				changeCounter.incrementAndGet();
+				return 0;
+			} else
+				return i.get();
+		} finally {
+			if (lock.isHeldByCurrentThread())
+				lock.unlock();
+		}
 	}
 
 	@Override
 	public boolean remove(Object key, Object value) {
-		if (value instanceof Integer)
-			return map.remove(key, new AtomicInteger((Integer) value));
-		return false;
+		try {
+			switch (lockingMode) {
+			case Fast:
+				if (lock.isLocked())
+					lock.lock();
+				break;
+			case Safe:
+				lock.lock();
+				break;
+			}
+
+			if (value instanceof Integer) {
+				boolean res = map.remove(key, new AtomicInteger((Integer) value));
+				changeCounter.incrementAndGet();
+				return res;
+			}
+			return false;
+		} finally {
+			if (lock.isHeldByCurrentThread())
+				lock.unlock();
+		}
 	}
 
 	@Override
 	public boolean replace(T key, Integer oldValue, Integer newValue) {
-		if (oldValue == null || newValue == null)
-			return false;
-		return map.replace(key, new AtomicInteger(oldValue), new AtomicInteger(newValue));
+		try {
+			switch (lockingMode) {
+			case Fast:
+				if (lock.isLocked())
+					lock.lock();
+				break;
+			case Safe:
+				lock.lock();
+				break;
+			}
+
+			if (oldValue == null || newValue == null)
+				return false;
+			boolean res = map.replace(key, new AtomicInteger(oldValue), new AtomicInteger(newValue));
+			changeCounter.incrementAndGet();
+			return res;
+		} finally {
+			if (lock.isHeldByCurrentThread())
+				lock.unlock();
+		}
 	}
 
 	@Override
 	public Integer replace(T key, Integer value) {
-		if (value == null)
-			return null;
-		AtomicInteger i = map.replace(key, new AtomicInteger(value));
-		return i == null ? 0 : i.get();
+		try {
+			switch (lockingMode) {
+			case Fast:
+				if (lock.isLocked())
+					lock.lock();
+				break;
+			case Safe:
+				lock.lock();
+				break;
+			}
+
+			if (value == null)
+				return null;
+			AtomicInteger i = map.replace(key, new AtomicInteger(value));
+			changeCounter.incrementAndGet();
+			return i == null ? 0 : i.get();
+		} finally {
+			if (lock.isHeldByCurrentThread())
+				lock.unlock();
+		}
 	}
 
 	/**
@@ -160,10 +333,132 @@ public class ConcurrentCountingMap<T> implements ConcurrentMap<T, Integer> {
 	 * @return The new counter value
 	 */
 	public int increment(T key) {
-		AtomicInteger i = map.putIfAbsent(key, new AtomicInteger(1));
-		if (i == null)
-			return 1;
-		return i.incrementAndGet();
+		try {
+			switch (lockingMode) {
+			case Fast:
+				if (lock.isLocked())
+					lock.lock();
+				break;
+			case Safe:
+				lock.lock();
+				break;
+			}
+
+			AtomicInteger i = map.computeIfAbsent(key, k -> new AtomicInteger(0));
+			changeCounter.incrementAndGet();
+			return i.incrementAndGet();
+		} finally {
+			if (lock.isHeldByCurrentThread())
+				lock.unlock();
+		}
+	}
+
+	/**
+	 * Decrements the counter associated with the given value by one
+	 * 
+	 * @param key The key of the value for which to decrement the counter
+	 * @return The new counter value
+	 */
+	public int decrement(T key) {
+		try {
+			switch (lockingMode) {
+			case Fast:
+				if (lock.isLocked())
+					lock.lock();
+				break;
+			case Safe:
+				lock.lock();
+				break;
+			}
+
+			AtomicInteger i = map.get(key);
+			if (i == null)
+				return 0;
+			int res = i.decrementAndGet();
+			changeCounter.incrementAndGet();
+			return res;
+		} finally {
+			if (lock.isHeldByCurrentThread())
+				lock.unlock();
+		}
+	}
+
+	/**
+	 * Gets all keys that have the given value. Note that values are free to change
+	 * at any time, so the set returned by this method may contain keys that have
+	 * other values as well in case they were mutated by a different thread while
+	 * this method was running.
+	 * 
+	 * @param value The expected value
+	 * @return A set with all keys that have the given value
+	 */
+	public Set<T> getByValue(int value) {
+		Set<T> set = new HashSet<>();
+		for (java.util.Map.Entry<T, AtomicInteger> e : map.entrySet()) {
+			AtomicInteger atomicInt = e.getValue();
+			if (atomicInt != null && atomicInt.get() == value)
+				set.add(e.getKey());
+		}
+		return set;
+	}
+
+	/**
+	 * Sets how whether and how this class shall perform locking
+	 * 
+	 * @param lockingMode The new locking mode
+	 */
+	public void setLockingMode(LockingMode lockingMode) {
+		this.lockingMode = lockingMode;
+	}
+
+	/**
+	 * Creates a snapshot of this map
+	 * 
+	 * @return A copy of the current state of this map
+	 */
+	public ConcurrentCountingMap<T> snapshot() {
+		try {
+			lock.lock();
+
+			ConcurrentCountingMap<T> snapshot = new ConcurrentCountingMap<>();
+			for (T key : map.keySet())
+				snapshot.put(key, map.get(key).get());
+			return snapshot;
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Creates a partial snapshot of this map
+	 * 
+	 * @param subset The subset of element for which to create a partial snapshot
+	 * @return A copy of the current state of this map
+	 */
+	public ConcurrentCountingMap<T> snapshot(Collection<T> subset) {
+		try {
+			lock.lock();
+
+			ConcurrentCountingMap<T> snapshot = new ConcurrentCountingMap<>(subset.size());
+			for (T key : subset) {
+				AtomicInteger atomic = map.get(key);
+				if (atomic != null)
+					snapshot.put(key, atomic.get());
+			}
+			return snapshot;
+		} finally {
+			lock.unlock();
+		}
+	}
+
+	/**
+	 * Gets the current state of the change counter. This counter is modified
+	 * whenever the contents of the map are changed.
+	 * 
+	 * @return The current value of the change counter
+	 */
+	public int getChangeCounter() {
+		return changeCounter.get();
 	}
 
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/data/Abstraction.java b/soot-infoflow/src/soot/jimple/infoflow/data/Abstraction.java
index 69c2fcb..1ba1f29 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/data/Abstraction.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/data/Abstraction.java
@@ -24,7 +24,7 @@ import soot.jimple.infoflow.InfoflowConfiguration;
 import soot.jimple.infoflow.collect.AtomicBitSet;
 import soot.jimple.infoflow.solver.cfg.IInfoflowCFG.UnitContainer;
 import soot.jimple.infoflow.solver.fastSolver.FastSolverLinkedNode;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 
 /**
  * The abstraction class contains all information that is necessary to track the
@@ -43,7 +43,7 @@ public class Abstraction implements Cloneable, FastSolverLinkedNode<Abstraction,
 	protected AccessPath accessPath;
 
 	protected Abstraction predecessor = null;
-	protected Set<Abstraction> neighbors = null;
+	protected volatile Set<Abstraction> neighbors = null;
 	protected Stmt currentStmt = null;
 	protected Stmt correspondingCallSite = null;
 
@@ -91,7 +91,13 @@ public class Abstraction implements Cloneable, FastSolverLinkedNode<Abstraction,
 			int result = 1;
 
 			result = prime * result + abs.hashCode();
+			result = prime * result + ((abs.accessPath == null) ? 0 : abs.accessPath.hashCode());
 			result = prime * result + ((abs.predecessor == null) ? 0 : abs.predecessor.hashCode());
+			result = prime * result + ((abs.currentStmt == null) ? 0 : abs.currentStmt.hashCode());
+
+			result = prime * result + ((abs.sourceContext == null) ? 0 : abs.sourceContext.hashCode());
+			result = prime * result + ((abs.activationUnit == null) ? 0 : abs.activationUnit.hashCode());
+			result = prime * result + ((abs.postdominators == null) ? 0 : abs.postdominators.hashCode());
 
 			abs.neighborHashCode = result;
 			return result;
@@ -132,13 +138,12 @@ public class Abstraction implements Cloneable, FastSolverLinkedNode<Abstraction,
 
 	}
 
-	public Abstraction(SourceSinkDefinition definition, AccessPath sourceVal, Stmt sourceStmt, Object userData,
+	public Abstraction(ISourceSinkDefinition definition, AccessPath sourceVal, Stmt sourceStmt, Object userData,
 			boolean exceptionThrown, boolean isImplicit) {
 		this(sourceVal, new SourceContext(definition, sourceVal, sourceStmt, userData), exceptionThrown, isImplicit);
 	}
 
-	protected Abstraction(AccessPath apToTaint, SourceContext sourceContext, boolean exceptionThrown,
-			boolean isImplicit) {
+	Abstraction(AccessPath apToTaint, SourceContext sourceContext, boolean exceptionThrown, boolean isImplicit) {
 		this.sourceContext = sourceContext;
 		this.accessPath = apToTaint;
 		this.activationUnit = null;
diff --git a/soot-infoflow/src/soot/jimple/infoflow/data/AbstractionAtSink.java b/soot-infoflow/src/soot/jimple/infoflow/data/AbstractionAtSink.java
index 1d0620b..107977b 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/data/AbstractionAtSink.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/data/AbstractionAtSink.java
@@ -11,25 +11,23 @@
 package soot.jimple.infoflow.data;
 
 import soot.jimple.Stmt;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 
 public class AbstractionAtSink {
 
-	private final SourceSinkDefinition sinkDefinition;
+	private final ISourceSinkDefinition sinkDefinition;
 	private final Abstraction abstraction;
 	private final Stmt sinkStmt;
 
 	/**
 	 * Creates a new instance of the {@link AbstractionAtSink} class
 	 * 
-	 * @param sinkDefinition
-	 *            The original definition of the sink that has been reached
-	 * @param abstraction
-	 *            The abstraction with which the sink has been reached
-	 * @param sinkStmt
-	 *            The statement that triggered the sink
+	 * @param sinkDefinition The original definition of the sink that has been
+	 *                       reached
+	 * @param abstraction    The abstraction with which the sink has been reached
+	 * @param sinkStmt       The statement that triggered the sink
 	 */
-	public AbstractionAtSink(SourceSinkDefinition sinkDefinition, Abstraction abstraction, Stmt sinkStmt) {
+	public AbstractionAtSink(ISourceSinkDefinition sinkDefinition, Abstraction abstraction, Stmt sinkStmt) {
 		this.sinkDefinition = sinkDefinition;
 		this.abstraction = abstraction;
 		this.sinkStmt = sinkStmt;
@@ -40,7 +38,7 @@ public class AbstractionAtSink {
 	 * 
 	 * @return The original definition of the sink that has been reached
 	 */
-	public SourceSinkDefinition getSinkDefinition() {
+	public ISourceSinkDefinition getSinkDefinition() {
 		return sinkDefinition;
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/data/AccessPathFactory.java b/soot-infoflow/src/soot/jimple/infoflow/data/AccessPathFactory.java
index 87bc6af..0015ff1 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/data/AccessPathFactory.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/data/AccessPathFactory.java
@@ -131,8 +131,15 @@ public class AccessPathFactory {
 			boolean taintSubFields, boolean cutFirstField, boolean reduceBases, ArrayTaintType arrayTaintType,
 			boolean canHaveImmutableAliases) {
 		// Make sure that the base object is valid
-		assert (val == null && appendingFields != null && appendingFields.length > 0)
-				|| AccessPath.canContainValue(val);
+		if (val != null && !AccessPath.canContainValue(val)) {
+			logger.error(String.format("Access paths cannot be rooted in values of type %s", val.getClass().getName()));
+			return null;
+		}
+
+		// Make sure that we have data for an access path at all
+		if (val == null && (appendingFields == null || appendingFields.length == 0))
+			return null;
+
 		final AccessPathConfiguration accessPathConfig = config.getAccessPathConfiguration();
 
 		// Do we track types?
diff --git a/soot-infoflow/src/soot/jimple/infoflow/data/FlowDroidMemoryManager.java b/soot-infoflow/src/soot/jimple/infoflow/data/FlowDroidMemoryManager.java
index fa98b75..0d1338a 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/data/FlowDroidMemoryManager.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/data/FlowDroidMemoryManager.java
@@ -179,25 +179,10 @@ public class FlowDroidMemoryManager implements IMemoryManager<Abstraction, Unit>
 		if (input == output)
 			return output;
 
-		// If the flow function gave us a chain of abstractions, we can
-		// compact it
-		Abstraction pred = output.getPredecessor();
-		if (pred != null && pred != input)
-			output.setPredecessor(input);
-
 		// If the abstraction didn't change at all, we can use the old one
 		if (input.equals(output)) {
 			if (output.getCurrentStmt() == null || input.getCurrentStmt() == output.getCurrentStmt())
 				return input;
-			if (input.getCurrentStmt() == null) {
-				synchronized (input) {
-					if (input.getCurrentStmt() == null) {
-						input.setCurrentStmt(output.getCurrentStmt());
-						input.setCorrespondingCallSite(output.getCorrespondingCallSite());
-						return input;
-					}
-				}
-			}
 		}
 
 		// We check for a cached version of the access path
diff --git a/soot-infoflow/src/soot/jimple/infoflow/data/SootMethodAndClass.java b/soot-infoflow/src/soot/jimple/infoflow/data/SootMethodAndClass.java
index 1cf91ae..bc98eeb 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/data/SootMethodAndClass.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/data/SootMethodAndClass.java
@@ -173,6 +173,7 @@ public class SootMethodAndClass {
 			if (!isFirst)
 				sb.append(",");
 			sb.append(param);
+			isFirst = false;
 		}
 		sb.append(")>");
 		return sb.toString();
diff --git a/soot-infoflow/src/soot/jimple/infoflow/data/SourceContext.java b/soot-infoflow/src/soot/jimple/infoflow/data/SourceContext.java
index 0961303..7d09693 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/data/SourceContext.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/data/SourceContext.java
@@ -1,7 +1,7 @@
 package soot.jimple.infoflow.data;
 
 import soot.jimple.Stmt;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 
 /**
  * Class representing a source value together with the statement that created it
@@ -9,18 +9,18 @@ import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
  * @author Steven Arzt
  */
 public class SourceContext implements Cloneable {
-	protected final SourceSinkDefinition definition;
+	protected final ISourceSinkDefinition definition;
 	protected final AccessPath accessPath;
 	protected final Stmt stmt;
 	protected final Object userData;
 
 	private int hashCode = 0;
 
-	public SourceContext(SourceSinkDefinition definition, AccessPath accessPath, Stmt stmt) {
+	public SourceContext(ISourceSinkDefinition definition, AccessPath accessPath, Stmt stmt) {
 		this(definition, accessPath, stmt, null);
 	}
 
-	public SourceContext(SourceSinkDefinition definition, AccessPath accessPath, Stmt stmt, Object userData) {
+	public SourceContext(ISourceSinkDefinition definition, AccessPath accessPath, Stmt stmt, Object userData) {
 		assert accessPath != null;
 
 		this.definition = definition;
@@ -29,7 +29,7 @@ public class SourceContext implements Cloneable {
 		this.userData = userData;
 	}
 
-	public SourceSinkDefinition getDefinition() {
+	public ISourceSinkDefinition getDefinition() {
 		return this.definition;
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/data/SourceContextAndPath.java b/soot-infoflow/src/soot/jimple/infoflow/data/SourceContextAndPath.java
index c7bfe98..532140c 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/data/SourceContextAndPath.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/data/SourceContextAndPath.java
@@ -9,7 +9,7 @@ import heros.solver.Pair;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.InfoflowConfiguration;
 import soot.jimple.infoflow.InfoflowConfiguration.PathConfiguration;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.util.extensiblelist.ExtensibleList;
 
 /**
@@ -24,11 +24,11 @@ public class SourceContextAndPath extends SourceContext implements Cloneable {
 	protected int neighborCounter = 0;
 	private int hashCode = 0;
 
-	public SourceContextAndPath(SourceSinkDefinition definition, AccessPath value, Stmt stmt) {
+	public SourceContextAndPath(ISourceSinkDefinition definition, AccessPath value, Stmt stmt) {
 		this(definition, value, stmt, null);
 	}
 
-	public SourceContextAndPath(SourceSinkDefinition definition, AccessPath value, Stmt stmt, Object userData) {
+	public SourceContextAndPath(ISourceSinkDefinition definition, AccessPath value, Stmt stmt, Object userData) {
 		super(definition, value, stmt, userData);
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/BaseEntryPointCreator.java b/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/BaseEntryPointCreator.java
index 970f9a2..dc90a08 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/BaseEntryPointCreator.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/BaseEntryPointCreator.java
@@ -45,7 +45,6 @@ import soot.Type;
 import soot.Unit;
 import soot.Value;
 import soot.VoidType;
-import soot.dava.internal.javaRep.DIntConstant;
 import soot.javaToJimple.LocalGenerator;
 import soot.jimple.AssignStmt;
 import soot.jimple.DoubleConstant;
@@ -162,6 +161,22 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 */
 	protected abstract SootMethod createDummyMainInternal();
 
+	/**
+	 * Gets the class that contains the dummy main method. If such a class does not
+	 * exist yet, it is created
+	 * 
+	 * @return The class tha contains the dummy main method
+	 */
+	protected SootClass getOrCreateDummyMainClass() {
+		SootClass mainClass = Scene.v().getSootClassUnsafe(dummyClassName);
+		if (mainClass == null) {
+			mainClass = Scene.v().makeSootClass(dummyClassName);
+			mainClass.setResolvingLevel(SootClass.BODIES);
+			Scene.v().addClass(mainClass);
+		}
+		return mainClass;
+	}
+
 	/**
 	 * Creates a new, empty main method containing the given body
 	 * 
@@ -170,19 +185,12 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	protected void createEmptyMainMethod() {
 		// If we already have a main class, we need to make sure to use a fresh
 		// method name
-		final SootClass mainClass;
+		int methodIndex = 0;
 		String methodName = dummyMethodName;
-		if (Scene.v().containsClass(dummyClassName)) {
-			int methodIndex = 0;
-			mainClass = Scene.v().getSootClass(dummyClassName);
-			if (!overwriteDummyMainMethod)
-				while (mainClass.declaresMethodByName(methodName))
-					methodName = dummyMethodName + "_" + methodIndex++;
-		} else {
-			mainClass = Scene.v().makeSootClass(dummyClassName);
-			mainClass.setResolvingLevel(SootClass.BODIES);
-			Scene.v().addClass(mainClass);
-		}
+		SootClass mainClass = getOrCreateDummyMainClass();
+		if (!overwriteDummyMainMethod)
+			while (mainClass.declaresMethodByName(methodName))
+				methodName = dummyMethodName + "_" + methodIndex++;
 
 		Type stringArrayType = ArrayType.v(RefType.v("java.lang.String"), 1);
 
@@ -235,38 +243,44 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 		// empty in default implementation
 	}
 
+	/**
+	 * Gets a field name that is not already in use by some field
+	 * 
+	 * @param baseName The base name, i.e., prefix of the new field
+	 * @return A field name that is still free
+	 */
+	protected String getNonCollidingFieldName(String baseName) {
+		String fieldName = baseName;
+		int fieldIdx = 0;
+		final SootClass mainClass = getOrCreateDummyMainClass();
+		while (mainClass.declaresFieldByName(fieldName))
+			fieldName = baseName + "_" + fieldIdx++;
+		return fieldName;
+	}
+
 	/**
 	 * Builds a new invocation statement that invokes the given method
 	 * 
 	 * @param methodToCall The method to call
-	 * @param body         The body in which to create the invocation statement
 	 * @param classLocal   The local containing an instance of the class on which to
 	 *                     invoke the method
-	 * @param gen          The local generator to be used for generating locals that
-	 *                     hold any additional values required for the call
-	 *                     parameters
 	 * @return The newly created invocation statement
 	 */
-	protected Stmt buildMethodCall(SootMethod methodToCall, Body body, Local classLocal, LocalGenerator gen) {
-		return buildMethodCall(methodToCall, body, classLocal, gen, Collections.<SootClass>emptySet());
+	protected Stmt buildMethodCall(SootMethod methodToCall, Local classLocal) {
+		return buildMethodCall(methodToCall, classLocal, Collections.<SootClass>emptySet());
 	}
 
 	/**
 	 * Builds a new invocation statement that invokes the given method
 	 * 
 	 * @param methodToCall  The method to call
-	 * @param body          The body in which to create the invocation statement
 	 * @param classLocal    The local containing an instance of the class on which
 	 *                      to invoke the method
-	 * @param gen           The local generator to be used for generating locals
-	 *                      that hold any additional values required for the call
-	 *                      parameters
 	 * @param parentClasses The classes for which we already have instances that
 	 *                      shall be reused
 	 * @return The newly created invocation statement
 	 */
-	protected Stmt buildMethodCall(SootMethod methodToCall, Body body, Local classLocal, LocalGenerator gen,
-			Set<SootClass> parentClasses) {
+	protected Stmt buildMethodCall(SootMethod methodToCall, Local classLocal, Set<SootClass> parentClasses) {
 		// If we don't have a method, we cannot call it (sad but true)
 		if (methodToCall == null)
 			return null;
@@ -285,7 +299,7 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 				Set<SootClass> constructionStack = new HashSet<SootClass>();
 				if (!allowSelfReferences)
 					constructionStack.add(methodToCall.getDeclaringClass());
-				args.add(getValueForType(body, gen, tp, constructionStack, parentClasses));
+				args.add(getValueForType(tp, constructionStack, parentClasses));
 			}
 
 			if (methodToCall.isStatic())
@@ -311,7 +325,7 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 
 		Stmt stmt;
 		if (!(methodToCall.getReturnType() instanceof VoidType)) {
-			Local returnLocal = gen.generateLocal(methodToCall.getReturnType());
+			Local returnLocal = generator.generateLocal(methodToCall.getReturnType());
 			stmt = Jimple.v().newAssignStmt(returnLocal, invokeExpr);
 
 		} else {
@@ -336,8 +350,6 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 * Creates a value of the given type to be used as a substitution in method
 	 * invocations or fields
 	 * 
-	 * @param body              The body in which to create the value
-	 * @param gen               The local generator
 	 * @param tp                The type for which to get a value
 	 * @param constructionStack The set of classes we're currently constructing.
 	 *                          Attempts to create a parameter of one of these
@@ -349,17 +361,14 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 *                          used instead of creating a new one.
 	 * @return The generated value, or null if no value could be generated
 	 */
-	private Value getValueForType(Body body, LocalGenerator gen, Type tp, Set<SootClass> constructionStack,
-			Set<SootClass> parentClasses) {
-		return getValueForType(body, gen, tp, constructionStack, parentClasses, null);
+	protected Value getValueForType(Type tp, Set<SootClass> constructionStack, Set<SootClass> parentClasses) {
+		return getValueForType(tp, constructionStack, parentClasses, null);
 	}
 
 	/**
 	 * Creates a value of the given type to be used as a substitution in method
 	 * invocations or fields
 	 * 
-	 * @param body              The body in which to create the value
-	 * @param gen               The local generator
 	 * @param tp                The type for which to get a value
 	 * @param constructionStack The set of classes we're currently constructing.
 	 *                          Attempts to create a parameter of one of these
@@ -373,8 +382,8 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 *                          to provide a value of the requested type
 	 * @return The generated value, or null if no value could be generated
 	 */
-	private Value getValueForType(Body body, LocalGenerator gen, Type tp, Set<SootClass> constructionStack,
-			Set<SootClass> parentClasses, Set<Local> generatedLocals) {
+	protected Value getValueForType(Type tp, Set<SootClass> constructionStack, Set<SootClass> parentClasses,
+			Set<Local> generatedLocals) {
 		// Depending on the parameter type, we try to find a suitable
 		// concrete substitution
 		if (isSimpleType(tp.toString()))
@@ -393,12 +402,11 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 					}
 
 				// If this is a system class, we may want to skip it
-				if (ignoreSystemClassParams && SystemClassHandler.isClassInSystemPackage(classToType.getName()))
+				if (ignoreSystemClassParams && SystemClassHandler.v().isClassInSystemPackage(classToType.getName()))
 					return NullConstant.v();
 
 				// Create a new instance to plug in here
-				Value val = generateClassConstructor(classToType, body, constructionStack, parentClasses,
-						generatedLocals);
+				Value val = generateClassConstructor(classToType, constructionStack, parentClasses, generatedLocals);
 
 				// If we cannot create a parameter, we try a null reference.
 				// Better than not creating the whole invocation...
@@ -412,8 +420,7 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 				return val;
 			}
 		} else if (tp instanceof ArrayType) {
-			Value arrVal = buildArrayOfType(body, gen, (ArrayType) tp, constructionStack, parentClasses,
-					generatedLocals);
+			Value arrVal = buildArrayOfType((ArrayType) tp, constructionStack, parentClasses, generatedLocals);
 			if (arrVal == null) {
 				logger.warn("Array parameter substituted by null");
 				return NullConstant.v();
@@ -430,8 +437,6 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 * Constructs an array of the given type with a single element of this type in
 	 * the given method
 	 * 
-	 * @param body              The body of the method in which to create the array
-	 * @param gen               The local generator
 	 * @param tp                The type of which to create the array
 	 * @param constructionStack Set of classes currently being built to avoid
 	 *                          constructor loops
@@ -443,13 +448,13 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 * @return The local referencing the newly created array, or null if the array
 	 *         generation failed
 	 */
-	private Value buildArrayOfType(Body body, LocalGenerator gen, ArrayType tp, Set<SootClass> constructionStack,
-			Set<SootClass> parentClasses, Set<Local> generatedLocals) {
+	private Value buildArrayOfType(ArrayType tp, Set<SootClass> constructionStack, Set<SootClass> parentClasses,
+			Set<Local> generatedLocals) {
 		// Generate a single element in the array
-		Value singleElement = getValueForType(body, gen, tp.getElementType(), constructionStack, parentClasses);
+		Value singleElement = getValueForType(tp.getElementType(), constructionStack, parentClasses);
 
 		// Generate a new single-element array
-		Local local = gen.generateLocal(tp);
+		Local local = generator.generateLocal(tp);
 		NewArrayExpr newArrayExpr = Jimple.v().newNewArrayExpr(tp.getElementType(), IntConstant.v(1));
 		AssignStmt assignArray = Jimple.v().newAssignStmt(local, newArrayExpr);
 		body.getUnits().add(assignArray);
@@ -464,22 +469,18 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 * Generates code which creates a new instance of the given class.
 	 * 
 	 * @param createdClass The class of which to create an instance
-	 * @param body         The body to which to add the new statements ("new"
-	 *                     statement, constructor call, etc.)
 	 * @return The local containing the new object instance if the operation
 	 *         completed successfully, otherwise null.
 	 */
-	protected Local generateClassConstructor(SootClass createdClass, Body body) {
-		return this.generateClassConstructor(createdClass, body, new HashSet<SootClass>(),
-				Collections.<SootClass>emptySet(), null);
+	protected Local generateClassConstructor(SootClass createdClass) {
+		return this.generateClassConstructor(createdClass, new HashSet<SootClass>(), Collections.<SootClass>emptySet(),
+				null);
 	}
 
 	/**
 	 * Generates code which creates a new instance of the given class.
 	 * 
 	 * @param createdClass  The class of which to create an instance
-	 * @param body          The body to which to add the new statements ("new"
-	 *                      statement, constructor call, etc.)
 	 * @param parentClasses If a constructor call requires an object of a type which
 	 *                      is compatible with one of the types in this list, the
 	 *                      already-created object is used instead of creating a new
@@ -487,16 +488,31 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 * @return The local containing the new object instance if the operation
 	 *         completed successfully, otherwise null.
 	 */
-	protected Local generateClassConstructor(SootClass createdClass, Body body, Set<SootClass> parentClasses) {
-		return this.generateClassConstructor(createdClass, body, new HashSet<SootClass>(), parentClasses, null);
+	protected Local generateClassConstructor(SootClass createdClass, Set<SootClass> parentClasses) {
+		return this.generateClassConstructor(createdClass, new HashSet<SootClass>(), parentClasses, null);
+	}
+
+	/**
+	 * Determines whether a class is accepted for generating a constructor.
+	 * 
+	 * @param clazz The class of which to create an instance
+	 * @return Whether the class is accepted for generating a constructor
+	 */
+	protected boolean acceptClass(SootClass clazz) {
+		// We cannot create instances of phantom classes as we do not have any
+		// constructor information for them
+		if (clazz.isPhantom() || clazz.isPhantomClass()) {
+			logger.warn("Cannot generate constructor for phantom class {}", clazz.getName());
+			return false;
+		}
+
+		return true;
 	}
 
 	/**
 	 * Generates code which creates a new instance of the given class.
 	 * 
 	 * @param createdClass      The class of which to create an instance
-	 * @param body              The body to which to add the new statements ("new"
-	 *                          statement, constructor call, etc.)
 	 * @param constructionStack The stack of classes currently under construction.
 	 *                          This is used to detect constructor loops. If a
 	 *                          constructor requires a parameter of a type that is
@@ -512,7 +528,7 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 * @return The local containing the new object instance if the operation
 	 *         completed successfully, otherwise null.
 	 */
-	protected Local generateClassConstructor(SootClass createdClass, Body body, Set<SootClass> constructionStack,
+	protected Local generateClassConstructor(SootClass createdClass, Set<SootClass> constructionStack,
 			Set<SootClass> parentClasses, Set<Local> tempLocals) {
 		if (createdClass == null || this.failedClasses.contains(createdClass))
 			return null;
@@ -522,16 +538,11 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 		if (existingLocal != null)
 			return existingLocal;
 
-		// We cannot create instances of phantom classes as we do not have any
-		// constructor information for them
-		if (createdClass.isPhantom() || createdClass.isPhantomClass()) {
-			logger.warn("Cannot generate constructor for phantom class {}", createdClass.getName());
+		if (!acceptClass(createdClass)) {
 			failedClasses.add(createdClass);
 			return null;
 		}
 
-		LocalGenerator generator = new LocalGenerator(body);
-
 		// if sootClass is simpleClass:
 		if (isSimpleType(createdClass.toString())) {
 			Local varLocal = generator.generateLocal(getSimpleTypeFromType(createdClass.getType()));
@@ -559,7 +570,7 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 			return tempLocal;
 		}
 		if (createdClass.isInterface() || createdClass.isAbstract()) {
-			return generateSubstitutedClassConstructor(createdClass, body, constructionStack, parentClasses);
+			return generateSubstitutedClassConstructor(createdClass, constructionStack, parentClasses);
 		} else {
 			// Find a constructor we can invoke. We do this first as we don't
 			// want
@@ -614,7 +625,7 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 						else
 							params.add(NullConstant.v());
 					} else {
-						Value val = getValueForType(body, generator, type, newStack, parentClasses, tempLocals);
+						Value val = getValueForType(type, newStack, parentClasses, tempLocals);
 						params.add(val);
 					}
 				}
@@ -649,8 +660,6 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 * that is substituted with an actual implementation
 	 * 
 	 * @param createdClass      The class for which to create a constructor call
-	 * @param body              The body of the dummy main method to which to add
-	 *                          the call statement
 	 * @param constructionStack The stack for making sure that we do not run into
 	 *                          loops
 	 * @param parentClasses     If a constructor call requires an object of a type
@@ -660,8 +669,8 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 	 * @return The local containing the new object instance if the operation
 	 *         completed successfully, otherwise null.
 	 */
-	private Local generateSubstitutedClassConstructor(SootClass createdClass, Body body,
-			Set<SootClass> constructionStack, Set<SootClass> parentClasses) {
+	private Local generateSubstitutedClassConstructor(SootClass createdClass, Set<SootClass> constructionStack,
+			Set<SootClass> parentClasses) {
 		// This feature must be enabled explicitly
 		if (!substituteCallParams) {
 			logger.warn("Cannot create valid constructor for {}, because it is {} and cannot substitute with subclass",
@@ -683,7 +692,7 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 		// substitution, we're in trouble
 		for (SootClass sClass : classes)
 			if (substituteClasses.contains(sClass.toString())) {
-				Local cons = generateClassConstructor(sClass, body, constructionStack, parentClasses, null);
+				Local cons = generateClassConstructor(sClass, constructionStack, parentClasses, null);
 				if (cons == null)
 					continue;
 				return cons;
@@ -695,7 +704,7 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 		return null;
 	}
 
-	private Type getSimpleTypeFromType(Type type) {
+	protected Type getSimpleTypeFromType(Type type) {
 		if (type.toString().equals("java.lang.String")) {
 			assert type instanceof RefType;
 			return RefType.v(((RefType) type).getSootClass());
@@ -749,7 +758,7 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 		if (t instanceof DoubleType)
 			return DoubleConstant.v(0);
 		if (t instanceof BooleanType)
-			return DIntConstant.v(0, BooleanType.v());
+			return IntConstant.v(0);
 
 		// also for arrays etc.
 		return NullConstant.v();
@@ -790,10 +799,8 @@ public abstract class BaseEntryPointCreator implements IEntryPointCreator {
 
 	/**
 	 * Eliminates all loops of length 0 (if a goto <if a>)
-	 * 
-	 * @param body The body from which to eliminate the self-loops
 	 */
-	protected void eliminateSelfLoops(Body body) {
+	protected void eliminateSelfLoops() {
 		// Get rid of self-loops
 		for (Iterator<Unit> unitIt = body.getUnits().iterator(); unitIt.hasNext();) {
 			Unit u = unitIt.next();
diff --git a/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/DefaultEntryPointCreator.java b/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/DefaultEntryPointCreator.java
index 594ab33..1a3f6d3 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/DefaultEntryPointCreator.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/DefaultEntryPointCreator.java
@@ -19,7 +19,6 @@ import java.util.Set;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import soot.Body;
 import soot.IntType;
 import soot.Local;
 import soot.Scene;
@@ -27,7 +26,6 @@ import soot.SootClass;
 import soot.SootField;
 import soot.SootMethod;
 import soot.Value;
-import soot.javaToJimple.LocalGenerator;
 import soot.jimple.EqExpr;
 import soot.jimple.GotoStmt;
 import soot.jimple.IfStmt;
@@ -54,10 +52,10 @@ public class DefaultEntryPointCreator extends BaseEntryPointCreator {
 	/**
 	 * Creates a new instanceof the {@link DefaultEntryPointCreator} class
 	 * 
-	 * @param methodsToCall
-	 *            A collection containing the methods to be called in the dummy main
-	 *            method. Note that the order of the method calls is simulated to be
-	 *            arbitrary. Entries must be valid Soot method signatures.
+	 * @param methodsToCall A collection containing the methods to be called in the
+	 *                      dummy main method. Note that the order of the method
+	 *                      calls is simulated to be arbitrary. Entries must be
+	 *                      valid Soot method signatures.
 	 */
 	public DefaultEntryPointCreator(Collection<String> methodsToCall) {
 		this.methodsToCall = methodsToCall;
@@ -68,8 +66,6 @@ public class DefaultEntryPointCreator extends BaseEntryPointCreator {
 		Map<String, Set<String>> classMap = SootMethodRepresentationParser.v().parseClassNames(methodsToCall, false);
 
 		// create new class:
-		Body body = mainMethod.getActiveBody();
-		LocalGenerator generator = new LocalGenerator(body);
 		HashMap<String, Local> localVarsForClasses = new HashMap<String, Local>();
 
 		// create constructors:
@@ -77,7 +73,7 @@ public class DefaultEntryPointCreator extends BaseEntryPointCreator {
 			SootClass createdClass = Scene.v().forceResolve(className, SootClass.BODIES);
 			createdClass.setApplicationClass();
 
-			Local localVal = generateClassConstructor(createdClass, body);
+			Local localVal = generateClassConstructor(createdClass);
 			if (localVal == null) {
 				logger.warn("Cannot generate constructor for class: {}", createdClass);
 				continue;
@@ -108,7 +104,7 @@ public class DefaultEntryPointCreator extends BaseEntryPointCreator {
 				NopStmt thenStmt = jimple.newNopStmt();
 				IfStmt ifStmt = jimple.newIfStmt(cond, thenStmt);
 				body.getUnits().add(ifStmt);
-				buildMethodCall(currentMethod, body, classLocal, generator);
+				buildMethodCall(currentMethod, classLocal);
 				body.getUnits().add(thenStmt);
 			}
 		}
@@ -118,7 +114,7 @@ public class DefaultEntryPointCreator extends BaseEntryPointCreator {
 
 		body.getUnits().add(Jimple.v().newReturnVoidStmt());
 		NopEliminator.v().transform(body);
-		eliminateSelfLoops(body);
+		eliminateSelfLoops();
 		return mainMethod;
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/SequentialEntryPointCreator.java b/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/SequentialEntryPointCreator.java
index d146227..f240b17 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/SequentialEntryPointCreator.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/entryPointCreators/SequentialEntryPointCreator.java
@@ -4,13 +4,11 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 
-import soot.Body;
 import soot.Local;
 import soot.Scene;
 import soot.SootClass;
 import soot.SootField;
 import soot.SootMethod;
-import soot.javaToJimple.LocalGenerator;
 import soot.jimple.Jimple;
 import soot.jimple.infoflow.data.SootMethodAndClass;
 import soot.jimple.infoflow.util.SootMethodRepresentationParser;
@@ -45,15 +43,11 @@ public class SequentialEntryPointCreator extends BaseEntryPointCreator {
 	protected SootMethod createDummyMainInternal() {
 		Map<String, Set<String>> classMap = SootMethodRepresentationParser.v().parseClassNames(methodsToCall, false);
 
-		// create new class:
-		Body body = mainMethod.getActiveBody();
-		LocalGenerator generator = new LocalGenerator(body);
-
 		// Create the classes
 		for (String className : classMap.keySet()) {
 			SootClass createdClass = Scene.v().forceResolve(className, SootClass.BODIES);
 			createdClass.setApplicationClass();
-			Local localVal = generateClassConstructor(createdClass, body);
+			Local localVal = generateClassConstructor(createdClass);
 			if (localVal == null) {
 				logger.warn("Cannot generate constructor for class: {}", createdClass);
 				continue;
@@ -70,7 +64,7 @@ public class SequentialEntryPointCreator extends BaseEntryPointCreator {
 				else if (methodToInvoke.isConcrete() && !methodToInvoke.isConstructor()) {
 					// Load the method
 					methodToInvoke.retrieveActiveBody();
-					buildMethodCall(methodToInvoke, body, localVal, generator);
+					buildMethodCall(methodToInvoke, localVal);
 				}
 			}
 		}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/handlers/SequentialTaintPropagationHandler.java b/soot-infoflow/src/soot/jimple/infoflow/handlers/SequentialTaintPropagationHandler.java
index fefb2b9..090b54f 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/handlers/SequentialTaintPropagationHandler.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/handlers/SequentialTaintPropagationHandler.java
@@ -30,9 +30,8 @@ public class SequentialTaintPropagationHandler implements TaintPropagationHandle
 	/**
 	 * Creates a sequence of taint propagation handlers from the given list
 	 * 
-	 * @param handlers
-	 *            A list of taint propagation handlers to which all calls shall be
-	 *            relayed
+	 * @param handlers A list of taint propagation handlers to which all calls shall
+	 *                 be relayed
 	 */
 	public SequentialTaintPropagationHandler(List<TaintPropagationHandler> handlers) {
 		this.innerHandlers = new ArrayList<>(handlers);
@@ -41,11 +40,11 @@ public class SequentialTaintPropagationHandler implements TaintPropagationHandle
 	/**
 	 * Adds a new handler to this sequence of handlers
 	 * 
-	 * @param handler
-	 *            The handler to add to the sequence
+	 * @param handler The handler to add to the sequence
 	 */
 	public void addHandler(TaintPropagationHandler handler) {
-		this.innerHandlers.add(handler);
+		if (handler != null)
+			this.innerHandlers.add(handler);
 	}
 
 	/**
@@ -75,4 +74,16 @@ public class SequentialTaintPropagationHandler implements TaintPropagationHandle
 		return resultSet;
 	}
 
+	/**
+	 * Adds all of the given taint propagation handlers
+	 * 
+	 * @param handlers The taint propagation handlers to add
+	 */
+	public void addAllHandlers(TaintPropagationHandler[] handlers) {
+		if (handlers != null && handlers.length > 0) {
+			for (TaintPropagationHandler handler : handlers)
+				addHandler(handler);
+		}
+	}
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/memory/FlowDroidMemoryWatcher.java b/soot-infoflow/src/soot/jimple/infoflow/memory/FlowDroidMemoryWatcher.java
index 121d6a0..da8c884 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/memory/FlowDroidMemoryWatcher.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/memory/FlowDroidMemoryWatcher.java
@@ -74,7 +74,7 @@ public class FlowDroidMemoryWatcher {
 			}
 
 		});
-		MemoryWarningSystem.setWarningThreshold(threshold);
+		warningSystem.setWarningThreshold(threshold);
 		this.results = res;
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/memory/MemoryWarningSystem.java b/soot-infoflow/src/soot/jimple/infoflow/memory/MemoryWarningSystem.java
index 8541c1f..aa10e1d 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/memory/MemoryWarningSystem.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/memory/MemoryWarningSystem.java
@@ -5,10 +5,15 @@ import java.lang.management.MemoryMXBean;
 import java.lang.management.MemoryNotificationInfo;
 import java.lang.management.MemoryPoolMXBean;
 import java.lang.management.MemoryType;
+import java.lang.management.MemoryUsage;
+import java.text.MessageFormat;
 import java.util.ArrayList;
+import java.util.Comparator;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.TreeSet;
 
 import javax.management.ListenerNotFoundException;
 import javax.management.Notification;
@@ -28,7 +33,7 @@ import org.slf4j.LoggerFactory;
  * lot of time left to perform corrective measures if the warning threshold is
  * reached.
  * 
- * @author Steven Arzt
+ * @author Steven Arzt, Marc Miltenberger
  *
  */
 public class MemoryWarningSystem {
@@ -53,31 +58,31 @@ public class MemoryWarningSystem {
 
 	}
 
-	private static final MemoryPoolMXBean tenuredGenPool = findTenuredGenPool();
+	private final static MemoryPoolMXBean tenuredGenPool = findTenuredGenPool();
 
 	private final Set<OnMemoryThresholdReached> listeners = new HashSet<>();
-	private final NotificationListener memoryListener;
+	private final static NotificationListener memoryListener;
 	private boolean isClosed = false;
 
-	/**
-	 * Creates a new instance of the {@link MemoryWarningSystem} class
-	 */
-	public MemoryWarningSystem() {
-		this.memoryListener = new NotificationListener() {
+	private long threshold;
+
+	private static Thread thrLowMemoryWarningThread;
+
+	private static TreeSet<MemoryWarningSystem> warningSystems = new TreeSet<>(new Comparator<MemoryWarningSystem>() {
+
+		@Override
+		public int compare(MemoryWarningSystem o1, MemoryWarningSystem o2) {
+			return Long.compare(o1.threshold, o2.threshold);
+		}
+	});
+
+	static {
+		memoryListener = new NotificationListener() {
 
 			@Override
 			public void handleNotification(Notification notification, Object handback) {
 				if (notification.getType().equals(MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED)) {
-					long maxMemory = tenuredGenPool.getUsage().getMax();
-					long usedMemory = tenuredGenPool.getUsage().getUsed();
-
-					Runtime runtime = Runtime.getRuntime();
-					long usedMem = runtime.totalMemory() - runtime.freeMemory();
-
-					logger.info("Triggering memory warning at " + (usedMem / 1000 / 1000) + " MB ("
-							+ (usedMem / 1000 / 1000) + " MB in tenured gen)...");
-					for (OnMemoryThresholdReached listener : listeners)
-						listener.onThresholdReached(usedMemory, maxMemory);
+					triggerNotification();
 				}
 			}
 		};
@@ -93,6 +98,35 @@ public class MemoryWarningSystem {
 			}
 
 		}, null);
+
+	}
+
+	private static long triggerNotification() {
+		long maxMemory = tenuredGenPool.getUsage().getMax();
+		long usedMemory = tenuredGenPool.getUsage().getUsed();
+
+		Runtime runtime = Runtime.getRuntime();
+		long usedMem = runtime.totalMemory() - runtime.freeMemory();
+
+		synchronized (warningSystems) {
+			Iterator<MemoryWarningSystem> it = warningSystems.iterator();
+			while (it.hasNext()) {
+				MemoryWarningSystem ws = it.next();
+				if (ws.threshold <= usedMemory) {
+					logger.info("Triggering memory warning at " + (usedMem / 1000 / 1000) + " MB ("
+							+ (maxMemory / 1000 / 1000) + " MB max, " + (usedMemory / 1000 / 1000)
+							+ " in watched memory pool)...");
+					for (OnMemoryThresholdReached listener : ws.listeners)
+						listener.onThresholdReached(usedMemory, maxMemory);
+					it.remove();
+				} else {
+					// At least one warning systme has a higher threshold
+					tenuredGenPool.setUsageThreshold(ws.threshold);
+					return ws.threshold;
+				}
+			}
+			return -1;
+		}
 	}
 
 	@Override
@@ -115,7 +149,7 @@ public class MemoryWarningSystem {
 	 * Tenured Space Pool can be determined by it being of type HEAP and by it being
 	 * possible to set the usage threshold.
 	 */
-	private static MemoryPoolMXBean findTenuredGenPool() {
+	public static MemoryPoolMXBean findTenuredGenPool() {
 		List<MemoryPoolMXBean> usablePools = new ArrayList<>();
 		for (MemoryPoolMXBean pool : ManagementFactory.getMemoryPoolMXBeans()) {
 			// Can we put a threshold on this pool?
@@ -144,13 +178,87 @@ public class MemoryWarningSystem {
 	 * 
 	 * @param percentage
 	 */
-	public static void setWarningThreshold(double percentage) {
+	public void setWarningThreshold(double percentage) {
 		if (percentage <= 0.0 || percentage > 1.0) {
 			throw new IllegalArgumentException("Percentage not in range");
 		}
 		long maxMemory = tenuredGenPool.getUsage().getMax();
 		long warningThreshold = (long) (maxMemory * percentage);
-		tenuredGenPool.setUsageThreshold(warningThreshold);
+		synchronized (warningSystems) {
+			// If element has changed, it needs to removed first
+			warningSystems.remove(this);
+			this.threshold = warningThreshold;
+			logger.info(MessageFormat.format("Registered a memory warning system for {0} MiB",
+					(threshold / 1024D / 1024D)));
+			warningSystems.add(this);
+			MemoryUsage usage = tenuredGenPool.getUsage();
+			long threshold = warningSystems.iterator().next().threshold;
+			boolean useOwnImplementation = !tenuredGenPool.isUsageThresholdSupported();
+			if (!useOwnImplementation && usage != null && usage.getUsed() > threshold) {
+				tenuredGenPool.setUsageThreshold(threshold);
+			} else {
+				// when the usage is already above the threshold, we use our own implementation,
+				// since the jvm implementation does not seem to get called in that case.
+				useOwnImplementation = true;
+			}
+			if (useOwnImplementation) {
+				// No JVM support is available, use our own implementation
+				if (thrLowMemoryWarningThread == null) {
+					thrLowMemoryWarningThread = new Thread(new Runnable() {
+
+						@Override
+						public void run() {
+							while (true) {
+								MemoryWarningSystem l;
+								synchronized (warningSystems) {
+									if (warningSystems.isEmpty()) {
+										thrLowMemoryWarningThread = null;
+										return;
+									}
+									l = warningSystems.iterator().next();
+								}
+								long nextThreshold = l.threshold;
+								MemoryUsage usage = tenuredGenPool.getUsage();
+								if (usage == null) {
+									logger.warn(MessageFormat.format("Memory usage of {0} could not be estimated",
+											tenuredGenPool.getName()));
+									return;
+								} else {
+									long used = usage.getUsed();
+									if (used >= l.threshold) {
+										nextThreshold = triggerNotification();
+										if (nextThreshold == -1) {
+											synchronized (warningSystems) {
+												if (warningSystems.isEmpty()) {
+													thrLowMemoryWarningThread = null;
+													return;
+												}
+											}
+										}
+									}
+								}
+								long used = usage.getUsed();
+								// Depending on how far we are from the next threshold, we can rest longer
+								// or shorter
+								long missing = nextThreshold - used;
+								if (missing <= 0)
+									continue;
+								try {
+									long wait = (long) ((missing / (double) tenuredGenPool.getUsage().getMax()) * 500);
+									Thread.sleep(wait);
+								} catch (InterruptedException e) {
+								}
+							}
+						}
+
+					});
+					thrLowMemoryWarningThread.setName("Low memory monitor");
+					thrLowMemoryWarningThread.setDaemon(true);
+					thrLowMemoryWarningThread.setPriority(Thread.MIN_PRIORITY);
+					thrLowMemoryWarningThread.start();
+				}
+			}
+		}
 	}
 
 	/**
@@ -161,8 +269,10 @@ public class MemoryWarningSystem {
 		// Avoid duplicate attempts to unregister the listener
 		if (isClosed)
 			return;
-		isClosed = true;
 		logger.info("Shutting down the memory warning system...");
+		synchronized (warningSystems) {
+			warningSystems.remove(this);
+		}
 
 		MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
 		try {
@@ -170,6 +280,7 @@ public class MemoryWarningSystem {
 		} catch (ListenerNotFoundException e) {
 			// Doesn't matter, we wanted to get rid of it anyway
 		}
+		isClosed = true;
 	}
 
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/problems/AbstractInfoflowProblem.java b/soot-infoflow/src/soot/jimple/infoflow/problems/AbstractInfoflowProblem.java
index dacfdcd..784128b 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/problems/AbstractInfoflowProblem.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/problems/AbstractInfoflowProblem.java
@@ -301,7 +301,7 @@ public abstract class AbstractInfoflowProblem
 		// We can ignore system classes according to FlowDroid's definition
 		if (manager.getConfig().getIgnoreFlowsInSystemPackages()) {
 			SootClass declClass = sm.getDeclaringClass();
-			if (declClass != null && SystemClassHandler.isClassInSystemPackage(declClass.getName()))
+			if (declClass != null && SystemClassHandler.v().isClassInSystemPackage(declClass.getName()))
 				return true;
 		}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/problems/BackwardsInfoflowProblem.java b/soot-infoflow/src/soot/jimple/infoflow/problems/BackwardsInfoflowProblem.java
index 6f5b370..f847d3c 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/problems/BackwardsInfoflowProblem.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/problems/BackwardsInfoflowProblem.java
@@ -88,15 +88,9 @@ public class BackwardsInfoflowProblem extends AbstractInfoflowProblem {
 				if (!abs.getAccessPath().isStaticFieldRef()) {
 					if (abs.getAccessPath().getBaseType() instanceof PrimType)
 						return null;
-					if (TypeUtils.isStringType(abs.getAccessPath().getBaseType())
-							&& !abs.getAccessPath().getCanHaveImmutableAliases())
-						return null;
 				} else {
 					if (abs.getAccessPath().getFirstFieldType() instanceof PrimType)
 						return null;
-					if (TypeUtils.isStringType(abs.getAccessPath().getFirstFieldType())
-							&& !abs.getAccessPath().getCanHaveImmutableAliases())
-						return null;
 				}
 				return abs;
 			}
@@ -823,7 +817,7 @@ public class BackwardsInfoflowProblem extends AbstractInfoflowProblem {
 
 									// Do not pass on this taint, but
 									// trigger the forward analysis
-									for (Unit u : interproceduralCFG().getPredsOf(defStmt))
+									for (Unit u : interproceduralCFG().getPredsOf(call))
 										manager.getForwardSolver()
 												.processEdge(new PathEdge<Unit, Abstraction>(d1, u, abs));
 								}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/problems/InfoflowProblem.java b/soot-infoflow/src/soot/jimple/infoflow/problems/InfoflowProblem.java
index 6c81925..89735ad 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/problems/InfoflowProblem.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/problems/InfoflowProblem.java
@@ -175,7 +175,7 @@ public class InfoflowProblem extends AbstractInfoflowProblem {
 						// Perform a normal IFDS-style propagation for the new taint
 						taintSet.add(newAbs);
 						final Aliasing aliasing = manager.getAliasing();
-						if (aliasing != null && Aliasing.canHaveAliases(assignStmt, leftValue, newAbs)) {
+						if (aliasing != null && aliasing.canHaveAliases(assignStmt, leftValue, newAbs)) {
 							aliasing.computeAliases(d1, assignStmt, leftValue, taintSet, method, newAbs);
 						}
 					}
@@ -810,8 +810,9 @@ public class InfoflowProblem extends AbstractInfoflowProblem {
 										|| (taintWrapper != null && taintWrapper.isExclusive(iCallStmt, newSource)))) {
 							// If one of the callers does not read the value, we
 							// must pass it on in any case
-							boolean allCalleesRead = true;
-							outer: for (SootMethod callee : interproceduralCFG().getCalleesOfCallAt(call)) {
+							Collection<SootMethod> callees = interproceduralCFG().getCalleesOfCallAt(call);
+							boolean allCalleesRead = !callees.isEmpty();
+							outer: for (SootMethod callee : callees) {
 								if (callee.isConcrete() && callee.hasActiveBody()) {
 									Set<AccessPath> calleeAPs = mapAccessPathToCallee(callee, invExpr, null, null,
 											source.getAccessPath());
@@ -887,7 +888,7 @@ public class InfoflowProblem extends AbstractInfoflowProblem {
 
 										// Compute the aliases
 										for (Abstraction abs : nativeAbs)
-											if (abs.getAccessPath().isStaticFieldRef() || Aliasing.canHaveAliases(
+											if (abs.getAccessPath().isStaticFieldRef() || aliasing.canHaveAliases(
 													iCallStmt, abs.getAccessPath().getPlainValue(), abs))
 												aliasing.computeAliases(d1, iCallStmt,
 														abs.getAccessPath().getPlainValue(), res,
@@ -926,8 +927,7 @@ public class InfoflowProblem extends AbstractInfoflowProblem {
 					return null;
 
 				// Android executor methods are handled specially.
-				// getSubSignature()
-				// is slow, so we try to avoid it whenever we can
+				// getSubSignature() is slow, so we try to avoid it whenever we can
 				final boolean isExecutorExecute = interproceduralCFG().isExecutorExecute(ie, callee);
 
 				Set<AccessPath> res = null;
diff --git a/soot-infoflow/src/soot/jimple/infoflow/problems/TaintPropagationResults.java b/soot-infoflow/src/soot/jimple/infoflow/problems/TaintPropagationResults.java
index ac2813b..c99db77 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/problems/TaintPropagationResults.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/problems/TaintPropagationResults.java
@@ -28,10 +28,8 @@ public class TaintPropagationResults {
 		/**
 		 * Called when a new abstraction has reached a sink statement
 		 * 
-		 * @param abs
-		 *            The abstraction at the sink
-		 * @return True if the data flow analysis shall continue, otherwise
-		 *         false
+		 * @param abs The abstraction at the sink
+		 * @return True if the data flow analysis shall continue, otherwise false
 		 */
 		public boolean onResultAvailable(AbstractionAtSink abs);
 
@@ -45,8 +43,7 @@ public class TaintPropagationResults {
 	/**
 	 * Creates a new instance of the TaintPropagationResults class
 	 * 
-	 * @param manager
-	 *            A reference to the manager class used during taint propagation
+	 * @param manager A reference to the manager class used during taint propagation
 	 */
 	TaintPropagationResults(InfoflowManager manager) {
 		this.manager = manager;
@@ -55,13 +52,12 @@ public class TaintPropagationResults {
 	/**
 	 * Adds a new result of the data flow analysis to the collection
 	 * 
-	 * @param resultAbs
-	 *            The abstraction at the sink instruction
+	 * @param resultAbs The abstraction at the sink instruction
 	 * @return True if the data flow analysis shall continue, otherwise false
 	 */
 	public boolean addResult(AbstractionAtSink resultAbs) {
 		// Check whether we need to filter a result in a system package
-		if (manager.getConfig().getIgnoreFlowsInSystemPackages() && SystemClassHandler.isClassInSystemPackage(
+		if (manager.getConfig().getIgnoreFlowsInSystemPackages() && SystemClassHandler.v().isClassInSystemPackage(
 				manager.getICFG().getMethodOf(resultAbs.getSinkStmt()).getDeclaringClass().getName()))
 			return true;
 
@@ -95,8 +91,8 @@ public class TaintPropagationResults {
 	/**
 	 * Checks whether this result object is empty
 	 * 
-	 * @return True if this result object is empty, i.e., there are no results
-	 *         yet, otherwise false
+	 * @return True if this result object is empty, i.e., there are no results yet,
+	 *         otherwise false
 	 * @return
 	 */
 	public boolean isEmpty() {
@@ -113,14 +109,22 @@ public class TaintPropagationResults {
 	}
 
 	/**
-	 * Adds a new handler that is invoked when a new data flow result is added
-	 * to this data object
+	 * Adds a new handler that is invoked when a new data flow result is added to
+	 * this data object
 	 * 
-	 * @param handler
-	 *            The handler implementation to add
+	 * @param handler The handler implementation to add
 	 */
 	public void addResultAvailableHandler(OnTaintPropagationResultAdded handler) {
 		this.resultAddedHandlers.add(handler);
 	}
 
+	/**
+	 * Gets the number of taint abstractions in this result object
+	 * 
+	 * @return The number of taint abstractions in this result object
+	 */
+	public int size() {
+		return results == null ? 0 : results.size();
+	}
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/problems/rules/ArrayPropagationRule.java b/soot-infoflow/src/soot/jimple/infoflow/problems/rules/ArrayPropagationRule.java
index e875b88..50c29f3 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/problems/rules/ArrayPropagationRule.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/problems/rules/ArrayPropagationRule.java
@@ -15,7 +15,6 @@ import soot.jimple.LengthExpr;
 import soot.jimple.NewArrayExpr;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.InfoflowManager;
-import soot.jimple.infoflow.aliasing.Aliasing;
 import soot.jimple.infoflow.data.Abstraction;
 import soot.jimple.infoflow.data.AccessPath;
 import soot.jimple.infoflow.data.AccessPath.ArrayTaintType;
@@ -108,7 +107,7 @@ public class ArrayPropagationRule extends AbstractTaintPropagationRule {
 		res.add(newAbs);
 
 		// Compute the aliases
-		if (Aliasing.canHaveAliases(assignStmt, leftVal, newAbs))
+		if (manager.getAliasing().canHaveAliases(assignStmt, leftVal, newAbs))
 			getAliasing().computeAliases(d1, assignStmt, leftVal, res, getManager().getICFG().getMethodOf(assignStmt),
 					newAbs);
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/problems/rules/ImplicitPropagtionRule.java b/soot-infoflow/src/soot/jimple/infoflow/problems/rules/ImplicitPropagtionRule.java
index b2f614d..4d6fad1 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/problems/rules/ImplicitPropagtionRule.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/problems/rules/ImplicitPropagtionRule.java
@@ -19,7 +19,6 @@ import soot.jimple.ReturnStmt;
 import soot.jimple.Stmt;
 import soot.jimple.TableSwitchStmt;
 import soot.jimple.infoflow.InfoflowManager;
-import soot.jimple.infoflow.aliasing.Aliasing;
 import soot.jimple.infoflow.collect.ConcurrentHashSet;
 import soot.jimple.infoflow.collect.MyConcurrentHashMap;
 import soot.jimple.infoflow.data.Abstraction;
@@ -118,13 +117,10 @@ public class ImplicitPropagtionRule extends AbstractTaintPropagationRule {
 	 * Checks whether the given abstraction at the given statement leaves a
 	 * conditional branch
 	 * 
-	 * @param stmt
-	 *            The statement to check
-	 * @param source
-	 *            The abstraction arriving at the given statement
-	 * @param killAll
-	 *            The by-value boolean to receive whether all taints shall be
-	 *            removed
+	 * @param stmt    The statement to check
+	 * @param source  The abstraction arriving at the given statement
+	 * @param killAll The by-value boolean to receive whether all taints shall be
+	 *                removed
 	 * @return True if the given abstraction at the given statement leaves a
 	 *         conditional branch, otherwise false
 	 */
@@ -267,7 +263,7 @@ public class ImplicitPropagtionRule extends AbstractTaintPropagationRule {
 
 					// If we taint a return value because it is implicit,
 					// we must trigger an alias analysis
-					if (Aliasing.canHaveAliases(def, def.getLeftOp(), abs) && !callerD1sConditional)
+					if (manager.getAliasing().canHaveAliases(def, def.getLeftOp(), abs) && !callerD1sConditional)
 						for (Abstraction d1 : callerD1s)
 							getAliasing().computeAliases(d1, returnStmt, def.getLeftOp(), res,
 									getManager().getICFG().getMethodOf(callSite), abs);
diff --git a/soot-infoflow/src/soot/jimple/infoflow/problems/rules/SinkPropagationRule.java b/soot-infoflow/src/soot/jimple/infoflow/problems/rules/SinkPropagationRule.java
index 0841618..bf2c752 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/problems/rules/SinkPropagationRule.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/problems/rules/SinkPropagationRule.java
@@ -13,6 +13,7 @@ import soot.jimple.ReturnStmt;
 import soot.jimple.Stmt;
 import soot.jimple.TableSwitchStmt;
 import soot.jimple.infoflow.InfoflowManager;
+import soot.jimple.infoflow.aliasing.Aliasing;
 import soot.jimple.infoflow.data.Abstraction;
 import soot.jimple.infoflow.data.AbstractionAtSink;
 import soot.jimple.infoflow.data.AccessPath;
@@ -70,16 +71,18 @@ public class SinkPropagationRule extends AbstractTaintPropagationRule {
 	private void checkForSink(Abstraction d1, Abstraction source, Stmt stmt, final Value retVal) {
 		// The incoming value may be a complex expression. We have to look at
 		// every simple value contained within it.
-		for (Value val : BaseSelector.selectBaseList(retVal, false)) {
-			final AccessPath ap = source.getAccessPath();
-			final ISourceSinkManager sourceSinkManager = getManager().getSourceSinkManager();
-
-			if (ap != null && sourceSinkManager != null && source.isAbstractionActive()
-					&& getAliasing().mayAlias(val, ap.getPlainValue())) {
-				SinkInfo sinkInfo = sourceSinkManager.getSinkInfo(stmt, getManager(), source.getAccessPath());
-				if (sinkInfo != null
-						&& !getResults().addResult(new AbstractionAtSink(sinkInfo.getDefinition(), source, stmt)))
-					killState = true;
+		final AccessPath ap = source.getAccessPath();
+		final Aliasing aliasing = getAliasing();
+		final ISourceSinkManager sourceSinkManager = getManager().getSourceSinkManager();
+
+		if (ap != null && sourceSinkManager != null && aliasing != null && source.isAbstractionActive()) {
+			for (Value val : BaseSelector.selectBaseList(retVal, false)) {
+				if (aliasing.mayAlias(val, ap.getPlainValue())) {
+					SinkInfo sinkInfo = sourceSinkManager.getSinkInfo(stmt, getManager(), source.getAccessPath());
+					if (sinkInfo != null
+							&& !getResults().addResult(new AbstractionAtSink(sinkInfo.getDefinition(), source, stmt)))
+						killState = true;
+				}
 			}
 		}
 	}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/problems/rules/StrongUpdatePropagationRule.java b/soot-infoflow/src/soot/jimple/infoflow/problems/rules/StrongUpdatePropagationRule.java
index 585ee23..e76a941 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/problems/rules/StrongUpdatePropagationRule.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/problems/rules/StrongUpdatePropagationRule.java
@@ -11,7 +11,9 @@ import soot.jimple.InstanceFieldRef;
 import soot.jimple.StaticFieldRef;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.InfoflowManager;
+import soot.jimple.infoflow.aliasing.Aliasing;
 import soot.jimple.infoflow.data.Abstraction;
+import soot.jimple.infoflow.data.AccessPath;
 import soot.jimple.infoflow.problems.TaintPropagationResults;
 import soot.jimple.infoflow.util.ByReferenceBoolean;
 
@@ -128,11 +130,15 @@ public class StrongUpdatePropagationRule extends AbstractTaintPropagationRule {
 			ByReferenceBoolean killSource, ByReferenceBoolean killAll) {
 		// Do not propagate abstractions for locals that get overwritten
 		if (stmt instanceof AssignStmt) {
-			// a = foo() with a tainted
-			AssignStmt assignStmt = (AssignStmt) stmt;
-			if (!source.getAccessPath().isStaticFieldRef() && assignStmt.getLeftOp() instanceof Local
-					&& getAliasing().mayAlias(assignStmt.getLeftOp(), source.getAccessPath().getPlainValue()))
-				killSource.value = true;
+			AccessPath ap = source.getAccessPath();
+			if (ap != null) {
+				// a = foo() with a tainted
+				AssignStmt assignStmt = (AssignStmt) stmt;
+				final Aliasing aliasing = getAliasing();
+				if (aliasing != null && !ap.isStaticFieldRef() && assignStmt.getLeftOp() instanceof Local
+						&& aliasing.mayAlias(assignStmt.getLeftOp(), ap.getPlainValue()))
+					killSource.value = true;
+			}
 		}
 
 		return null;
diff --git a/soot-infoflow/src/soot/jimple/infoflow/problems/rules/WrapperPropagationRule.java b/soot-infoflow/src/soot/jimple/infoflow/problems/rules/WrapperPropagationRule.java
index aed8e85..c01bfe1 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/problems/rules/WrapperPropagationRule.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/problems/rules/WrapperPropagationRule.java
@@ -94,30 +94,8 @@ public class WrapperPropagationRule extends AbstractTaintPropagationRule {
 			Set<Abstraction> resWithAliases = new HashSet<>(res);
 			for (Abstraction abs : res) {
 				// The new abstraction gets activated where it was generated
-				if (!abs.equals(source)) {
-					// If the taint wrapper creates a new taint, this must be propagated
-					// backwards as there might be aliases for the base object
-					// Note that we don't only need to check for heap writes such as a.x = y,
-					// but also for base object taints ("a" in this case).
-					final AccessPath val = abs.getAccessPath();
-					boolean taintsObjectValue = val.getBaseType() instanceof RefType
-							&& abs.getAccessPath().getBaseType() instanceof RefType
-							&& (!TypeUtils.isStringType(val.getBaseType()) || val.getCanHaveImmutableAliases());
-					boolean taintsStaticField = getManager().getConfig()
-							.getStaticFieldTrackingMode() != StaticFieldTrackingMode.None
-							&& abs.getAccessPath().isStaticFieldRef();
-
-					// If the tainted value gets overwritten, it cannot have aliases afterwards
-					boolean taintedValueOverwritten = (iStmt instanceof DefinitionStmt)
-							? Aliasing.baseMatches(((DefinitionStmt) iStmt).getLeftOp(), abs)
-							: false;
-
-					if (!taintedValueOverwritten)
-						if (taintsStaticField || (taintsObjectValue && abs.getAccessPath().getTaintSubFields())
-								|| Aliasing.canHaveAliases(iStmt, val.getPlainValue(), abs))
-							getAliasing().computeAliases(d1, iStmt, val.getPlainValue(), resWithAliases,
-									getManager().getICFG().getMethodOf(iStmt), abs);
-				}
+				if (!abs.equals(source))
+					checkAndPropagateAlias(d1, iStmt, resWithAliases, abs);
 			}
 			res = resWithAliases;
 		}
@@ -125,6 +103,42 @@ public class WrapperPropagationRule extends AbstractTaintPropagationRule {
 		return res;
 	}
 
+	/**
+	 * Starts alias tracking for the results of a taint wrapper if necessary
+	 * 
+	 * @param d1             The context in which the wrapped method was called
+	 * @param iStmt          The call site
+	 * @param resWithAliases The resulting taint abstractions generated by the
+	 *                       wrapper
+	 * @param abs            The original incoming taint abstraction
+	 */
+	protected void checkAndPropagateAlias(Abstraction d1, final Stmt iStmt, Set<Abstraction> resWithAliases,
+			Abstraction abs) {
+		// If the taint wrapper creates a new taint, this must be propagated
+		// backwards as there might be aliases for the base object
+		// Note that we don't only need to check for heap writes such as a.x = y,
+		// but also for base object taints ("a" in this case).
+		final AccessPath val = abs.getAccessPath();
+		boolean isBasicString = TypeUtils.isStringType(val.getBaseType()) && !val.getCanHaveImmutableAliases()
+				&& !getAliasing().isStringConstructorCall(iStmt);
+		boolean taintsObjectValue = val.getBaseType() instanceof RefType
+				&& abs.getAccessPath().getBaseType() instanceof RefType && !isBasicString;
+		boolean taintsStaticField = getManager().getConfig()
+				.getStaticFieldTrackingMode() != StaticFieldTrackingMode.None && abs.getAccessPath().isStaticFieldRef();
+
+		// If the tainted value gets overwritten, it cannot have aliases afterwards
+		boolean taintedValueOverwritten = (iStmt instanceof DefinitionStmt)
+				? Aliasing.baseMatches(((DefinitionStmt) iStmt).getLeftOp(), abs)
+				: false;
+
+		if (!taintedValueOverwritten) {
+			if (taintsStaticField || (taintsObjectValue && abs.getAccessPath().getTaintSubFields())
+					|| manager.getAliasing().canHaveAliases(iStmt, val.getPlainValue(), abs))
+				getAliasing().computeAliases(d1, iStmt, val.getPlainValue(), resWithAliases,
+						getManager().getICFG().getMethodOf(iStmt), abs);
+		}
+	}
+
 	@Override
 	public Collection<Abstraction> propagateCallToReturnFlow(Abstraction d1, Abstraction source, Stmt stmt,
 			ByReferenceBoolean killSource, ByReferenceBoolean killAll) {
diff --git a/soot-infoflow/src/soot/jimple/infoflow/resources/controls/LayoutControl.java b/soot-infoflow/src/soot/jimple/infoflow/resources/controls/LayoutControl.java
index bbdfa2e..02d0225 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/resources/controls/LayoutControl.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/resources/controls/LayoutControl.java
@@ -1,6 +1,6 @@
 package soot.jimple.infoflow.resources.controls;
 
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 
 /**
  * Abstract base class for all layout controls
@@ -27,6 +27,6 @@ public abstract class LayoutControl {
 	 * 
 	 * @return The source definition for this layout control
 	 */
-	public abstract SourceSinkDefinition getSourceDefinition();
+	public abstract ISourceSinkDefinition getSourceDefinition();
 
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/resources/controls/SwingPasswordField.java b/soot-infoflow/src/soot/jimple/infoflow/resources/controls/SwingPasswordField.java
index 5997ec8..483c244 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/resources/controls/SwingPasswordField.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/resources/controls/SwingPasswordField.java
@@ -4,9 +4,9 @@ import java.util.Collections;
 
 import soot.jimple.infoflow.sourcesSinks.definitions.AccessPathTuple;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkCategory;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition.CallType;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 
 /**
@@ -17,7 +17,7 @@ import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
  */
 public class SwingPasswordField extends JavaSwingLayoutControl {
 
-	protected final static SourceSinkDefinition UI_PASSWORD_SOURCE_DEF;
+	protected final static ISourceSinkDefinition UI_PASSWORD_SOURCE_DEF;
 
 	static {
 		UI_PASSWORD_SOURCE_DEF = new MethodSourceSinkDefinition(null, null,
@@ -53,7 +53,7 @@ public class SwingPasswordField extends JavaSwingLayoutControl {
 	}
 
 	@Override
-	public SourceSinkDefinition getSourceDefinition() {
+	public ISourceSinkDefinition getSourceDefinition() {
 		return UI_PASSWORD_SOURCE_DEF;
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/resources/controls/SwingTextField.java b/soot-infoflow/src/soot/jimple/infoflow/resources/controls/SwingTextField.java
index e646bae..7707ebd 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/resources/controls/SwingTextField.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/resources/controls/SwingTextField.java
@@ -4,9 +4,9 @@ import java.util.Collections;
 
 import soot.jimple.infoflow.sourcesSinks.definitions.AccessPathTuple;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkCategory;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition.CallType;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
 
 /**
@@ -17,7 +17,7 @@ import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkType;
  */
 public class SwingTextField extends JavaSwingLayoutControl {
 
-	protected final static SourceSinkDefinition UI_SOURCE_DEF;
+	protected final static ISourceSinkDefinition UI_SOURCE_DEF;
 
 	static {
 		UI_SOURCE_DEF = new MethodSourceSinkDefinition(null, null,
@@ -47,7 +47,7 @@ public class SwingTextField extends JavaSwingLayoutControl {
 	}
 
 	@Override
-	public SourceSinkDefinition getSourceDefinition() {
+	public ISourceSinkDefinition getSourceDefinition() {
 		return UI_SOURCE_DEF;
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/results/AbstractResultSourceSinkInfo.java b/soot-infoflow/src/soot/jimple/infoflow/results/AbstractResultSourceSinkInfo.java
index 462e13e..e96b1b1 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/results/AbstractResultSourceSinkInfo.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/results/AbstractResultSourceSinkInfo.java
@@ -3,7 +3,7 @@ package soot.jimple.infoflow.results;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.InfoflowConfiguration;
 import soot.jimple.infoflow.data.AccessPath;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 
 /**
  * Abstract base class for information on data flow results
@@ -13,16 +13,24 @@ import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
  */
 public abstract class AbstractResultSourceSinkInfo {
 
-	protected final SourceSinkDefinition definition;
+	protected final ISourceSinkDefinition definition;
 	protected final AccessPath accessPath;
 	protected final Stmt stmt;
 	protected final Object userData;
 
-	public AbstractResultSourceSinkInfo(SourceSinkDefinition definition, AccessPath accessPath, Stmt stmt) {
+	public AbstractResultSourceSinkInfo() {
+		this.stmt = null;
+		this.definition = null;
+		this.accessPath = null;
+		this.userData = null;
+
+	}
+
+	public AbstractResultSourceSinkInfo(ISourceSinkDefinition definition, AccessPath accessPath, Stmt stmt) {
 		this(definition, accessPath, stmt, null);
 	}
 
-	public AbstractResultSourceSinkInfo(SourceSinkDefinition definition, AccessPath accessPath, Stmt stmt,
+	public AbstractResultSourceSinkInfo(ISourceSinkDefinition definition, AccessPath accessPath, Stmt stmt,
 			Object userData) {
 		assert accessPath != null;
 
@@ -32,7 +40,7 @@ public abstract class AbstractResultSourceSinkInfo {
 		this.userData = userData;
 	}
 
-	public SourceSinkDefinition getDefinition() {
+	public ISourceSinkDefinition getDefinition() {
 		return this.definition;
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/results/InfoflowResults.java b/soot-infoflow/src/soot/jimple/infoflow/results/InfoflowResults.java
index 0c84fc0..03c199d 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/results/InfoflowResults.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/results/InfoflowResults.java
@@ -27,7 +27,7 @@ import soot.jimple.InvokeExpr;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.data.Abstraction;
 import soot.jimple.infoflow.data.AccessPath;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.util.ConcurrentHashMultiMap;
 import soot.util.MultiMap;
 
@@ -51,6 +51,9 @@ public class InfoflowResults {
 	private volatile List<String> exceptions = null;
 	private int terminationState = TERMINATION_SUCCESS;
 
+	public InfoflowResults() {
+	}
+
 	/**
 	 * Gets the exceptions that have happened during the data flow analysis. This
 	 * collection is immutable.
@@ -77,10 +80,6 @@ public class InfoflowResults {
 		exceptions.add(ex);
 	}
 
-	public InfoflowResults() {
-
-	}
-
 	/**
 	 * Gets the number of entries in this result object
 	 * 
@@ -141,14 +140,14 @@ public class InfoflowResults {
 		return !findSinkByMethodSignature(sinkSignature).isEmpty();
 	}
 
-	public void addResult(SourceSinkDefinition sinkDefinition, AccessPath sink, Stmt sinkStmt,
-			SourceSinkDefinition sourceDefinition, AccessPath source, Stmt sourceStmt) {
+	public void addResult(ISourceSinkDefinition sinkDefinition, AccessPath sink, Stmt sinkStmt,
+			ISourceSinkDefinition sourceDefinition, AccessPath source, Stmt sourceStmt) {
 		this.addResult(new ResultSinkInfo(sinkDefinition, sink, sinkStmt),
 				new ResultSourceInfo(sourceDefinition, source, sourceStmt));
 	}
 
-	public Pair<ResultSourceInfo, ResultSinkInfo> addResult(SourceSinkDefinition sinkDefinition, AccessPath sink,
-			Stmt sinkStmt, SourceSinkDefinition sourceDefinition, AccessPath source, Stmt sourceStmt, Object userData,
+	public Pair<ResultSourceInfo, ResultSinkInfo> addResult(ISourceSinkDefinition sinkDefinition, AccessPath sink,
+			Stmt sinkStmt, ISourceSinkDefinition sourceDefinition, AccessPath source, Stmt sourceStmt, Object userData,
 			List<Abstraction> propagationPath) {
 		// Get the statements and the access paths from the abstractions
 		List<Stmt> stmtPath = null;
@@ -187,8 +186,8 @@ public class InfoflowResults {
 	 *                              path
 	 * @return The new data flow result
 	 */
-	public Pair<ResultSourceInfo, ResultSinkInfo> addResult(SourceSinkDefinition sinkDefinition, AccessPath sink,
-			Stmt sinkStmt, SourceSinkDefinition sourceDefinition, AccessPath source, Stmt sourceStmt, Object userData,
+	public Pair<ResultSourceInfo, ResultSinkInfo> addResult(ISourceSinkDefinition sinkDefinition, AccessPath sink,
+			Stmt sinkStmt, ISourceSinkDefinition sourceDefinition, AccessPath source, Stmt sourceStmt, Object userData,
 			List<Stmt> propagationPath, List<AccessPath> propagationAccessPath) {
 		ResultSourceInfo sourceObj = new ResultSourceInfo(sourceDefinition, source, sourceStmt, userData,
 				propagationPath, propagationAccessPath);
@@ -231,7 +230,9 @@ public class InfoflowResults {
 	 * @param results The data structure from which to copy the results
 	 */
 	public void addAll(InfoflowResults results) {
-		if (results == null || results.isEmpty())
+		// We must also accept empty result objects, because even though they do not
+		// contain any data flows, they may still contain performance data.
+		if (results == null)
 			return;
 
 		if (results.getExceptions() != null) {
@@ -239,7 +240,7 @@ public class InfoflowResults {
 				addException(e);
 		}
 
-		if (!results.getResults().isEmpty()) {
+		if (!results.isEmpty() && !results.getResults().isEmpty()) {
 			for (ResultSinkInfo sink : results.getResults().keySet())
 				for (ResultSourceInfo source : results.getResults().get(sink))
 					addResult(sink, source);
@@ -252,6 +253,9 @@ public class InfoflowResults {
 			else
 				this.performanceData.add(results.performanceData);
 		}
+
+		// We aggregate all individual states rather than just taking the best one
+		this.terminationState |= results.terminationState;
 	}
 
 	/**
@@ -495,6 +499,22 @@ public class InfoflowResults {
 		this.performanceData = performanceData;
 	}
 
+	/**
+	 * Adds the given performance data to this result object
+	 * 
+	 * @param performanceData The performance data to add
+	 */
+	public void addPerformanceData(InfoflowPerformanceData performanceData) {
+		// don't duplicate performance data
+		if (performanceData == this.performanceData)
+			return;
+
+		if (this.performanceData == null)
+			this.performanceData = performanceData;
+		else
+			this.performanceData.add(performanceData);
+	}
+
 	@Override
 	public String toString() {
 		if (this.results == null)
diff --git a/soot-infoflow/src/soot/jimple/infoflow/results/ResultSinkInfo.java b/soot-infoflow/src/soot/jimple/infoflow/results/ResultSinkInfo.java
index 9b662ed..a71b577 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/results/ResultSinkInfo.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/results/ResultSinkInfo.java
@@ -2,7 +2,7 @@ package soot.jimple.infoflow.results;
 
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.data.AccessPath;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.tagkit.LineNumberTag;
 
 /**
@@ -13,7 +13,10 @@ import soot.tagkit.LineNumberTag;
  */
 public class ResultSinkInfo extends AbstractResultSourceSinkInfo {
 
-	public ResultSinkInfo(SourceSinkDefinition definition, AccessPath sink, Stmt context) {
+	public ResultSinkInfo() {
+	}
+
+	public ResultSinkInfo(ISourceSinkDefinition definition, AccessPath sink, Stmt context) {
 		super(definition, sink, context);
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/results/ResultSourceInfo.java b/soot-infoflow/src/soot/jimple/infoflow/results/ResultSourceInfo.java
index 7b71ea4..031ee45 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/results/ResultSourceInfo.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/results/ResultSourceInfo.java
@@ -6,7 +6,7 @@ import java.util.List;
 import soot.jimple.Stmt;
 import soot.jimple.infoflow.InfoflowConfiguration;
 import soot.jimple.infoflow.data.AccessPath;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.tagkit.LineNumberTag;
 
 /**
@@ -18,14 +18,19 @@ public class ResultSourceInfo extends AbstractResultSourceSinkInfo {
 	private final Stmt[] path;
 	private final AccessPath[] pathAPs;
 
-	public ResultSourceInfo(SourceSinkDefinition definition, AccessPath source, Stmt context) {
+	public ResultSourceInfo() {
+		this.path = null;
+		this.pathAPs = null;
+	}
+
+	public ResultSourceInfo(ISourceSinkDefinition definition, AccessPath source, Stmt context) {
 		super(definition, source, context);
 
 		this.path = null;
 		this.pathAPs = null;
 	}
 
-	public ResultSourceInfo(SourceSinkDefinition definition, AccessPath source, Stmt context, Object userData,
+	public ResultSourceInfo(ISourceSinkDefinition definition, AccessPath source, Stmt context, Object userData,
 			List<Stmt> path, List<AccessPath> pathAPs) {
 		super(definition, source, context, userData);
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/results/xml/InfoflowResultsSerializer.java b/soot-infoflow/src/soot/jimple/infoflow/results/xml/InfoflowResultsSerializer.java
index 788d7ab..230370e 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/results/xml/InfoflowResultsSerializer.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/results/xml/InfoflowResultsSerializer.java
@@ -192,6 +192,9 @@ public class InfoflowResultsSerializer {
 	private void writeSourceInfo(ResultSourceInfo source, XMLStreamWriter writer) throws XMLStreamException {
 		writer.writeStartElement(XmlConstants.Tags.source);
 		writer.writeAttribute(XmlConstants.Attributes.statement, source.getStmt().toString());
+		if (config.getEnableLineNumbers())
+			writer.writeAttribute(XmlConstants.Attributes.linenumber,
+					String.valueOf(source.getStmt().getJavaSourceStartLineNumber()));
 		if (source.getDefinition().getCategory() != null)
 			writer.writeAttribute(XmlConstants.Attributes.category,
 					source.getDefinition().getCategory().getHumanReadableDescription());
@@ -246,6 +249,9 @@ public class InfoflowResultsSerializer {
 	private void writeSinkInfo(ResultSinkInfo sink, XMLStreamWriter writer) throws XMLStreamException {
 		writer.writeStartElement(XmlConstants.Tags.sink);
 		writer.writeAttribute(XmlConstants.Attributes.statement, sink.getStmt().toString());
+		if (config.getEnableLineNumbers())
+			writer.writeAttribute(XmlConstants.Attributes.linenumber,
+					String.valueOf(sink.getStmt().getJavaSourceStartLineNumber()));
 		if (sink.getDefinition().getCategory() != null)
 			writer.writeAttribute(XmlConstants.Attributes.category,
 					sink.getDefinition().getCategory().getHumanReadableDescription());
diff --git a/soot-infoflow/src/soot/jimple/infoflow/results/xml/XmlConstants.java b/soot-infoflow/src/soot/jimple/infoflow/results/xml/XmlConstants.java
index de4c410..eaa7282 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/results/xml/XmlConstants.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/results/xml/XmlConstants.java
@@ -38,6 +38,7 @@ class XmlConstants {
 		public static final String fileFormatVersion = "FileFormatVersion";
 		public static final String terminationState = "TerminationState";
 		public static final String statement = "Statement";
+		public static final String linenumber = "LineNumber";
 		public static final String method = "Method";
 
 		public static final String value = "Value";
diff --git a/soot-infoflow/src/soot/jimple/infoflow/rifl/RIFLSourceSinkDefinitionProvider.java b/soot-infoflow/src/soot/jimple/infoflow/rifl/RIFLSourceSinkDefinitionProvider.java
index 1cd74c6..23f1b0d 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/rifl/RIFLSourceSinkDefinitionProvider.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/rifl/RIFLSourceSinkDefinitionProvider.java
@@ -21,10 +21,10 @@ import soot.jimple.infoflow.rifl.RIFLDocument.SourceSinkSpec;
 import soot.jimple.infoflow.rifl.RIFLDocument.SourceSinkType;
 import soot.jimple.infoflow.sourcesSinks.definitions.AccessPathTuple;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkCategory;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinitionProvider;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition.CallType;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.util.SootMethodRepresentationParser;
 
 /**
@@ -34,9 +34,9 @@ import soot.jimple.infoflow.util.SootMethodRepresentationParser;
  */
 public class RIFLSourceSinkDefinitionProvider implements ISourceSinkDefinitionProvider {
 
-	private final Set<SourceSinkDefinition> sources = new HashSet<>();
-	private final Set<SourceSinkDefinition> sinks = new HashSet<>();
-	private Set<SourceSinkDefinition> allMethods = null;
+	private final Set<ISourceSinkDefinition> sources = new HashSet<>();
+	private final Set<ISourceSinkDefinition> sinks = new HashSet<>();
+	private Set<ISourceSinkDefinition> allMethods = null;
 	private String lastCategory = null;
 
 	/**
@@ -44,8 +44,8 @@ public class RIFLSourceSinkDefinitionProvider implements ISourceSinkDefinitionPr
 	 *
 	 * @param file The file from which to read the RIFL specification
 	 * @throws IOException  Thrown if the given RIFL file cannot be read
-	 * @throws SAXException Thrown in the case of an XML error while parsing the RIFL
-	 *                      file
+	 * @throws SAXException Thrown in the case of an XML error while parsing the
+	 *                      RIFL file
 	 */
 	public RIFLSourceSinkDefinitionProvider(String file) throws SAXException, IOException {
 		RIFLParser parser = new RIFLParser();
@@ -64,8 +64,8 @@ public class RIFLSourceSinkDefinitionProvider implements ISourceSinkDefinitionPr
 	 */
 	private void parseRawDefinition(SourceSinkSpec element) {
 		if (element.getType() == SourceSinkType.Source) {
-			SourceSinkDefinition sourceSinkDefinition = parseDefinition(element, SourceSinkType.Source);
-			final String permanentCategory=lastCategory;
+			ISourceSinkDefinition sourceSinkDefinition = parseDefinition(element, SourceSinkType.Source);
+			final String permanentCategory = lastCategory;
 			sourceSinkDefinition.setCategory(new ISourceSinkCategory() {
 				@Override
 				public String getHumanReadableDescription() {
@@ -80,8 +80,8 @@ public class RIFLSourceSinkDefinitionProvider implements ISourceSinkDefinitionPr
 			sources.add(sourceSinkDefinition);
 
 		} else if (element.getType() == SourceSinkType.Sink) {
-			SourceSinkDefinition sourceSinkDefinition = parseDefinition(element, SourceSinkType.Sink);
-            final String permanentCategory=lastCategory;
+			ISourceSinkDefinition sourceSinkDefinition = parseDefinition(element, SourceSinkType.Sink);
+			final String permanentCategory = lastCategory;
 			sourceSinkDefinition.setCategory(new ISourceSinkCategory() {
 				@Override
 				public String getHumanReadableDescription() {
@@ -114,11 +114,12 @@ public class RIFLSourceSinkDefinitionProvider implements ISourceSinkDefinitionPr
 	 * Parses the contents of a source/sink specification element
 	 *
 	 * @param element        The element to parse
-	 * @param sourceSinkType Specifies whether the current element is a source or a sink
+	 * @param sourceSinkType Specifies whether the current element is a source or a
+	 *                       sink
 	 * @return The source/sink definition that corresponds to the given RIFL
-	 * specification element
+	 *         specification element
 	 */
-	private SourceSinkDefinition parseDefinition(SourceSinkSpec element, SourceSinkType sourceSinkType) {
+	private ISourceSinkDefinition parseDefinition(SourceSinkSpec element, SourceSinkType sourceSinkType) {
 		if (element instanceof JavaMethodSourceSinkSpec) {
 			JavaMethodSourceSinkSpec javaElement = (JavaMethodSourceSinkSpec) element;
 
@@ -130,29 +131,26 @@ public class RIFLSourceSinkDefinitionProvider implements ISourceSinkDefinitionPr
 
 			// Build the parameter list
 			List<String> parameterTypes = new ArrayList<>();
-			if (parameters != null) {//handle empty parameter case
+			if (parameters != null) {// handle empty parameter case
 
 				for (String p : parameters)
 					parameterTypes.add(p);
 			}
-			if (element instanceof JavaParameterSpec) {//sink
+			if (element instanceof JavaParameterSpec) {// sink
 				JavaParameterSpec paramSpec = (JavaParameterSpec) element;
 
-				Set<AccessPathTuple> returnValue = new HashSet<>();//dummy
+				Set<AccessPathTuple> returnValue = new HashSet<>();// dummy
 
 				SootMethodAndClass am = new SootMethodAndClass(methodName, javaElement.getClassName(), "",
 						parameterTypes);
-				SourceSinkDefinition def = new MethodSourceSinkDefinition(am, null, null, returnValue,
-						CallType.MethodCall);
-				return def;
-			} else if (element instanceof JavaReturnValueSpec) {//source
+				return new MethodSourceSinkDefinition(am, null, null, returnValue, CallType.MethodCall);
+			} else if (element instanceof JavaReturnValueSpec) {// source
 				AccessPathTuple apt = AccessPathTuple.fromPathElements((String[]) null, null,
 						sourceSinkType == SourceSinkType.Source, sourceSinkType == SourceSinkType.Sink);
 
 				SootMethodAndClass am = new SootMethodAndClass(methodName, javaElement.getClassName(), "",
 						parameterTypes);
-				SourceSinkDefinition def = new MethodSourceSinkDefinition(am, null, null, null, CallType.MethodCall);
-				return def;
+				return new MethodSourceSinkDefinition(am, null, null, null, CallType.MethodCall);
 			}
 		} else if (element instanceof JavaFieldSpec) {
 			// JavaFieldSpec javaElement = (JavaFieldSpec) element;
@@ -162,17 +160,17 @@ public class RIFLSourceSinkDefinitionProvider implements ISourceSinkDefinitionPr
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSources() {
+	public Set<ISourceSinkDefinition> getSources() {
 		return sources;
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSinks() {
+	public Set<ISourceSinkDefinition> getSinks() {
 		return sinks;
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getAllMethods() {
+	public Set<ISourceSinkDefinition> getAllMethods() {
 		if (allMethods == null) {
 			allMethods = new HashSet<>(sources.size() + sinks.size());
 			allMethods.addAll(sources);
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/IInfoflowSolver.java b/soot-infoflow/src/soot/jimple/infoflow/solver/IInfoflowSolver.java
index 62e795f..4433e3d 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/solver/IInfoflowSolver.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/IInfoflowSolver.java
@@ -122,4 +122,17 @@ public interface IInfoflowSolver {
 	 */
 	public void setMaxAbstractionPathLength(int maxAbstractionPathLength);
 
+	/**
+	 * Sets the peer group in which this solver operates. Peer groups allow for
+	 * synchronization between solvers
+	 * 
+	 * @param solverPeerGroup The solver peer group
+	 */
+	public void setPeerGroup(SolverPeerGroup solverPeerGroup);
+
+	/**
+	 * Notifies the solver that no further edges will be scheduled
+	 */
+	public void terminate();
+
 }
\ No newline at end of file
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/SolverPeerGroup.java b/soot-infoflow/src/soot/jimple/infoflow/solver/SolverPeerGroup.java
new file mode 100644
index 0000000..5d3be1e
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/SolverPeerGroup.java
@@ -0,0 +1,28 @@
+package soot.jimple.infoflow.solver;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Peer group for synchronizing multiple IFDS solvers
+ * 
+ * @author Steven Arzt
+ *
+ */
+public abstract class SolverPeerGroup {
+
+	protected Set<IInfoflowSolver> solvers = new HashSet<>();
+
+	public SolverPeerGroup() {
+	}
+
+	/**
+	 * Adds a data flow solver to this peer group
+	 * 
+	 * @param solver The solver to add
+	 */
+	public void addSolver(IInfoflowSolver solver) {
+		this.solvers.add(solver);
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/cfg/BackwardsInfoflowCFG.java b/soot-infoflow/src/soot/jimple/infoflow/solver/cfg/BackwardsInfoflowCFG.java
index f934ef1..a4a1bea 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/solver/cfg/BackwardsInfoflowCFG.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/cfg/BackwardsInfoflowCFG.java
@@ -1,5 +1,9 @@
 package soot.jimple.infoflow.solver.cfg;
 
+import soot.SootField;
+import soot.SootMethod;
+import soot.Unit;
+import soot.Value;
 import soot.jimple.toolkits.ide.icfg.BackwardsInterproceduralCFG;
 
 /**
@@ -9,16 +13,52 @@ import soot.jimple.toolkits.ide.icfg.BackwardsInterproceduralCFG;
  * @author Eric Bodden
  */
 public class BackwardsInfoflowCFG extends InfoflowCFG {
-	
+
 	private final IInfoflowCFG baseCFG;
-	
+
 	public BackwardsInfoflowCFG(IInfoflowCFG baseCFG) {
 		super(new BackwardsInterproceduralCFG(baseCFG));
 		this.baseCFG = baseCFG;
 	}
-	
+
 	public IInfoflowCFG getBaseCFG() {
 		return this.baseCFG;
 	}
-	
+
+	@Override
+	public boolean isStaticFieldRead(SootMethod method, SootField variable) {
+		return baseCFG.isStaticFieldRead(method, variable);
+	}
+
+	@Override
+	public boolean isStaticFieldUsed(SootMethod method, SootField variable) {
+		return baseCFG.isStaticFieldUsed(method, variable);
+	}
+
+	@Override
+	public boolean hasSideEffects(SootMethod method) {
+		return baseCFG.hasSideEffects(method);
+	}
+
+	@Override
+	public boolean methodReadsValue(SootMethod m, Value v) {
+		return baseCFG.methodReadsValue(m, v);
+	}
+
+	@Override
+	public boolean methodWritesValue(SootMethod m, Value v) {
+		return baseCFG.methodWritesValue(m, v);
+	}
+
+	@Override
+	public UnitContainer getPostdominatorOf(Unit u) {
+		return baseCFG.getPostdominatorOf(u);
+	}
+
+	@Override
+	public void purge() {
+		baseCFG.purge();
+		super.purge();
+	}
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/cfg/InfoflowCFG.java b/soot-infoflow/src/soot/jimple/infoflow/solver/cfg/InfoflowCFG.java
index 6320b77..0a87a53 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/solver/cfg/InfoflowCFG.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/cfg/InfoflowCFG.java
@@ -30,6 +30,7 @@ import soot.RefType;
 import soot.Scene;
 import soot.SootField;
 import soot.SootMethod;
+import soot.Trap;
 import soot.Unit;
 import soot.Value;
 import soot.ValueBox;
@@ -42,11 +43,11 @@ import soot.jimple.VirtualInvokeExpr;
 import soot.jimple.toolkits.callgraph.Edge;
 import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
 import soot.jimple.toolkits.ide.icfg.JimpleBasedInterproceduralCFG;
+import soot.toolkits.exceptions.ThrowableSet;
 import soot.toolkits.graph.DirectedGraph;
 import soot.toolkits.graph.ExceptionalUnitGraph;
+import soot.toolkits.graph.ExceptionalUnitGraph.ExceptionDest;
 import soot.toolkits.graph.MHGPostDominatorsFinder;
-import soot.util.HashMultiMap;
-import soot.util.MultiMap;
 
 /**
  * Interprocedural control-flow graph for the infoflow solver
@@ -259,14 +260,13 @@ public class InfoflowCFG implements IInfoflowCFG {
 		return use == StaticFieldUse.Write || use == StaticFieldUse.ReadWrite || use == StaticFieldUse.Unknown;
 	}
 
-	private synchronized StaticFieldUse checkStaticFieldUsed(SootMethod smethod, SootField variable) {
+	protected synchronized StaticFieldUse checkStaticFieldUsed(SootMethod smethod, SootField variable) {
 		// Skip over phantom methods
 		if (!smethod.isConcrete())
 			return StaticFieldUse.Unused;
 
 		List<SootMethod> workList = new ArrayList<>();
 		workList.add(smethod);
-		MultiMap<SootMethod, SootMethod> methodToCallees = new HashMultiMap<>();
 		Map<SootMethod, StaticFieldUse> tempUses = new HashMap<>();
 
 		int processedMethods = 0;
@@ -334,7 +334,6 @@ public class InfoflowCFG implements IInfoflowCFG {
 
 								// Process the callee
 								workList.add(callee);
-								methodToCallees.put(method, callee);
 								hasInvocation = true;
 							} else {
 								reads |= calleeUse == StaticFieldUse.Read || calleeUse == StaticFieldUse.ReadWrite;
@@ -368,7 +367,7 @@ public class InfoflowCFG implements IInfoflowCFG {
 		return outerUse == null ? StaticFieldUse.Unknown : outerUse;
 	}
 
-	private void registerStaticVariableUse(SootMethod method, SootField variable, StaticFieldUse fieldUse) {
+	protected void registerStaticVariableUse(SootMethod method, SootField variable, StaticFieldUse fieldUse) {
 		Map<SootField, StaticFieldUse> entry = staticFieldUses.get(method);
 		StaticFieldUse oldUse;
 		synchronized (staticFieldUses) {
@@ -411,7 +410,7 @@ public class InfoflowCFG implements IInfoflowCFG {
 		return hasSideEffects(method, new HashSet<SootMethod>(), 0);
 	}
 
-	private boolean hasSideEffects(SootMethod method, Set<SootMethod> runList, int depth) {
+	protected boolean hasSideEffects(SootMethod method, Set<SootMethod> runList, int depth) {
 		// Without a body, we cannot say much
 		if (!method.hasActiveBody())
 			return false;
@@ -484,7 +483,7 @@ public class InfoflowCFG implements IInfoflowCFG {
 		SootMethod m1 = getMethodOf(u1);
 		SootMethod m2 = getMethodOf(u2);
 		if (m1 != m2)
-			throw new RuntimeException("Exceptional edges are only supported " + "inside the same method");
+			throw new RuntimeException("Exceptional edges are only supported inside the same method");
 		DirectedGraph<Unit> ug1 = getOrCreateUnitGraph(m1);
 
 		// Exception tracking might be disabled
@@ -492,7 +491,33 @@ public class InfoflowCFG implements IInfoflowCFG {
 			return false;
 
 		ExceptionalUnitGraph eug = (ExceptionalUnitGraph) ug1;
-		return eug.getExceptionalSuccsOf(u1).contains(u2);
+		if (!eug.getExceptionalSuccsOf(u1).contains(u2))
+			return false;
+
+		// The ExceptionalUnitGraph has edges from the predecessors of thrower
+		// statements to the respective catch block to model that the predecessor was
+		// potentially the last statement to be fully executed before arriving at the
+		// catch block. For our purposes, we don't want that edge, because there the
+		// thrower itself is at least attempted to be executed, before we end up in the
+		// exception handler.
+		Collection<ExceptionDest> dests = eug.getExceptionDests(u1);
+		if (dests != null && !dests.isEmpty()) {
+			ThrowableSet ts = Scene.v().getDefaultThrowAnalysis().mightThrow(u1);
+			if (ts != null) {
+				boolean hasTraps = false;
+				for (ExceptionDest dest : dests) {
+					Trap trap = dest.getTrap();
+					if (trap != null) {
+						hasTraps = true;
+						if (!ts.catchableAs(trap.getException().getType()))
+							return false;
+					}
+				}
+				if (!hasTraps)
+					return false;
+			}
+		}
+		return true;
 	}
 
 	@Override
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/executors/InterruptableExecutor.java b/soot-infoflow/src/soot/jimple/infoflow/solver/executors/InterruptableExecutor.java
index 0d906ed..8cb18cf 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/solver/executors/InterruptableExecutor.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/executors/InterruptableExecutor.java
@@ -4,32 +4,37 @@ import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import heros.solver.CountingThreadPoolExecutor;
 import soot.jimple.infoflow.collect.BlackHoleCollection;
 
 public class InterruptableExecutor extends CountingThreadPoolExecutor {
-	
+
+	protected static final Logger logger = LoggerFactory.getLogger(InterruptableExecutor.class);
+
 	private boolean interrupted = false;
 	private boolean terminated = false;
-	
+
 	public InterruptableExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
 			BlockingQueue<Runnable> workQueue) {
 		super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
 	}
-	
+
 	/**
-	 * Interrupts the executor. This will make the awaitCompletion() methods
-	 * return immediately and silently reject all new tasks.
+	 * Interrupts the executor. This will make the awaitCompletion() methods return
+	 * immediately and silently reject all new tasks.
 	 */
 	public void interrupt() {
 		// Make sure that no new tasks are spawned
 		this.interrupted = true;
-		
+
 		// Get rid of the cancelled tasks in the work queue
 		getQueue().clear();
 		getQueue().drainTo(new BlackHoleCollection<>());
 		this.purge();
-		
+
 		// Signal to the blocking threads that we are done
 		numRunningTasks.resetAndInterrupt();
 	}
@@ -42,36 +47,37 @@ public class InterruptableExecutor extends CountingThreadPoolExecutor {
 		this.terminated = false;
 		this.interrupted = false;
 	}
-	
+
 	@Override
 	public void execute(Runnable command) {
 		// If the executor was terminated, it must be reset explicitly
-		if (this.terminated)
-			throw new RuntimeException("Executor has terminated. Call reset() before submitting new tasks.");
-		
+		if (this.terminated) {
+			logger.warn("Executor has terminated. Call reset() before submitting new tasks.");
+			return;
+		}
+
 		// Discard all submitted tasks if the executor has been interrupted
 		try {
 			if (!this.interrupted)
 				super.execute(command);
-		}
-		catch (RejectedExecutionException ex) {
+		} catch (RejectedExecutionException ex) {
 			// We expect the solver to be aborted, just terminate silently
 			// now
 			this.interrupted = true;
 		}
 	}
-	
+
 	@Override
 	public void awaitCompletion() throws InterruptedException {
 		// If we already know that we're done, there's no need to wait
 		if (terminated)
 			return;
-		
+
 		// Wait for the tasks to complete
 		super.awaitCompletion();
 		terminated = true;
 	}
-	
+
 	@Override
 	public void awaitCompletion(long timeout, TimeUnit unit) throws InterruptedException {
 		// If we already know that we're done, there's no need to wait
@@ -82,19 +88,20 @@ public class InterruptableExecutor extends CountingThreadPoolExecutor {
 		super.awaitCompletion(timeout, unit);
 		terminated = true;
 	}
-	
+
 	/**
 	 * Gets whether this executor has terminated all of its tasks
+	 * 
 	 * @return True if this executor has terminated all of its tasks, otherwise
-	 * false
+	 *         false
 	 */
 	public boolean isFinished() {
 		return terminated || numRunningTasks.isAtZero();
 	}
-	
+
 	@Override
 	public boolean isTerminated() {
 		return terminated || super.isTerminated();
 	}
-	
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/IFDSSolver.java b/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/IFDSSolver.java
index b47b3a1..da7e729 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/IFDSSolver.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/IFDSSolver.java
@@ -41,7 +41,6 @@ import heros.solver.Pair;
 import heros.solver.PathEdge;
 import soot.SootMethod;
 import soot.Unit;
-import soot.jimple.infoflow.collect.ConcurrentHashSet;
 import soot.jimple.infoflow.collect.MyConcurrentHashMap;
 import soot.jimple.infoflow.memory.IMemoryBoundedSolver;
 import soot.jimple.infoflow.memory.ISolverTerminationReason;
@@ -87,7 +86,7 @@ public class IFDSSolver<N, D extends FastSolverLinkedNode<D, N>, I extends BiDiI
 	// stores summaries that were queried before they were computed
 	// see CC 2010 paper by Naeem, Lhotak and Rodriguez
 	@SynchronizedBy("consistent lock on 'incoming'")
-	protected final MyConcurrentHashMap<Pair<SootMethod, D>, Set<Pair<N, D>>> endSummary = new MyConcurrentHashMap<Pair<SootMethod, D>, Set<Pair<N, D>>>();
+	protected final MyConcurrentHashMap<Pair<SootMethod, D>, Map<Pair<N, D>, D>> endSummary = new MyConcurrentHashMap<>();
 
 	// edges going along calls
 	// see CC 2010 paper by Naeem, Lhotak and Rodriguez
@@ -656,17 +655,22 @@ public class IFDSSolver<N, D extends FastSolverLinkedNode<D, N>, I extends BiDiI
 	}
 
 	protected Set<Pair<N, D>> endSummary(SootMethod m, D d3) {
-		Set<Pair<N, D>> map = endSummary.get(new Pair<SootMethod, D>(m, d3));
-		return map;
+		Map<Pair<N, D>, D> map = endSummary.get(new Pair<>(m, d3));
+		return map == null ? null : map.keySet();
 	}
 
 	private boolean addEndSummary(SootMethod m, D d1, N eP, D d2) {
 		if (d1 == zeroValue)
 			return true;
 
-		Set<Pair<N, D>> summaries = endSummary.putIfAbsentElseGet(new Pair<SootMethod, D>(m, d1),
-				new ConcurrentHashSet<Pair<N, D>>());
-		return summaries.add(new Pair<N, D>(eP, d2));
+		Map<Pair<N, D>, D> summaries = endSummary.putIfAbsentElseGet(new Pair<>(m, d1),
+				() -> new MyConcurrentHashMap<>());
+		D oldD2 = summaries.putIfAbsent(new Pair<N, D>(eP, d2), d2);
+		if (oldD2 != null) {
+			oldD2.addNeighbor(d2);
+			return false;
+		}
+		return true;
 	}
 
 	protected Map<N, Map<D, D>> incoming(D d1, SootMethod m) {
@@ -676,8 +680,8 @@ public class IFDSSolver<N, D extends FastSolverLinkedNode<D, N>, I extends BiDiI
 
 	protected boolean addIncoming(SootMethod m, D d3, N n, D d1, D d2) {
 		MyConcurrentHashMap<N, Map<D, D>> summaries = incoming.putIfAbsentElseGet(new Pair<SootMethod, D>(m, d3),
-				new MyConcurrentHashMap<N, Map<D, D>>());
-		Map<D, D> set = summaries.putIfAbsentElseGet(n, new ConcurrentHashMap<D, D>());
+				() -> new MyConcurrentHashMap<N, Map<D, D>>());
+		Map<D, D> set = summaries.putIfAbsentElseGet(n, () -> new ConcurrentHashMap<D, D>());
 		return set.put(d1, d2) == null;
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/InfoflowSolver.java b/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/InfoflowSolver.java
index a2f8200..b377b98 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/InfoflowSolver.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/InfoflowSolver.java
@@ -24,6 +24,7 @@ import soot.jimple.infoflow.data.Abstraction;
 import soot.jimple.infoflow.problems.AbstractInfoflowProblem;
 import soot.jimple.infoflow.solver.IFollowReturnsPastSeedsHandler;
 import soot.jimple.infoflow.solver.IInfoflowSolver;
+import soot.jimple.infoflow.solver.SolverPeerGroup;
 import soot.jimple.infoflow.solver.executors.InterruptableExecutor;
 import soot.jimple.infoflow.solver.functions.SolverCallFlowFunction;
 import soot.jimple.infoflow.solver.functions.SolverCallToReturnFlowFunction;
@@ -154,4 +155,14 @@ public class InfoflowSolver extends IFDSSolver<Unit, Abstraction, BiDiInterproce
 		return problem;
 	}
 
+	@Override
+	public void setPeerGroup(SolverPeerGroup solverPeerGroup) {
+		// we don't need peers
+	}
+
+	@Override
+	public void terminate() {
+		// not required
+	}
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/flowInsensitive/InfoflowSolver.java b/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/flowInsensitive/InfoflowSolver.java
index 1cf4346..a376d3c 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/flowInsensitive/InfoflowSolver.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/fastSolver/flowInsensitive/InfoflowSolver.java
@@ -24,6 +24,7 @@ import soot.jimple.infoflow.data.Abstraction;
 import soot.jimple.infoflow.problems.AbstractInfoflowProblem;
 import soot.jimple.infoflow.solver.IFollowReturnsPastSeedsHandler;
 import soot.jimple.infoflow.solver.IInfoflowSolver;
+import soot.jimple.infoflow.solver.SolverPeerGroup;
 import soot.jimple.infoflow.solver.executors.InterruptableExecutor;
 import soot.jimple.infoflow.solver.functions.SolverCallFlowFunction;
 import soot.jimple.infoflow.solver.functions.SolverCallToReturnFlowFunction;
@@ -153,4 +154,14 @@ public class InfoflowSolver extends FlowInsensitiveSolver<Unit, Abstraction, BiD
 		return this.problem;
 	}
 
+	@Override
+	public void setPeerGroup(SolverPeerGroup solverPeerGroup) {
+		// We don't have support for peer groups and don't really need them either
+	}
+
+	@Override
+	public void terminate() {
+		// not required
+	}
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gc/GCContext.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gc/GCContext.java
deleted file mode 100644
index c7e9938..0000000
--- a/soot-infoflow/src/soot/jimple/infoflow/solver/gc/GCContext.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package soot.jimple.infoflow.solver.gc;
-
-import soot.SootMethod;
-import soot.jimple.infoflow.solver.fastSolver.FastSolverLinkedNode;
-
-public class GCContext<N, D extends FastSolverLinkedNode<D, N>> {
-
-	private final D context;
-	private final SootMethod method;
-
-	public GCContext(D context, SootMethod method) {
-		this.context = context;
-		this.method = method;
-	}
-
-	public SootMethod getMethod() {
-		return method;
-	}
-
-	@Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((context == null) ? 0 : context.hashCode());
-		result = prime * result + ((method == null) ? 0 : method.hashCode());
-		return result;
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (getClass() != obj.getClass())
-			return false;
-		GCContext other = (GCContext) obj;
-		if (context == null) {
-			if (other.context != null)
-				return false;
-		} else if (!context.equals(other.context))
-			return false;
-		if (method == null) {
-			if (other.method != null)
-				return false;
-		} else if (!method.equals(other.method))
-			return false;
-		return true;
-	}
-
-}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gc/GCCounter.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gc/GCCounter.java
deleted file mode 100644
index 822313b..0000000
--- a/soot-infoflow/src/soot/jimple/infoflow/solver/gc/GCCounter.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package soot.jimple.infoflow.solver.gc;
-
-import java.util.Iterator;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import soot.jimple.infoflow.collect.ConcurrentIdentityHashMap;
-import soot.jimple.infoflow.solver.fastSolver.FastSolverLinkedNode;
-
-class GCCounter<N, D extends FastSolverLinkedNode<D, N>> {
-
-	private final AtomicInteger scheduledTasks = new AtomicInteger();
-	private volatile ConcurrentMap<GCCounter<N, D>, Object> callees;
-
-	public void incTasks() {
-		scheduledTasks.incrementAndGet();
-	}
-
-	public void decTasks() {
-		if (scheduledTasks.get() == 0)
-			throw new RuntimeException("GC counter underflow");
-		scheduledTasks.decrementAndGet();
-	}
-
-	public void addCallee(GCCounter<N, D> callee) {
-		if (callees == null) {
-			synchronized (this) {
-				if (callees == null)
-					callees = new ConcurrentIdentityHashMap<GCCounter<N, D>, Object>();
-			}
-		}
-		callees.put(callee, callee);
-	}
-
-	public boolean canGC() {
-		// Get rid of callees in which no jobs are open anymore
-		if (scheduledTasks.get() == 0) {
-			if (callees != null) {
-				for (Iterator<GCCounter<N, D>> calleeIt = callees.keySet().iterator(); calleeIt.hasNext();) {
-					GCCounter<N, D> callee = calleeIt.next();
-					if (callee.canGC())
-						calleeIt.remove();
-				}
-			}
-			return callees == null || callees.isEmpty();
-		}
-		return false;
-	}
-
-	@Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((callees == null) ? 0 : callees.hashCode());
-		result = prime * result + ((scheduledTasks == null) ? 0 : scheduledTasks.hashCode());
-		return result;
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (getClass() != obj.getClass())
-			return false;
-		GCCounter<?, ?> other = (GCCounter<?, ?>) obj;
-		if (callees == null) {
-			if (other.callees != null)
-				return false;
-		} else if (!callees.equals(other.callees))
-			return false;
-		if (scheduledTasks == null) {
-			if (other.scheduledTasks != null)
-				return false;
-		} else if (!scheduledTasks.equals(other.scheduledTasks))
-			return false;
-		return true;
-	}
-
-}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gc/SolverReferenceCounter.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gc/SolverReferenceCounter.java
deleted file mode 100644
index d38d22c..0000000
--- a/soot-infoflow/src/soot/jimple/infoflow/solver/gc/SolverReferenceCounter.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package soot.jimple.infoflow.solver.gc;
-
-import soot.SootMethod;
-import soot.jimple.infoflow.collect.MyConcurrentHashMap;
-import soot.jimple.infoflow.collect.MyConcurrentHashMap.IValueFactory;
-import soot.jimple.infoflow.solver.fastSolver.FastSolverLinkedNode;
-
-public class SolverReferenceCounter<N, D extends FastSolverLinkedNode<D, N>> {
-
-	private final IValueFactory<GCCounter<N, D>> counterFactory = new IValueFactory<GCCounter<N, D>>() {
-
-		@Override
-		public GCCounter<N, D> createValue() {
-			return new GCCounter<N, D>();
-		}
-
-	};
-
-	private final MyConcurrentHashMap<GCContext<N, D>, GCCounter<N, D>> countingMap = new MyConcurrentHashMap<>();
-
-	private GCCounter<N, D> getCounter(GCContext<N, D> context) {
-		return countingMap.putIfAbsentElseGet(context, counterFactory);
-	}
-
-	public void incTasks(D context, SootMethod method) {
-		GCContext<N, D> gccontext = new GCContext<>(context, method);
-		GCCounter<N, D> ctr = getCounter(gccontext);
-		ctr.incTasks();
-	}
-
-	public void decTasks(D context, SootMethod method) {
-		GCContext<N, D> gccontext = new GCContext<>(context, method);
-		decTasks(gccontext);
-	}
-
-	public void decTasks(GCContext<N, D> gccontext) {
-		GCCounter<N, D> ctr = getCounter(gccontext);
-		if (ctr != null)
-			ctr.decTasks();
-	}
-
-	public void addCallee(D context, SootMethod method, D calleeContext, SootMethod calleeMethod) {
-		GCContext<N, D> gccontext = new GCContext<>(context, method);
-		GCContext<N, D> calleeGCContext = new GCContext<N, D>(calleeContext, calleeMethod);
-		GCCounter<N, D> ctr = getCounter(gccontext);
-		GCCounter<N, D> ctrCallee = getCounter(calleeGCContext);
-		ctr.addCallee(ctrCallee);
-	}
-
-	public boolean canGC(GCContext<N, D> gccontext) {
-		GCCounter<N, D> ctr = getCounter(gccontext);
-		return ctr == null || ctr.canGC();
-	}
-
-}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AbstractGarbageCollector.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AbstractGarbageCollector.java
new file mode 100644
index 0000000..6f86b80
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AbstractGarbageCollector.java
@@ -0,0 +1,53 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import heros.solver.PathEdge;
+import soot.SootMethod;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+import soot.util.ConcurrentHashMultiMap;
+
+/**
+ * Abstract base class for garbage collectors
+ * 
+ * @author Steven Arzt
+ *
+ */
+public abstract class AbstractGarbageCollector<N, D> implements IGarbageCollector<N, D> {
+
+	protected final BiDiInterproceduralCFG<N, SootMethod> icfg;
+	protected final IGCReferenceProvider<D, N> referenceProvider;
+	protected final ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions;
+
+	public AbstractGarbageCollector(BiDiInterproceduralCFG<N, SootMethod> icfg,
+			ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions,
+			IGCReferenceProvider<D, N> referenceProvider) {
+		this.icfg = icfg;
+		this.referenceProvider = referenceProvider;
+		this.jumpFunctions = jumpFunctions;
+		initialize();
+	}
+
+	public AbstractGarbageCollector(BiDiInterproceduralCFG<N, SootMethod> icfg,
+			ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions) {
+		this.icfg = icfg;
+		this.referenceProvider = createReferenceProvider();
+		this.jumpFunctions = jumpFunctions;
+		initialize();
+	}
+
+	/**
+	 * Initializes the garbage collector
+	 */
+	protected void initialize() {
+	}
+
+	/**
+	 * Creates the reference provider that garbage collectors can use to identify
+	 * dependencies
+	 * 
+	 * @return The new reference provider
+	 */
+	protected IGCReferenceProvider<D, N> createReferenceProvider() {
+		return new OnDemandReferenceProvider<>(icfg);
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AbstractReferenceCountingGarbageCollector.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AbstractReferenceCountingGarbageCollector.java
new file mode 100644
index 0000000..f81de7b
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AbstractReferenceCountingGarbageCollector.java
@@ -0,0 +1,238 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import heros.solver.PathEdge;
+import soot.SootMethod;
+import soot.jimple.infoflow.collect.ConcurrentCountingMap;
+import soot.jimple.infoflow.collect.ConcurrentHashSet;
+import soot.jimple.infoflow.util.ExtendedAtomicInteger;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+import soot.util.ConcurrentHashMultiMap;
+
+/**
+ * Abstract base class for garbage collectors based on reference counting
+ * 
+ * @author Steven Arzt
+ *
+ */
+public abstract class AbstractReferenceCountingGarbageCollector<N, D> extends AbstractGarbageCollector<N, D>
+		implements IGarbageCollectorPeer {
+
+	private ConcurrentCountingMap<SootMethod> jumpFnCounter = new ConcurrentCountingMap<>();
+	private final Set<SootMethod> gcScheduleSet = new ConcurrentHashSet<>();
+	private final AtomicInteger gcedMethods = new AtomicInteger();
+	private final AtomicInteger gcedEdges = new AtomicInteger();
+	private final ExtendedAtomicInteger edgeCounterForThreshold = new ExtendedAtomicInteger();
+	private GarbageCollectionTrigger trigger = GarbageCollectionTrigger.Immediate;
+	private GarbageCollectorPeerGroup peerGroup = null;
+	private boolean checkChangeCounter = false;
+
+	protected boolean validateEdges = false;
+	protected Set<PathEdge<N, D>> oldEdges = new HashSet<>();
+
+	/**
+	 * The number of methods to collect as candidates for garbage collection, before
+	 * halting the taint propagation and actually cleaning them up
+	 */
+	protected int methodThreshold = 0;
+	/**
+	 * Wait for at least this number of edges before starting the garbage collection
+	 */
+	protected int edgeThreshold = 0;
+
+	public AbstractReferenceCountingGarbageCollector(BiDiInterproceduralCFG<N, SootMethod> icfg,
+			ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions,
+			IGCReferenceProvider<D, N> referenceProvider) {
+		super(icfg, jumpFunctions, referenceProvider);
+	}
+
+	public AbstractReferenceCountingGarbageCollector(BiDiInterproceduralCFG<N, SootMethod> icfg,
+			ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions) {
+		super(icfg, jumpFunctions);
+	}
+
+	@Override
+	public void notifyEdgeSchedule(PathEdge<N, D> edge) {
+		SootMethod sm = icfg.getMethodOf(edge.getTarget());
+		jumpFnCounter.increment(sm);
+		gcScheduleSet.add(sm);
+		if (trigger == GarbageCollectionTrigger.EdgeThreshold)
+			edgeCounterForThreshold.incrementAndGet();
+
+		if (validateEdges) {
+			if (oldEdges.contains(edge))
+				System.out.println("Edge re-scheduled");
+		}
+	}
+
+	@Override
+	public void notifyTaskProcessed(PathEdge<N, D> edge) {
+		jumpFnCounter.decrement(icfg.getMethodOf(edge.getTarget()));
+	}
+
+	/**
+	 * Checks whether the given method has any open dependencies that prevent its
+	 * jump functions from being garbage collected
+	 * 
+	 * @param method           The method to check
+	 * @param referenceCounter The counter that keeps track of active references to
+	 *                         taint abstractions
+	 * @return True it the method has active dependencies and thus cannot be
+	 *         garbage-collected, false otherwise
+	 */
+	private boolean hasActiveDependencies(SootMethod method, ConcurrentCountingMap<SootMethod> referenceCounter) {
+		int changeCounter = -1;
+		do {
+			// Update the change counter for the next round
+			changeCounter = referenceCounter.getChangeCounter();
+
+			// Check the method itself
+			if (referenceCounter.get(method) > 0)
+				return true;
+
+			// Check the transitive callees
+			Set<SootMethod> references = referenceProvider.getMethodReferences(method, null);
+			for (SootMethod ref : references) {
+				if (referenceCounter.get(ref) > 0)
+					return true;
+			}
+		} while (checkChangeCounter && changeCounter != referenceCounter.getChangeCounter());
+		return false;
+	}
+
+	@Override
+	public boolean hasActiveDependencies(SootMethod method) {
+		return hasActiveDependencies(method, jumpFnCounter);
+	}
+
+	/**
+	 * Immediately performs garbage collection
+	 */
+	protected void gcImmediate() {
+		if (gcScheduleSet != null && !gcScheduleSet.isEmpty()) {
+			// Check our various triggers for garbage collection
+			boolean gc = trigger == GarbageCollectionTrigger.Immediate;
+			gc |= trigger == GarbageCollectionTrigger.MethodThreshold && gcScheduleSet.size() > methodThreshold;
+			gc |= trigger == GarbageCollectionTrigger.EdgeThreshold && edgeCounterForThreshold.get() > edgeThreshold;
+
+			// Perform the garbage collection if required
+			if (gc) {
+				int tempMethods = 0;
+				onBeforeRemoveEdges();
+				for (SootMethod sm : gcScheduleSet) {
+					// Is it safe to remove this method?
+					if (peerGroup != null) {
+						if (peerGroup.hasActiveDependencies(sm))
+							continue;
+					} else if (hasActiveDependencies(sm))
+						continue;
+
+					// Get stats for the stuff we are about to remove
+					Set<PathEdge<N, D>> oldFunctions = jumpFunctions.get(sm);
+					if (oldFunctions != null) {
+						int gcedSize = oldFunctions.size();
+						gcedEdges.addAndGet(gcedSize);
+						if (trigger == GarbageCollectionTrigger.EdgeThreshold)
+							edgeCounterForThreshold.subtract(gcedSize);
+					}
+
+					// First unregister the method, then delete the edges. In case some other thread
+					// concurrently schedules a new edge, the method gets back into the GC work list
+					// this way.
+					gcScheduleSet.remove(sm);
+					if (jumpFunctions.remove(sm)) {
+						gcedMethods.incrementAndGet();
+						tempMethods++;
+						if (validateEdges)
+							oldEdges.addAll(oldFunctions);
+					}
+				}
+				onAfterRemoveEdges(tempMethods);
+			}
+		}
+	}
+
+	/**
+	 * Method that is called before the first edge is removed from the jump
+	 * functions
+	 */
+	protected void onBeforeRemoveEdges() {
+	}
+
+	/**
+	 * Method that is called after the last edge has been removed from the jump
+	 * functions
+	 * 
+	 * @param gcedMethods The number of methods for which edges have been removed
+	 */
+	protected void onAfterRemoveEdges(int gcedMethods) {
+	}
+
+	@Override
+	public int getGcedMethods() {
+		return gcedMethods.get();
+	}
+
+	@Override
+	public int getGcedEdges() {
+		return gcedEdges.get();
+	}
+
+	/**
+	 * Sets the number of methods for which edges must have been added before
+	 * garbage collection is started
+	 * 
+	 * @param threshold The threshold of new methods required to trigger garbage
+	 *                  collection
+	 */
+	public void setMethodThreshold(int threshold) {
+		this.methodThreshold = threshold;
+	}
+
+	/**
+	 * Sets the minimum number of edges that shall be propagated before triggering
+	 * the garbage collection
+	 * 
+	 * @param threshold The minimum number of edges that shall be propagated before
+	 *                  triggering the garbage collection
+	 */
+	public void setEdgeThreshold(int threshold) {
+		this.edgeThreshold = threshold;
+	}
+
+	/**
+	 * Set the trigger that defines when garbage collection shall be started
+	 * 
+	 * @param trigger The trigger that defines when garbage collection shall be
+	 *                started
+	 */
+	public void setTrigger(GarbageCollectionTrigger trigger) {
+		this.trigger = trigger;
+	}
+
+	/**
+	 * Sets the peer group in which this solver operates. Peer groups are used to
+	 * synchronize active dependencies between multiple solvers.
+	 * 
+	 * @param peerGroup The peer group
+	 */
+	public void setPeerGroup(GarbageCollectorPeerGroup peerGroup) {
+		this.peerGroup = peerGroup;
+		peerGroup.addGarbageCollector(this);
+	}
+
+	/**
+	 * Sets whether the change counter shall be checked when identifying active
+	 * method dependencies
+	 * 
+	 * @param checkChangeCounter True to ensure consistency using change counters,
+	 *                           false otherwise
+	 */
+	public void setCheckChangeCounter(boolean checkChangeCounter) {
+		this.checkChangeCounter = checkChangeCounter;
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AbstractReferenceProvider.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AbstractReferenceProvider.java
new file mode 100644
index 0000000..f364edb
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AbstractReferenceProvider.java
@@ -0,0 +1,56 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import soot.SootMethod;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+
+/**
+ * Abstract base class for reference providers
+ * 
+ * @author Steven Arzt
+ *
+ */
+public abstract class AbstractReferenceProvider<D, N> implements IGCReferenceProvider<D, N> {
+
+	protected final BiDiInterproceduralCFG<N, SootMethod> icfg;
+
+	public AbstractReferenceProvider(BiDiInterproceduralCFG<N, SootMethod> icfg) {
+		this.icfg = icfg;
+	}
+
+	/**
+	 * Computes the set of transitive callees of the given method
+	 * 
+	 * @param method The method for which to compute callees
+	 * @return The set of transitive callees of the given method
+	 */
+	protected Set<SootMethod> getTransitiveCallees(SootMethod method) {
+		Set<SootMethod> callees = new HashSet<>();
+		List<SootMethod> workList = new ArrayList<>();
+		workList.add(method);
+
+		while (!workList.isEmpty()) {
+			SootMethod sm = workList.remove(0);
+			if (sm.isConcrete()) {
+				// We can only look for callees if we have a body
+				if (!sm.hasActiveBody())
+					sm.retrieveActiveBody();
+
+				// Schedule the callees
+				for (N callSite : icfg.getCallsFromWithin(sm)) {
+					for (SootMethod callee : icfg.getCalleesOfCallAt(callSite)) {
+						if (callees.add(callee))
+							workList.add(callee);
+					}
+				}
+			}
+		}
+
+		return callees;
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AggressiveGarbageCollector.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AggressiveGarbageCollector.java
new file mode 100644
index 0000000..20a9afe
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AggressiveGarbageCollector.java
@@ -0,0 +1,85 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import java.util.Iterator;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import heros.solver.Pair;
+import heros.solver.PathEdge;
+import soot.SootMethod;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+import soot.util.ConcurrentHashMultiMap;
+
+/**
+ * Aggressive garbage collector that optimizes memory usage, but may degrade
+ * performance by removing path edges too early. This implementation does not
+ * necessarily guarantee that the analysis terminates at all. Use with caution.
+ * 
+ * @author Steven Arzt
+ *
+ */
+public class AggressiveGarbageCollector<N, D> extends AbstractGarbageCollector<N, D> {
+
+	private final AtomicInteger gcedMethods = new AtomicInteger();
+
+	/**
+	 * The number of methods for which to collect jump functions, before halting the
+	 * taint propagation and actually cleaning them up
+	 */
+	private int methodThreshold = 0;
+
+	public AggressiveGarbageCollector(BiDiInterproceduralCFG<N, SootMethod> icfg,
+			ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions) {
+		super(icfg, jumpFunctions);
+	}
+
+	@Override
+	public void notifyEdgeSchedule(PathEdge<N, D> edge) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void notifyTaskProcessed(PathEdge<N, D> edge) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void gc() {
+		Iterator<Pair<SootMethod, PathEdge<N, D>>> it = jumpFunctions.iterator();
+		while (jumpFunctions.size() > methodThreshold) {
+			it.next();
+			it.remove();
+			gcedMethods.incrementAndGet();
+		}
+	}
+
+	@Override
+	public int getGcedMethods() {
+		return gcedMethods.get();
+	}
+
+	@Override
+	public int getGcedEdges() {
+		// We don't keep track of individual edges
+		return 0;
+	}
+
+	/**
+	 * Sets the number of methods for which edges must have been added before
+	 * garbage collection is started
+	 * 
+	 * @param threshold The threshold of new methods required to trigger garbage
+	 *                  collection
+	 */
+	public void setMethodThreshold(int threshold) {
+		this.methodThreshold = threshold;
+	}
+
+	@Override
+	public void notifySolverTerminated() {
+		// TODO Auto-generated method stub
+
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AheadOfTimeReferenceProvider.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AheadOfTimeReferenceProvider.java
new file mode 100644
index 0000000..0f2fb1a
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/AheadOfTimeReferenceProvider.java
@@ -0,0 +1,40 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import java.util.Set;
+
+import soot.Scene;
+import soot.SootClass;
+import soot.SootMethod;
+import soot.jimple.infoflow.solver.fastSolver.FastSolverLinkedNode;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+import soot.util.HashMultiMap;
+import soot.util.MultiMap;
+
+/**
+ * Implementation of a reference provider that computes its dependencies ahead
+ * of time, and over-approximates the possible references by considering all
+ * transitively callees of a given method as possible locations for new analysis
+ * tasks, regardless of context and taint state.
+ * 
+ * @author Steven Arzt
+ */
+public class AheadOfTimeReferenceProvider<D, N> extends AbstractReferenceProvider<D, N> {
+
+	private final MultiMap<SootMethod, SootMethod> methodToCallees = new HashMultiMap<>();
+
+	public AheadOfTimeReferenceProvider(BiDiInterproceduralCFG<N, SootMethod> icfg) {
+		super(icfg);
+
+		// Initialize the caller/callee relationships
+		for (SootClass sc : Scene.v().getClasses()) {
+			for (SootMethod sm : sc.getMethods())
+				methodToCallees.putAll(sm, getTransitiveCallees(sm));
+		}
+	}
+
+	@Override
+	public Set<SootMethod> getMethodReferences(SootMethod method, FastSolverLinkedNode<D, N> context) {
+		return methodToCallees.get(method);
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/DefaultGarbageCollector.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/DefaultGarbageCollector.java
new file mode 100644
index 0000000..0248144
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/DefaultGarbageCollector.java
@@ -0,0 +1,37 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import heros.solver.PathEdge;
+import soot.SootMethod;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+import soot.util.ConcurrentHashMultiMap;
+
+/**
+ * The default garbage collector implementation
+ * 
+ * @author Steven Arzt
+ *
+ */
+public class DefaultGarbageCollector<N, D> extends AbstractReferenceCountingGarbageCollector<N, D> {
+
+	public DefaultGarbageCollector(BiDiInterproceduralCFG<N, SootMethod> icfg,
+			ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions) {
+		super(icfg, jumpFunctions);
+	}
+
+	public DefaultGarbageCollector(BiDiInterproceduralCFG<N, SootMethod> icfg,
+			ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions,
+			IGCReferenceProvider<D, N> referenceProvider) {
+		super(icfg, jumpFunctions, referenceProvider);
+	}
+
+	@Override
+	public void gc() {
+		gcImmediate();
+	}
+
+	@Override
+	public void notifySolverTerminated() {
+		// nothing to do here
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/GCSolverPeerGroup.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/GCSolverPeerGroup.java
new file mode 100644
index 0000000..b22c98c
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/GCSolverPeerGroup.java
@@ -0,0 +1,29 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import soot.jimple.infoflow.solver.SolverPeerGroup;
+
+/**
+ * Specialized solver peer group for garbage-collecting solvers
+ * 
+ * @author Steven Arzt
+ *
+ */
+public class GCSolverPeerGroup extends SolverPeerGroup {
+
+	private GarbageCollectorPeerGroup gcPeerGroup = null;
+
+	public GCSolverPeerGroup() {
+	}
+
+	/**
+	 * Creates the peer group for the garbage collectors
+	 * 
+	 * @return The garbage collector peer group
+	 */
+	public GarbageCollectorPeerGroup getGCPeerGroup() {
+		if (gcPeerGroup == null)
+			gcPeerGroup = new GarbageCollectorPeerGroup();
+		return gcPeerGroup;
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/GarbageCollectionTrigger.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/GarbageCollectionTrigger.java
new file mode 100644
index 0000000..8ebba58
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/GarbageCollectionTrigger.java
@@ -0,0 +1,33 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+/**
+ * Possible triggers when to start garbage collection
+ * 
+ * @author Steven Arzt
+ *
+ */
+public enum GarbageCollectionTrigger {
+
+	/**
+	 * Garbage collection is triggered immediately when a new edge has been
+	 * propagated
+	 */
+	Immediate,
+
+	/**
+	 * Start garbage collection after the method threshold has been reached
+	 */
+	MethodThreshold,
+
+	/**
+	 * Start garbage collection after the edge threshold has been reached
+	 */
+	EdgeThreshold,
+
+	/**
+	 * Compute the thresholds, but never actually gargabe-collect anything. Useful
+	 * only as a performance baseline.
+	 */
+	Never
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/GarbageCollectorPeerGroup.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/GarbageCollectorPeerGroup.java
new file mode 100644
index 0000000..45ce234
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/GarbageCollectorPeerGroup.java
@@ -0,0 +1,44 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import java.util.Collection;
+import java.util.HashSet;
+
+import soot.SootMethod;
+
+/**
+ * Set of multiple garbage collectors that share a set of active dependencies
+ * 
+ * @author Steven Arzt
+ *
+ */
+public class GarbageCollectorPeerGroup implements IGarbageCollectorPeer {
+
+	private final Collection<IGarbageCollectorPeer> peers;
+
+	public GarbageCollectorPeerGroup() {
+		this.peers = new HashSet<>();
+	}
+
+	public GarbageCollectorPeerGroup(Collection<IGarbageCollectorPeer> peers) {
+		this.peers = peers;
+	}
+
+	@Override
+	public boolean hasActiveDependencies(SootMethod method) {
+		for (IGarbageCollectorPeer peer : peers) {
+			if (peer.hasActiveDependencies(method))
+				return true;
+		}
+		return false;
+	}
+
+	/**
+	 * Adds a garbage collector to this peer group
+	 * 
+	 * @param peer The garbage collector to add
+	 */
+	public void addGarbageCollector(IGarbageCollectorPeer peer) {
+		this.peers.add(peer);
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IFDSSolver.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IFDSSolver.java
new file mode 100644
index 0000000..847d0a1
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IFDSSolver.java
@@ -0,0 +1,971 @@
+/*******************************************************************************
+ * Copyright (c) 2012 Eric Bodden.
+ * Copyright (c) 2013 Tata Consultancy Services & Ecole Polytechnique de Montreal
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the GNU Lesser Public License v2.1
+ * which accompanies this distribution, and is available at
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * 
+ * Contributors:
+ *     Eric Bodden - initial API and implementation
+ *     Marc-Andre Laverdiere-Papineau - Fixed race condition
+ *     Steven Arzt - Created FastSolver implementation
+ ******************************************************************************/
+package soot.jimple.infoflow.solver.gcSolver;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.cache.CacheBuilder;
+
+import heros.DontSynchronize;
+import heros.FlowFunction;
+import heros.FlowFunctionCache;
+import heros.FlowFunctions;
+import heros.IFDSTabulationProblem;
+import heros.SynchronizedBy;
+import heros.ZeroedFlowFunctions;
+import heros.solver.Pair;
+import heros.solver.PathEdge;
+import soot.SootMethod;
+import soot.Unit;
+import soot.jimple.infoflow.collect.MyConcurrentHashMap;
+import soot.jimple.infoflow.memory.IMemoryBoundedSolver;
+import soot.jimple.infoflow.memory.ISolverTerminationReason;
+import soot.jimple.infoflow.solver.PredecessorShorteningMode;
+import soot.jimple.infoflow.solver.SolverPeerGroup;
+import soot.jimple.infoflow.solver.executors.InterruptableExecutor;
+import soot.jimple.infoflow.solver.executors.SetPoolExecutor;
+import soot.jimple.infoflow.solver.fastSolver.FastSolverLinkedNode;
+import soot.jimple.infoflow.solver.memory.IMemoryManager;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+import soot.util.ConcurrentHashMultiMap;
+
+/**
+ * A solver for an {@link IFDSTabulationProblem}. This solver is not based on
+ * the IDESolver implementation in Heros for performance reasons.
+ * 
+ * @param <N> The type of nodes in the interprocedural control-flow graph.
+ *        Typically {@link Unit}.
+ * @param <D> The type of data-flow facts to be computed by the tabulation
+ *        problem.
+ * @param <I> The type of inter-procedural control-flow graph being used.
+ * @see IFDSTabulationProblem
+ */
+public class IFDSSolver<N, D extends FastSolverLinkedNode<D, N>, I extends BiDiInterproceduralCFG<N, SootMethod>>
+		implements IMemoryBoundedSolver {
+
+	public static CacheBuilder<Object, Object> DEFAULT_CACHE_BUILDER = CacheBuilder.newBuilder()
+			.concurrencyLevel(Runtime.getRuntime().availableProcessors()).initialCapacity(10000).softValues();
+
+	protected static final Logger logger = LoggerFactory.getLogger(IFDSSolver.class);
+
+	// enable with -Dorg.slf4j.simpleLogger.defaultLogLevel=trace
+	public static final boolean DEBUG = logger.isDebugEnabled();
+
+	protected InterruptableExecutor executor;
+
+	@DontSynchronize("only used by single thread")
+	protected int numThreads;
+
+	@SynchronizedBy("thread safe data structure, consistent locking when used")
+	protected ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions = new ConcurrentHashMultiMap<>();
+
+	@SynchronizedBy("thread safe data structure")
+	protected volatile IGarbageCollector<N, D> garbageCollector;
+
+	@SynchronizedBy("thread safe data structure, only modified internally")
+	protected final I icfg;
+
+	// stores summaries that were queried before they were computed
+	// see CC 2010 paper by Naeem, Lhotak and Rodriguez
+	@SynchronizedBy("consistent lock on 'incoming'")
+	protected final MyConcurrentHashMap<Pair<SootMethod, D>, Map<Pair<N, D>, D>> endSummary = new MyConcurrentHashMap<>();
+
+	// edges going along calls
+	// see CC 2010 paper by Naeem, Lhotak and Rodriguez
+	@SynchronizedBy("consistent lock on field")
+	protected final ConcurrentHashMultiMap<Pair<SootMethod, D>, IncomingRecord<N, D>> incoming = new ConcurrentHashMultiMap<>();
+
+	@DontSynchronize("stateless")
+	protected final FlowFunctions<N, D, SootMethod> flowFunctions;
+
+	@DontSynchronize("only used by single thread")
+	protected final Map<N, Set<D>> initialSeeds;
+
+	@DontSynchronize("benign races")
+	public long propagationCount;
+
+	@DontSynchronize("stateless")
+	protected final D zeroValue;
+
+	@DontSynchronize("readOnly")
+	protected final FlowFunctionCache<N, D, SootMethod> ffCache;
+
+	@DontSynchronize("readOnly")
+	protected final boolean followReturnsPastSeeds;
+
+	@DontSynchronize("readOnly")
+	protected PredecessorShorteningMode shorteningMode = PredecessorShorteningMode.NeverShorten;
+
+	@DontSynchronize("readOnly")
+	private int maxJoinPointAbstractions = -1;
+
+	@DontSynchronize("readOnly")
+	protected IMemoryManager<D, N> memoryManager = null;
+
+	protected boolean solverId;
+
+	private Set<IMemoryBoundedSolverStatusNotification> notificationListeners = new HashSet<>();
+	private ISolverTerminationReason killFlag = null;
+
+	private int maxCalleesPerCallSite = 75;
+	private int maxAbstractionPathLength = 100;
+
+	protected SolverPeerGroup solverPeerGroup;
+
+	/**
+	 * Creates a solver for the given problem, which caches flow functions and edge
+	 * functions. The solver must then be started by calling {@link #solve()}.
+	 */
+	public IFDSSolver(IFDSTabulationProblem<N, D, SootMethod, I> tabulationProblem) {
+		this(tabulationProblem, DEFAULT_CACHE_BUILDER);
+	}
+
+	/**
+	 * Creates a solver for the given problem, constructing caches with the given
+	 * {@link CacheBuilder}. The solver must then be started by calling
+	 * {@link #solve()}.
+	 * 
+	 * @param tabulationProblem        The tabulation problem to solve
+	 * @param flowFunctionCacheBuilder A valid {@link CacheBuilder} or
+	 *                                 <code>null</code> if no caching is to be used
+	 *                                 for flow functions.
+	 */
+	public IFDSSolver(IFDSTabulationProblem<N, D, SootMethod, I> tabulationProblem,
+			@SuppressWarnings("rawtypes") CacheBuilder flowFunctionCacheBuilder) {
+		if (logger.isDebugEnabled())
+			flowFunctionCacheBuilder = flowFunctionCacheBuilder.recordStats();
+		this.zeroValue = tabulationProblem.zeroValue();
+		this.icfg = tabulationProblem.interproceduralCFG();
+		FlowFunctions<N, D, SootMethod> flowFunctions = tabulationProblem.autoAddZero()
+				? new ZeroedFlowFunctions<N, D, SootMethod>(tabulationProblem.flowFunctions(), zeroValue)
+				: tabulationProblem.flowFunctions();
+		if (flowFunctionCacheBuilder != null) {
+			ffCache = new FlowFunctionCache<N, D, SootMethod>(flowFunctions, flowFunctionCacheBuilder);
+			flowFunctions = ffCache;
+		} else {
+			ffCache = null;
+		}
+		this.flowFunctions = flowFunctions;
+		this.initialSeeds = tabulationProblem.initialSeeds();
+		this.followReturnsPastSeeds = tabulationProblem.followReturnsPastSeeds();
+		this.numThreads = Math.max(1, tabulationProblem.numThreads());
+		this.executor = getExecutor();
+	}
+
+	/**
+	 * Factory method for creating an instance of the garbage collector
+	 * 
+	 * @return The new garbage collector
+	 */
+	protected IGarbageCollector<N, D> createGarbageCollector() {
+		if (garbageCollector != null)
+			return garbageCollector;
+
+//		DefaultGarbageCollector<N, D> gc = new DefaultGarbageCollector<>(icfg, jumpFunctions);
+		ThreadedGarbageCollector<N, D> gc = new ThreadedGarbageCollector<>(icfg, jumpFunctions);
+		GCSolverPeerGroup gcSolverGroup = (GCSolverPeerGroup) solverPeerGroup;
+		gc.setPeerGroup(gcSolverGroup.getGCPeerGroup());
+		return garbageCollector = gc;
+	}
+
+	public void setSolverId(boolean solverId) {
+		this.solverId = solverId;
+	}
+
+	/**
+	 * Runs the solver on the configured problem. This can take some time.
+	 */
+	public void solve() {
+		reset();
+
+		// Make sure that we have an instance of the garbage collector
+		if (this.garbageCollector == null)
+			this.garbageCollector = createGarbageCollector();
+
+		// Notify the listeners that the solver has been started
+		for (IMemoryBoundedSolverStatusNotification listener : notificationListeners)
+			listener.notifySolverStarted(this);
+
+		submitInitialSeeds();
+		awaitCompletionComputeValuesAndShutdown();
+
+		// Notify the listeners that the solver has been terminated
+		for (IMemoryBoundedSolverStatusNotification listener : notificationListeners)
+			listener.notifySolverTerminated(this);
+
+		logger.info(String.format("GC removed abstractions for %d methods", garbageCollector.getGcedMethods()));
+		this.garbageCollector.notifySolverTerminated();
+	}
+
+	/**
+	 * Schedules the processing of initial seeds, initiating the analysis. Clients
+	 * should only call this methods if performing synchronization on their own.
+	 * Normally, {@link #solve()} should be called instead.
+	 */
+	protected void submitInitialSeeds() {
+		for (Entry<N, Set<D>> seed : initialSeeds.entrySet()) {
+			N startPoint = seed.getKey();
+			for (D val : seed.getValue())
+				propagate(zeroValue, startPoint, val, null, false);
+			addFunction(new PathEdge<N, D>(zeroValue, startPoint, zeroValue));
+		}
+	}
+
+	/**
+	 * Awaits the completion of the exploded super graph. When complete, computes
+	 * result values, shuts down the executor and returns.
+	 */
+	protected void awaitCompletionComputeValuesAndShutdown() {
+		{
+			// run executor and await termination of tasks
+			runExecutorAndAwaitCompletion();
+		}
+		if (logger.isDebugEnabled())
+			printStats();
+
+		// ask executor to shut down;
+		// this will cause new submissions to the executor to be rejected,
+		// but at this point all tasks should have completed anyway
+		executor.shutdown();
+
+		// Wait for the executor to be really gone
+		while (!executor.isTerminated()) {
+			try {
+				Thread.sleep(100);
+			} catch (InterruptedException e) {
+				// silently ignore the exception, it's not an issue if the
+				// thread gets aborted
+			}
+		}
+	}
+
+	/**
+	 * Runs execution, re-throwing exceptions that might be thrown during its
+	 * execution.
+	 */
+	private void runExecutorAndAwaitCompletion() {
+		try {
+			executor.awaitCompletion();
+		} catch (InterruptedException e) {
+			e.printStackTrace();
+		}
+		Throwable exception = executor.getException();
+		if (exception != null) {
+			throw new RuntimeException("There were exceptions during IFDS analysis. Exiting.", exception);
+		}
+	}
+
+	/**
+	 * Dispatch the processing of a given edge. It may be executed in a different
+	 * thread.
+	 * 
+	 * @param edge the edge to process
+	 */
+	protected void scheduleEdgeProcessing(PathEdge<N, D> edge) {
+		// If the executor has been killed, there is little point
+		// in submitting new tasks
+		if (killFlag != null || executor.isTerminating() || executor.isTerminated())
+			return;
+
+		garbageCollector.notifyEdgeSchedule(edge);
+		executor.execute(new PathEdgeProcessingTask(edge, solverId));
+		propagationCount++;
+		garbageCollector.gc();
+	}
+
+	/**
+	 * Lines 13-20 of the algorithm; processing a call site in the caller's context.
+	 * 
+	 * For each possible callee, registers incoming call edges. Also propagates
+	 * call-to-return flows and summarized callee flows within the caller.
+	 * 
+	 * @param edge an edge whose target node resembles a method call
+	 */
+	private void processCall(PathEdge<N, D> edge) {
+		final D d1 = edge.factAtSource();
+		final N n = edge.getTarget(); // a call node; line 14...
+		final D d2 = edge.factAtTarget();
+		assert d2 != null;
+		Collection<N> returnSiteNs = icfg.getReturnSitesOfCallAt(n);
+
+		// for each possible callee
+		Collection<SootMethod> callees = icfg.getCalleesOfCallAt(n);
+		if (maxCalleesPerCallSite < 0 || callees.size() <= maxCalleesPerCallSite) {
+			callees.stream().filter(m -> m.isConcrete()).forEach(new Consumer<SootMethod>() {
+
+				@Override
+				public void accept(SootMethod sCalledProcN) {
+					// Early termination check
+					if (killFlag != null)
+						return;
+
+					// compute the call-flow function
+					FlowFunction<D> function = flowFunctions.getCallFlowFunction(n, sCalledProcN);
+					Set<D> res = computeCallFlowFunction(function, d1, d2);
+
+					if (res != null && !res.isEmpty()) {
+						Collection<N> startPointsOf = icfg.getStartPointsOf(sCalledProcN);
+						// for each result node of the call-flow function
+						for (D d3 : res) {
+							if (memoryManager != null)
+								d3 = memoryManager.handleGeneratedMemoryObject(d2, d3);
+							if (d3 == null)
+								continue;
+
+							// register the fact that <sp,d3> has an incoming edge from
+							// <n,d2>
+							// line 15.1 of Naeem/Lhotak/Rodriguez
+							if (!addIncoming(sCalledProcN, d3, n, d1, d2))
+								continue;
+
+							// If we already have a summary, we take that summary instead of propagating
+							// through the callee again
+							if (applyEndSummaryOnCall(d1, n, d2, returnSiteNs, sCalledProcN, d3))
+								continue;
+
+							// for each callee's start point(s)
+							for (N sP : startPointsOf) {
+								// create initial self-loop
+								propagate(d3, sP, d3, n, false); // line 15
+							}
+						}
+					}
+				}
+
+			});
+		}
+
+		// line 17-19 of Naeem/Lhotak/Rodriguez
+		// process intra-procedural flows along call-to-return flow functions
+		for (N returnSiteN : returnSiteNs) {
+			FlowFunction<D> callToReturnFlowFunction = flowFunctions.getCallToReturnFlowFunction(n, returnSiteN);
+			Set<D> res = computeCallToReturnFlowFunction(callToReturnFlowFunction, d1, d2);
+			if (res != null && !res.isEmpty()) {
+				for (D d3 : res) {
+					if (memoryManager != null)
+						d3 = memoryManager.handleGeneratedMemoryObject(d2, d3);
+					if (d3 != null)
+						propagate(d1, returnSiteN, d3, n, false);
+				}
+			}
+		}
+	}
+
+	protected boolean applyEndSummaryOnCall(final D d1, final N n, final D d2, Collection<N> returnSiteNs,
+			SootMethod sCalledProcN, D d3) {
+		// line 15.2
+		Map<Pair<N, D>, D> endSumm = endSummaryMap(sCalledProcN, d3);
+
+		// still line 15.2 of Naeem/Lhotak/Rodriguez
+		// for each already-queried exit value <eP,d4> reachable
+		// from <sP,d3>, create new caller-side jump functions to
+		// the return sites because we have observed a potentially
+		// new incoming edge into <sP,d3>
+		if (endSumm != null && !endSumm.isEmpty()) {
+			for (Pair<N, D> entry : endSumm.keySet()) {
+				N eP = entry.getO1();
+				D d4 = entry.getO2();
+				// for each return site
+				for (N retSiteN : returnSiteNs) {
+					// compute return-flow function
+					FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(n, sCalledProcN, eP, retSiteN);
+					Set<D> retFlowRes = computeReturnFlowFunction(retFunction, d3, d4, n, Collections.singleton(d1));
+					if (retFlowRes != null && !retFlowRes.isEmpty()) {
+						// for each target value of the function
+						for (D d5 : retFlowRes) {
+							if (memoryManager != null)
+								d5 = memoryManager.handleGeneratedMemoryObject(d4, d5);
+
+							// If we have not changed anything in
+							// the callee, we do not need the facts from
+							// there. Even if we change something:
+							// If we don't need the concrete path,
+							// we can skip the callee in the predecessor
+							// chain
+							D d5p = d5;
+							switch (shorteningMode) {
+							case AlwaysShorten:
+								if (d5p != d2) {
+									d5p = d5p.clone();
+									d5p.setPredecessor(d2);
+								}
+								break;
+							case ShortenIfEqual:
+								if (d5.equals(d2))
+									d5p = d2;
+								break;
+							}
+							D oldD1 = endSumm.get(entry);
+							if (oldD1 != d1)
+								oldD1.addNeighbor(d3);
+							propagate(d1, retSiteN, d5p, n, false);
+						}
+					}
+				}
+			}
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	 * Computes the call flow function for the given call-site abstraction
+	 * 
+	 * @param callFlowFunction The call flow function to compute
+	 * @param d1               The abstraction at the current method's start node.
+	 * @param d2               The abstraction at the call site
+	 * @return The set of caller-side abstractions at the callee's start node
+	 */
+	protected Set<D> computeCallFlowFunction(FlowFunction<D> callFlowFunction, D d1, D d2) {
+		return callFlowFunction.computeTargets(d2);
+	}
+
+	/**
+	 * Computes the call-to-return flow function for the given call-site abstraction
+	 * 
+	 * @param callToReturnFlowFunction The call-to-return flow function to compute
+	 * @param d1                       The abstraction at the current method's start
+	 *                                 node.
+	 * @param d2                       The abstraction at the call site
+	 * @return The set of caller-side abstractions at the return site
+	 */
+	protected Set<D> computeCallToReturnFlowFunction(FlowFunction<D> callToReturnFlowFunction, D d1, D d2) {
+		return callToReturnFlowFunction.computeTargets(d2);
+	}
+
+	/**
+	 * Lines 21-32 of the algorithm.
+	 * 
+	 * Stores callee-side summaries. Also, at the side of the caller, propagates
+	 * intra-procedural flows to return sites using those newly computed summaries.
+	 * 
+	 * @param edge an edge whose target node resembles a method exits
+	 */
+	protected void processExit(PathEdge<N, D> edge) {
+		final N n = edge.getTarget(); // an exit node; line 21...
+		SootMethod methodThatNeedsSummary = icfg.getMethodOf(n);
+
+		final D d1 = edge.factAtSource();
+		final D d2 = edge.factAtTarget();
+
+		// for each of the method's start points, determine incoming calls
+
+		// line 21.1 of Naeem/Lhotak/Rodriguez
+		// register end-summary
+		if (!addEndSummary(methodThatNeedsSummary, d1, n, d2))
+			return;
+		Set<IncomingRecord<N, D>> inc = incoming(d1, methodThatNeedsSummary);
+
+		// for each incoming call edge already processed
+		// (see processCall(..))
+		if (inc != null && !inc.isEmpty()) {
+			for (IncomingRecord<N, D> entry : inc) {
+				// Early termination check
+				if (killFlag != null)
+					return;
+
+				// line 22
+				N c = entry.n;
+				Set<D> callerSideDs = Collections.singleton(entry.d1);
+				// for each return site
+				for (N retSiteC : icfg.getReturnSitesOfCallAt(c)) {
+					// compute return-flow function
+					FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary, n,
+							retSiteC);
+					Set<D> targets = computeReturnFlowFunction(retFunction, d1, d2, c, callerSideDs);
+					// for each incoming-call value
+					if (targets != null && !targets.isEmpty()) {
+						final D d4 = entry.d1;
+						final D predVal = entry.d2;
+
+						for (D d5 : targets) {
+							if (memoryManager != null)
+								d5 = memoryManager.handleGeneratedMemoryObject(d2, d5);
+							if (d5 == null)
+								continue;
+
+							// If we have not changed anything in the callee, we do not need the facts from
+							// there. Even if we change something: If we don't need the concrete path, we
+							// can skip the callee in the predecessor chain
+							D d5p = d5;
+							switch (shorteningMode) {
+							case AlwaysShorten:
+								if (d5p != predVal) {
+									d5p = d5p.clone();
+									d5p.setPredecessor(predVal);
+								}
+								break;
+							case ShortenIfEqual:
+								if (d5.equals(predVal))
+									d5p = predVal;
+								break;
+							}
+							propagate(d4, retSiteC, d5p, c, false);
+
+							// Make sure all of the incoming edges are registered with the edge from the new
+							// summary
+							d1.addNeighbor(entry.d3);
+						}
+					}
+				}
+			}
+		}
+
+		// handling for unbalanced problems where we return out of a method with
+		// a fact for which we have no incoming flow
+		// note: we propagate that way only values that originate from ZERO, as
+		// conditionally generated values should only be propagated into callers that
+		// have an incoming edge for this condition
+		if (followReturnsPastSeeds && d1 == zeroValue && (inc == null || inc.isEmpty())) {
+			Collection<N> callers = icfg.getCallersOf(methodThatNeedsSummary);
+			for (N c : callers) {
+				for (N retSiteC : icfg.getReturnSitesOfCallAt(c)) {
+					FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(c, methodThatNeedsSummary, n,
+							retSiteC);
+					Set<D> targets = computeReturnFlowFunction(retFunction, d1, d2, c,
+							Collections.singleton(zeroValue));
+					if (targets != null && !targets.isEmpty()) {
+						for (D d5 : targets) {
+							if (memoryManager != null)
+								d5 = memoryManager.handleGeneratedMemoryObject(d2, d5);
+							if (d5 != null)
+								propagate(zeroValue, retSiteC, d5, c, true);
+						}
+					}
+				}
+			}
+			// in cases where there are no callers, the return statement would
+			// normally not be processed at all; this might be undesirable if the flow
+			// function has a side effect such as registering a taint; instead we thus call
+			// the return flow function will a null caller
+			if (callers.isEmpty()) {
+				FlowFunction<D> retFunction = flowFunctions.getReturnFlowFunction(null, methodThatNeedsSummary, n,
+						null);
+				retFunction.computeTargets(d2);
+			}
+		}
+	}
+
+	/**
+	 * Computes the return flow function for the given set of caller-side
+	 * abstractions.
+	 * 
+	 * @param retFunction  The return flow function to compute
+	 * @param d1           The abstraction at the beginning of the callee
+	 * @param d2           The abstraction at the exit node in the callee
+	 * @param callSite     The call site
+	 * @param callerSideDs The abstractions at the call site
+	 * @return The set of caller-side abstractions at the return site
+	 */
+	protected Set<D> computeReturnFlowFunction(FlowFunction<D> retFunction, D d1, D d2, N callSite,
+			Collection<D> callerSideDs) {
+		return retFunction.computeTargets(d2);
+	}
+
+	/**
+	 * Lines 33-37 of the algorithm. Simply propagate normal, intra-procedural
+	 * flows.
+	 * 
+	 * @param edge
+	 */
+	private void processNormalFlow(PathEdge<N, D> edge) {
+		final D d1 = edge.factAtSource();
+		final N n = edge.getTarget();
+		final D d2 = edge.factAtTarget();
+
+		for (N m : icfg.getSuccsOf(n)) {
+			// Early termination check
+			if (killFlag != null)
+				return;
+
+			// Compute the flow function
+			FlowFunction<D> flowFunction = flowFunctions.getNormalFlowFunction(n, m);
+			Set<D> res = computeNormalFlowFunction(flowFunction, d1, d2);
+			if (res != null && !res.isEmpty()) {
+				for (D d3 : res) {
+					if (memoryManager != null && d2 != d3)
+						d3 = memoryManager.handleGeneratedMemoryObject(d2, d3);
+					if (d3 != null)
+						propagate(d1, m, d3, null, false);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Computes the normal flow function for the given set of start and end
+	 * abstractions.
+	 * 
+	 * @param flowFunction The normal flow function to compute
+	 * @param d1           The abstraction at the method's start node
+	 * @param d2           The abstraction at the current node
+	 * @return The set of abstractions at the successor node
+	 */
+	protected Set<D> computeNormalFlowFunction(FlowFunction<D> flowFunction, D d1, D d2) {
+		return flowFunction.computeTargets(d2);
+	}
+
+	/**
+	 * Propagates the flow further down the exploded super graph.
+	 * 
+	 * @param sourceVal          the source value of the propagated summary edge
+	 * @param target             the target statement
+	 * @param targetVal          the target value at the target statement
+	 * @param relatedCallSite    for call and return flows the related call
+	 *                           statement, <code>null</code> otherwise (this value
+	 *                           is not used within this implementation but may be
+	 *                           useful for subclasses of {@link IFDSSolver})
+	 * @param isUnbalancedReturn <code>true</code> if this edge is propagating an
+	 *                           unbalanced return (this value is not used within
+	 *                           this implementation but may be useful for
+	 *                           subclasses of {@link IFDSSolver})
+	 */
+	protected void propagate(D sourceVal, N target, D targetVal,
+			/* deliberately exposed to clients */ N relatedCallSite,
+			/* deliberately exposed to clients */ boolean isUnbalancedReturn) {
+		// Let the memory manager run
+		if (memoryManager != null) {
+			sourceVal = memoryManager.handleMemoryObject(sourceVal);
+			targetVal = memoryManager.handleMemoryObject(targetVal);
+			if (targetVal == null)
+				return;
+		}
+
+		// Check the path length
+		if (maxAbstractionPathLength >= 0 && targetVal.getPathLength() > maxAbstractionPathLength)
+			return;
+
+		final PathEdge<N, D> edge = new PathEdge<N, D>(sourceVal, target, targetVal);
+		final D existingVal = addFunction(edge);
+		if (existingVal != null) {
+			if (existingVal != targetVal) {
+				// Check whether we need to retain this abstraction
+				boolean isEssential;
+				if (memoryManager == null)
+					isEssential = relatedCallSite != null && icfg.isCallStmt(relatedCallSite);
+				else
+					isEssential = memoryManager.isEssentialJoinPoint(targetVal, relatedCallSite);
+
+				if (maxJoinPointAbstractions < 0 || existingVal.getNeighborCount() < maxJoinPointAbstractions
+						|| isEssential) {
+					existingVal.addNeighbor(targetVal);
+				}
+			}
+		} else
+			scheduleEdgeProcessing(edge);
+	}
+
+	/**
+	 * Records a jump function. The source statement is implicit.
+	 * 
+	 * @see PathEdge
+	 */
+	public D addFunction(PathEdge<N, D> edge) {
+		PathEdge<N, D> oldEdge = jumpFunctions.putIfAbsent(icfg.getMethodOf(edge.getTarget()), edge);
+		return oldEdge == null ? null : oldEdge.factAtTarget();
+	}
+
+	protected Map<Pair<N, D>, D> endSummaryMap(SootMethod m, D d3) {
+		Map<Pair<N, D>, D> map = endSummary.get(new Pair<SootMethod, D>(m, d3));
+		return map;
+	}
+
+	private boolean addEndSummary(SootMethod m, D d1, N eP, D d2) {
+		if (d1 == zeroValue)
+			return true;
+
+		Map<Pair<N, D>, D> summaries = endSummary.putIfAbsentElseGet(new Pair<SootMethod, D>(m, d1),
+				() -> new MyConcurrentHashMap<>());
+		D oldD1 = summaries.putIfAbsent(new Pair<N, D>(eP, d2), d1);
+		if (oldD1 != null) {
+			oldD1.addNeighbor(d1);
+			return false;
+		}
+		return true;
+	}
+
+	protected static class IncomingRecord<N, D extends FastSolverLinkedNode<D, N>> {
+
+		public final N n;
+		public final D d1;
+		public final D d2;
+		public final D d3;
+
+		public IncomingRecord(N n, D d1, D d2, D d3) {
+			this.n = n;
+			this.d1 = d1;
+			this.d2 = d2;
+			this.d3 = d3;
+		}
+
+		@Override
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + ((d1 == null) ? 0 : d1.hashCode());
+			result = prime * result + ((d2 == null) ? 0 : d2.hashCode());
+			result = prime * result + ((d3 == null) ? 0 : d3.hashCode());
+			result = prime * result + ((n == null) ? 0 : n.hashCode());
+			return result;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (obj == null)
+				return false;
+			if (getClass() != obj.getClass())
+				return false;
+			IncomingRecord other = (IncomingRecord) obj;
+			if (d1 == null) {
+				if (other.d1 != null)
+					return false;
+			} else if (!d1.equals(other.d1))
+				return false;
+			if (d2 == null) {
+				if (other.d2 != null)
+					return false;
+			} else if (!d2.equals(other.d2))
+				return false;
+			if (d3 == null) {
+				if (other.d3 != null)
+					return false;
+			} else if (!d3.equals(other.d3))
+				return false;
+			if (n == null) {
+				if (other.n != null)
+					return false;
+			} else if (!n.equals(other.n))
+				return false;
+			return true;
+		}
+
+	}
+
+	protected Set<IncomingRecord<N, D>> incoming(D d1, SootMethod m) {
+		Set<IncomingRecord<N, D>> inc = incoming.get(new Pair<SootMethod, D>(m, d1));
+		return inc;
+	}
+
+	protected boolean addIncoming(SootMethod m, D d3, N n, D d1, D d2) {
+		IncomingRecord<N, D> newRecord = new IncomingRecord<N, D>(n, d1, d2, d3);
+		IncomingRecord<N, D> rec = incoming.putIfAbsent(new Pair<SootMethod, D>(m, d3), newRecord);
+		return rec == null;
+	}
+
+	/**
+	 * Factory method for this solver's thread-pool executor.
+	 */
+	protected InterruptableExecutor getExecutor() {
+		SetPoolExecutor executor = new SetPoolExecutor(1, this.numThreads, 30, TimeUnit.SECONDS,
+				new LinkedBlockingQueue<Runnable>());
+		executor.setThreadFactory(new ThreadFactory() {
+
+			@Override
+			public Thread newThread(Runnable r) {
+				Thread thrIFDS = new Thread(r);
+				thrIFDS.setDaemon(true);
+				thrIFDS.setName("IFDS Solver");
+				return thrIFDS;
+			}
+		});
+		return executor;
+	}
+
+	/**
+	 * Returns a String used to identify the output of this solver in debug mode.
+	 * Subclasses can overwrite this string to distinguish the output from different
+	 * solvers.
+	 */
+	protected String getDebugName() {
+		return "FAST IFDS SOLVER";
+	}
+
+	public void printStats() {
+		if (logger.isDebugEnabled()) {
+			if (ffCache != null)
+				ffCache.printStats();
+		} else {
+			logger.info("No statistics were collected, as DEBUG is disabled.");
+		}
+	}
+
+	private class PathEdgeProcessingTask implements Runnable {
+
+		private final PathEdge<N, D> edge;
+		private final boolean solverId;
+
+		public PathEdgeProcessingTask(PathEdge<N, D> edge, boolean solverId) {
+			this.edge = edge;
+			this.solverId = solverId;
+		}
+
+		public void run() {
+			if (icfg.isCallStmt(edge.getTarget())) {
+				processCall(edge);
+			} else {
+				// note that some statements, such as "throw" may be
+				// both an exit statement and a "normal" statement
+				if (icfg.isExitStmt(edge.getTarget()))
+					processExit(edge);
+				if (!icfg.getSuccsOf(edge.getTarget()).isEmpty())
+					processNormalFlow(edge);
+			}
+			garbageCollector.notifyTaskProcessed(edge);
+		}
+
+		@Override
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + ((edge == null) ? 0 : edge.hashCode());
+			result = prime * result + (solverId ? 1231 : 1237);
+			return result;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (obj == null)
+				return false;
+			if (getClass() != obj.getClass())
+				return false;
+			PathEdgeProcessingTask other = (PathEdgeProcessingTask) obj;
+			if (edge == null) {
+				if (other.edge != null)
+					return false;
+			} else if (!edge.equals(other.edge))
+				return false;
+			if (solverId != other.solverId)
+				return false;
+			return true;
+		}
+
+	}
+
+	/**
+	 * Sets whether abstractions on method returns shall be connected to the
+	 * respective call abstractions to shortcut paths.
+	 * 
+	 * @param mode The strategy to use for shortening predecessor paths
+	 */
+	public void setPredecessorShorteningMode(PredecessorShorteningMode mode) {
+		// this.shorteningMode = mode;
+	}
+
+	/**
+	 * Sets the maximum number of abstractions that shall be recorded per join
+	 * point. In other words, enabling this option disables the recording of
+	 * neighbors beyond the given count.
+	 * 
+	 * @param maxJoinPointAbstractions The maximum number of abstractions per join
+	 *                                 point, or -1 to record an arbitrary number of
+	 *                                 join point abstractions
+	 */
+	public void setMaxJoinPointAbstractions(int maxJoinPointAbstractions) {
+		this.maxJoinPointAbstractions = maxJoinPointAbstractions;
+	}
+
+	/**
+	 * Sets the memory manager that shall be used to manage the abstractions
+	 * 
+	 * @param memoryManager The memory manager that shall be used to manage the
+	 *                      abstractions
+	 */
+	public void setMemoryManager(IMemoryManager<D, N> memoryManager) {
+		this.memoryManager = memoryManager;
+	}
+
+	/**
+	 * Gets the memory manager used by this solver to reduce memory consumption
+	 * 
+	 * @return The memory manager registered with this solver
+	 */
+	public IMemoryManager<D, N> getMemoryManager() {
+		return this.memoryManager;
+	}
+
+	@Override
+	public void forceTerminate(ISolverTerminationReason reason) {
+		this.killFlag = reason;
+		this.executor.interrupt();
+		this.executor.shutdown();
+	}
+
+	@Override
+	public boolean isTerminated() {
+		return killFlag != null || this.executor.isFinished();
+	}
+
+	@Override
+	public boolean isKilled() {
+		return killFlag != null;
+	}
+
+	@Override
+	public void reset() {
+		this.killFlag = null;
+	}
+
+	@Override
+	public void addStatusListener(IMemoryBoundedSolverStatusNotification listener) {
+		this.notificationListeners.add(listener);
+	}
+
+	@Override
+	public ISolverTerminationReason getTerminationReason() {
+		return killFlag;
+	}
+
+	public void setMaxCalleesPerCallSite(int maxCalleesPerCallSite) {
+		this.maxCalleesPerCallSite = maxCalleesPerCallSite;
+	}
+
+	public void setMaxAbstractionPathLength(int maxAbstractionPathLength) {
+		this.maxAbstractionPathLength = maxAbstractionPathLength;
+	}
+
+	/**
+	 * Sets the peer group in which this solver operates. Peer groups allow for
+	 * synchronization between solvers
+	 * 
+	 * @param solverPeerGroup The solver peer group
+	 */
+	public void setPeerGroup(SolverPeerGroup solverPeerGroup) {
+		this.solverPeerGroup = solverPeerGroup;
+	}
+
+	/**
+	 * Notifies the solver that no further edges will be scheduled
+	 */
+	public void terminate() {
+		if (garbageCollector != null)
+			garbageCollector.notifySolverTerminated();
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IGCReferenceProvider.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IGCReferenceProvider.java
new file mode 100644
index 0000000..c46a3d5
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IGCReferenceProvider.java
@@ -0,0 +1,28 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import java.util.Set;
+
+import soot.SootMethod;
+import soot.jimple.infoflow.solver.fastSolver.FastSolverLinkedNode;
+
+/**
+ * Interface for all implementations that can provide reference counting. These
+ * classes answer the following question: Given a method X, in which methods can
+ * the solver transitively spawn new analysis tasks starting from X?
+ * 
+ * @author Steven Arzt
+ *
+ */
+public interface IGCReferenceProvider<D, N> {
+
+	/**
+	 * Given a method and a context, gets the set of methods that in which the
+	 * solver can transitively spawn new analysis tasks
+	 * 
+	 * @param method
+	 * @param context
+	 * @return
+	 */
+	public Set<SootMethod> getMethodReferences(SootMethod method, FastSolverLinkedNode<D, N> context);
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IGarbageCollector.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IGarbageCollector.java
new file mode 100644
index 0000000..1e1dc74
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IGarbageCollector.java
@@ -0,0 +1,57 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import heros.solver.PathEdge;
+
+/**
+ * Common interface for all garbage collector implementations oin the solver
+ * 
+ * @author Steven Arzt
+ *
+ */
+public interface IGarbageCollector<N, D> {
+
+	/**
+	 * Notifies the garbage collector that a new edge has been scheduled for
+	 * processing
+	 * 
+	 * @param edge The edge that has been scheduled
+	 */
+	public void notifyEdgeSchedule(PathEdge<N, D> edge);
+
+	/**
+	 * Notifies the garbage collector that an edge has been fully processed
+	 * 
+	 * @param edge The edge has been fully processed
+	 */
+	public void notifyTaskProcessed(PathEdge<N, D> edge);
+
+	/**
+	 * Performs the garbage collection
+	 */
+	public void gc();
+
+	/**
+	 * Gets the number of methods for which taint abstractions were removed during
+	 * garbage collection
+	 * 
+	 * @return The number of methods for which taint abstractions were removed
+	 *         during garbage collection
+	 */
+	public int getGcedMethods();
+
+	/**
+	 * Gets the number of taint abstractions that were removed during garbage
+	 * collection
+	 * 
+	 * @return The number of taint abstractions that were removed during garbage
+	 *         collection
+	 */
+	public int getGcedEdges();
+
+	/**
+	 * Notifies the garbage collector that the IFDS solver has finished propagating
+	 * its edges
+	 */
+	public void notifySolverTerminated();
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IGarbageCollectorPeer.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IGarbageCollectorPeer.java
new file mode 100644
index 0000000..be0f0ce
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/IGarbageCollectorPeer.java
@@ -0,0 +1,24 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import soot.SootMethod;
+
+/**
+ * A garbage collector that can operate as part of a peer group
+ * 
+ * @author Steven Arzt
+ *
+ */
+public interface IGarbageCollectorPeer {
+
+	/**
+	 * Checks whether the given method has any open dependencies in any of the
+	 * solvers that are members of this peer group that prevent its jump functions
+	 * from being garbage collected
+	 * 
+	 * @param method The method to check
+	 * @return True it the method has active dependencies and thus cannot be
+	 *         garbage-collected, false otherwise
+	 */
+	public boolean hasActiveDependencies(SootMethod method);
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/InfoflowSolver.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/InfoflowSolver.java
new file mode 100644
index 0000000..e7ba3a8
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/InfoflowSolver.java
@@ -0,0 +1,166 @@
+/*******************************************************************************
+ * Copyright (c) 2012 Secure Software Engineering Group at EC SPRIDE.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the GNU Lesser Public License v2.1
+ * which accompanies this distribution, and is available at
+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ * 
+ * Contributors: Christian Fritz, Steven Arzt, Siegfried Rasthofer, Eric
+ * Bodden, and others.
+ ******************************************************************************/
+package soot.jimple.infoflow.solver.gcSolver;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+
+import heros.FlowFunction;
+import heros.solver.Pair;
+import heros.solver.PathEdge;
+import soot.SootMethod;
+import soot.Unit;
+import soot.jimple.infoflow.data.Abstraction;
+import soot.jimple.infoflow.problems.AbstractInfoflowProblem;
+import soot.jimple.infoflow.solver.IFollowReturnsPastSeedsHandler;
+import soot.jimple.infoflow.solver.IInfoflowSolver;
+import soot.jimple.infoflow.solver.executors.InterruptableExecutor;
+import soot.jimple.infoflow.solver.functions.SolverCallFlowFunction;
+import soot.jimple.infoflow.solver.functions.SolverCallToReturnFlowFunction;
+import soot.jimple.infoflow.solver.functions.SolverNormalFlowFunction;
+import soot.jimple.infoflow.solver.functions.SolverReturnFlowFunction;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+import soot.util.ConcurrentHashMultiMap;
+
+/**
+ * We are subclassing the JimpleIFDSSolver because we need the same executor for
+ * both the forward and the backward analysis Also we need to be able to insert
+ * edges containing new taint information
+ * 
+ */
+public class InfoflowSolver extends IFDSSolver<Unit, Abstraction, BiDiInterproceduralCFG<Unit, SootMethod>>
+		implements IInfoflowSolver {
+
+	private IFollowReturnsPastSeedsHandler followReturnsPastSeedsHandler = null;
+	private final AbstractInfoflowProblem problem;
+
+	public InfoflowSolver(AbstractInfoflowProblem problem, InterruptableExecutor executor) {
+		super(problem);
+		this.problem = problem;
+		this.executor = executor;
+		problem.setSolver(this);
+	}
+
+	@Override
+	protected InterruptableExecutor getExecutor() {
+		return executor;
+	}
+
+	@Override
+	public boolean processEdge(PathEdge<Unit, Abstraction> edge) {
+		// We might not have a garbage collector yet
+		if (this.garbageCollector == null) {
+			synchronized (this) {
+				if (this.garbageCollector == null)
+					this.garbageCollector = createGarbageCollector();
+			}
+		}
+
+		propagate(edge.factAtSource(), edge.getTarget(), edge.factAtTarget(), null, false);
+		return true;
+	}
+
+	@Override
+	public void injectContext(IInfoflowSolver otherSolver, SootMethod callee, Abstraction d3, Unit callSite,
+			Abstraction d2, Abstraction d1) {
+		if (!addIncoming(callee, d3, callSite, d1, d2))
+			return;
+
+		Collection<Unit> returnSiteNs = icfg.getReturnSitesOfCallAt(callSite);
+		applyEndSummaryOnCall(d1, callSite, d2, returnSiteNs, callee, d3);
+	}
+
+	@Override
+	protected Set<Abstraction> computeReturnFlowFunction(FlowFunction<Abstraction> retFunction, Abstraction d1,
+			Abstraction d2, Unit callSite, Collection<Abstraction> callerSideDs) {
+		if (retFunction instanceof SolverReturnFlowFunction) {
+			// Get the d1s at the start points of the caller
+			return ((SolverReturnFlowFunction) retFunction).computeTargets(d2, d1, callerSideDs);
+		} else
+			return retFunction.computeTargets(d2);
+	}
+
+	@Override
+	protected Set<Abstraction> computeNormalFlowFunction(FlowFunction<Abstraction> flowFunction, Abstraction d1,
+			Abstraction d2) {
+		if (flowFunction instanceof SolverNormalFlowFunction)
+			return ((SolverNormalFlowFunction) flowFunction).computeTargets(d1, d2);
+		else
+			return flowFunction.computeTargets(d2);
+	}
+
+	@Override
+	protected Set<Abstraction> computeCallToReturnFlowFunction(FlowFunction<Abstraction> flowFunction, Abstraction d1,
+			Abstraction d2) {
+		if (flowFunction instanceof SolverCallToReturnFlowFunction)
+			return ((SolverCallToReturnFlowFunction) flowFunction).computeTargets(d1, d2);
+		else
+			return flowFunction.computeTargets(d2);
+	}
+
+	@Override
+	protected Set<Abstraction> computeCallFlowFunction(FlowFunction<Abstraction> flowFunction, Abstraction d1,
+			Abstraction d2) {
+		if (flowFunction instanceof SolverCallFlowFunction)
+			return ((SolverCallFlowFunction) flowFunction).computeTargets(d1, d2);
+		else
+			return flowFunction.computeTargets(d2);
+	}
+
+	@Override
+	public void cleanup() {
+		this.jumpFunctions = new ConcurrentHashMultiMap<>();
+		this.incoming.clear();
+		this.endSummary.clear();
+		if (this.ffCache != null)
+			this.ffCache.invalidate();
+	}
+
+	@Override
+	public Set<Pair<Unit, Abstraction>> endSummary(SootMethod m, Abstraction d3) {
+		Map<Pair<Unit, Abstraction>, Abstraction> map = super.endSummaryMap(m, d3);
+		return map == null ? null : map.keySet();
+	}
+
+	@Override
+	protected void processExit(PathEdge<Unit, Abstraction> edge) {
+		super.processExit(edge);
+
+		if (followReturnsPastSeeds && followReturnsPastSeedsHandler != null) {
+			final Abstraction d1 = edge.factAtSource();
+			final Unit u = edge.getTarget();
+			final Abstraction d2 = edge.factAtTarget();
+
+			final SootMethod methodThatNeedsSummary = icfg.getMethodOf(u);
+			final Set<IncomingRecord<Unit, Abstraction>> inc = incoming(d1, methodThatNeedsSummary);
+
+			if (inc == null || inc.isEmpty())
+				followReturnsPastSeedsHandler.handleFollowReturnsPastSeeds(d1, u, d2);
+		}
+	}
+
+	@Override
+	public void setFollowReturnsPastSeedsHandler(IFollowReturnsPastSeedsHandler handler) {
+		this.followReturnsPastSeedsHandler = handler;
+	}
+
+	@Override
+	public long getPropagationCount() {
+		return propagationCount;
+	}
+
+	@Override
+	public AbstractInfoflowProblem getTabulationProblem() {
+		return problem;
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/NullGarbageCollector.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/NullGarbageCollector.java
new file mode 100644
index 0000000..2320891
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/NullGarbageCollector.java
@@ -0,0 +1,42 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import heros.solver.PathEdge;
+
+/**
+ * Mock implementation for a garbage collector that does nothing
+ * 
+ * @author Steven Arzt
+ *
+ */
+public class NullGarbageCollector<N, D> implements IGarbageCollector<N, D> {
+
+	@Override
+	public void notifyEdgeSchedule(PathEdge<N, D> edge) {
+		// do nothing
+	}
+
+	@Override
+	public void notifyTaskProcessed(PathEdge<N, D> edge) {
+		// do nothing
+	}
+
+	@Override
+	public void gc() {
+		// do nothing
+	}
+
+	@Override
+	public int getGcedMethods() {
+		return 0;
+	}
+
+	@Override
+	public int getGcedEdges() {
+		return 0;
+	}
+
+	@Override
+	public void notifySolverTerminated() {
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/OnDemandReferenceProvider.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/OnDemandReferenceProvider.java
new file mode 100644
index 0000000..6fe1092
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/OnDemandReferenceProvider.java
@@ -0,0 +1,45 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import java.util.Set;
+
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+
+import heros.SynchronizedBy;
+import heros.solver.IDESolver;
+import soot.SootMethod;
+import soot.jimple.infoflow.solver.fastSolver.FastSolverLinkedNode;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+
+/**
+ * Implementation of a reference provider that computes transitive dependency
+ * sets on demand
+ * 
+ * @author Steven Arzt
+ *
+ * @param <D>
+ * @param <N>
+ */
+public class OnDemandReferenceProvider<D, N> extends AbstractReferenceProvider<D, N> {
+
+	@SynchronizedBy("by use of synchronized LoadingCache class")
+	protected final LoadingCache<SootMethod, Set<SootMethod>> methodToReferences = IDESolver.DEFAULT_CACHE_BUILDER
+			.build(new CacheLoader<SootMethod, Set<SootMethod>>() {
+
+				@Override
+				public Set<SootMethod> load(SootMethod key) throws Exception {
+					return getTransitiveCallees(key);
+				}
+
+			});
+
+	public OnDemandReferenceProvider(BiDiInterproceduralCFG<N, SootMethod> icfg) {
+		super(icfg);
+	}
+
+	@Override
+	public Set<SootMethod> getMethodReferences(SootMethod method, FastSolverLinkedNode<D, N> context) {
+		return methodToReferences.getUnchecked(method);
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/ThreadedGarbageCollector.java b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/ThreadedGarbageCollector.java
new file mode 100644
index 0000000..1bbb388
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/solver/gcSolver/ThreadedGarbageCollector.java
@@ -0,0 +1,94 @@
+package soot.jimple.infoflow.solver.gcSolver;
+
+import heros.solver.PathEdge;
+import soot.SootMethod;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+import soot.util.ConcurrentHashMultiMap;
+
+/**
+ * Garbage collector that performs its tasks in a separate thread
+ * 
+ * @author Steven Arzt
+ *
+ * @param <N>
+ * @param <D>
+ */
+public class ThreadedGarbageCollector<N, D> extends AbstractReferenceCountingGarbageCollector<N, D> {
+
+	private class GCThread extends Thread {
+
+		private boolean finished = false;
+
+		public GCThread() {
+			setName("IFDS Garbage Collector");
+		}
+
+		@Override
+		public void run() {
+			while (!finished) {
+				gcImmediate();
+
+				if (sleepTimeSeconds > 0) {
+					try {
+						Thread.sleep(sleepTimeSeconds * 1000);
+					} catch (InterruptedException e) {
+						break;
+					}
+				}
+			}
+		}
+
+		/**
+		 * Notifies the thread to finish its current garbage collection and then
+		 * terminate
+		 */
+		public void finish() {
+			finished = true;
+			interrupt();
+		}
+
+	}
+
+	private int sleepTimeSeconds = 10;
+	private GCThread gcThread;
+
+	public ThreadedGarbageCollector(BiDiInterproceduralCFG<N, SootMethod> icfg,
+			ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions,
+			IGCReferenceProvider<D, N> referenceProvider) {
+		super(icfg, jumpFunctions, referenceProvider);
+	}
+
+	public ThreadedGarbageCollector(BiDiInterproceduralCFG<N, SootMethod> icfg,
+			ConcurrentHashMultiMap<SootMethod, PathEdge<N, D>> jumpFunctions) {
+		super(icfg, jumpFunctions);
+	}
+
+	@Override
+	protected void initialize() {
+		super.initialize();
+
+		// Start the garbage collection thread
+		gcThread = new GCThread();
+		gcThread.start();
+	}
+
+	@Override
+	public void gc() {
+		// nothing to do here
+	}
+
+	@Override
+	public void notifySolverTerminated() {
+		gcThread.finish();
+	}
+
+	/**
+	 * Sets the time to wait between garbage collection cycles in seconds
+	 * 
+	 * @param sleepTimeSeconds The time to wait between GC cycles in seconds
+	 */
+	public void setSleepTimeSeconds(int sleepTimeSeconds) {
+		this.sleepTimeSeconds = sleepTimeSeconds;
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/AbstractSourceSinkDefinition.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/AbstractSourceSinkDefinition.java
new file mode 100644
index 0000000..2abebf0
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/AbstractSourceSinkDefinition.java
@@ -0,0 +1,49 @@
+package soot.jimple.infoflow.sourcesSinks.definitions;
+
+/**
+ * A class to handle all access paths of sources and sinks for a certain method.
+ * 
+ * @author Daniel Magin
+ * @author Steven Arzt
+ *
+ */
+public abstract class AbstractSourceSinkDefinition implements ISourceSinkDefinition {
+
+	protected ISourceSinkCategory category;
+
+	@Override
+	public void setCategory(ISourceSinkCategory category) {
+		this.category = category;
+	}
+
+	@Override
+	public ISourceSinkCategory getCategory() {
+		return category;
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((category == null) ? 0 : category.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		AbstractSourceSinkDefinition other = (AbstractSourceSinkDefinition) obj;
+		if (category == null) {
+			if (other.category != null)
+				return false;
+		} else if (!category.equals(other.category))
+			return false;
+		return true;
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/AccessPathTuple.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/AccessPathTuple.java
index 1f0b806..dd3b44c 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/AccessPathTuple.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/AccessPathTuple.java
@@ -281,7 +281,8 @@ public class AccessPathTuple {
 					sb.append(".");
 				sb.append(fields[i]);
 			}
-		}
+		} else
+			sb.append("<empty>");
 
 		if (description != null && !description.isEmpty()) {
 			sb.append(" (");
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/FieldSourceSinkDefinition.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/FieldSourceSinkDefinition.java
index 5137983..077120b 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/FieldSourceSinkDefinition.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/FieldSourceSinkDefinition.java
@@ -1,5 +1,6 @@
 package soot.jimple.infoflow.sourcesSinks.definitions;
 
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -9,7 +10,8 @@ import java.util.Set;
  * @author Steven Arzt
  *
  */
-public class FieldSourceSinkDefinition extends SourceSinkDefinition {
+public class FieldSourceSinkDefinition extends AbstractSourceSinkDefinition
+		implements IAccessPathBasedSourceSinkDefinition {
 
 	protected final String fieldSignature;
 	protected Set<AccessPathTuple> accessPaths;
@@ -17,8 +19,7 @@ public class FieldSourceSinkDefinition extends SourceSinkDefinition {
 	/**
 	 * Creates a new instance of the {@link FieldSourceSinkDefinition} class
 	 * 
-	 * @param fieldSignature
-	 *            The Soot signature of the target field
+	 * @param fieldSignature The Soot signature of the target field
 	 */
 	public FieldSourceSinkDefinition(String fieldSignature) {
 		this(fieldSignature, null);
@@ -27,11 +28,9 @@ public class FieldSourceSinkDefinition extends SourceSinkDefinition {
 	/**
 	 * Creates a new instance of the {@link FieldSourceSinkDefinition} class
 	 * 
-	 * @param fieldSignature
-	 *            The Soot signature of the target field
-	 * @param accessPaths
-	 *            The access paths on the field that have been defined as sources or
-	 *            sinks
+	 * @param fieldSignature The Soot signature of the target field
+	 * @param accessPaths    The access paths on the field that have been defined as
+	 *                       sources or sinks
 	 */
 	public FieldSourceSinkDefinition(String fieldSignature, Set<AccessPathTuple> accessPaths) {
 		this.fieldSignature = fieldSignature;
@@ -58,7 +57,7 @@ public class FieldSourceSinkDefinition extends SourceSinkDefinition {
 	}
 
 	@Override
-	public SourceSinkDefinition getSourceOnlyDefinition() {
+	public FieldSourceSinkDefinition getSourceOnlyDefinition() {
 		Set<AccessPathTuple> sources = null;
 		if (accessPaths != null) {
 			sources = new HashSet<>(accessPaths.size());
@@ -70,7 +69,7 @@ public class FieldSourceSinkDefinition extends SourceSinkDefinition {
 	}
 
 	@Override
-	public SourceSinkDefinition getSinkOnlyDefinition() {
+	public FieldSourceSinkDefinition getSinkOnlyDefinition() {
 		Set<AccessPathTuple> sinks = null;
 		if (accessPaths != null) {
 			sinks = new HashSet<>(accessPaths.size());
@@ -87,16 +86,29 @@ public class FieldSourceSinkDefinition extends SourceSinkDefinition {
 	 * definition. Derived classes can override this method to create instances of
 	 * the correct class.
 	 * 
-	 * @param accessPaths
-	 *            The of access paths for the new definition
+	 * @param accessPaths The of access paths for the new definition
 	 * @return The new source/sink definition
 	 */
-	protected SourceSinkDefinition buildNewDefinition(Set<AccessPathTuple> accessPaths) {
+	protected FieldSourceSinkDefinition buildNewDefinition(Set<AccessPathTuple> accessPaths) {
+		return buildNewDefinition(fieldSignature, accessPaths);
+	}
+
+	/**
+	 * Factory method for creating a new field-based source/sink definition based on
+	 * the current one. This method is used when transforming the current
+	 * definition. Derived classes can override this method to create instances of
+	 * the correct class.
+	 * 
+	 * @param fieldSignature The field signature
+	 * @param accessPaths    The of access paths for the new definition
+	 * @return The new source/sink definition
+	 */
+	protected FieldSourceSinkDefinition buildNewDefinition(String fieldSignature, Set<AccessPathTuple> accessPaths) {
 		return new FieldSourceSinkDefinition(fieldSignature, accessPaths);
 	}
 
 	@Override
-	public void merge(SourceSinkDefinition other) {
+	public void merge(ISourceSinkDefinition other) {
 		if (other instanceof FieldSourceSinkDefinition) {
 			FieldSourceSinkDefinition otherField = (FieldSourceSinkDefinition) other;
 
@@ -115,6 +127,26 @@ public class FieldSourceSinkDefinition extends SourceSinkDefinition {
 		return accessPaths == null || accessPaths.isEmpty();
 	}
 
+	@Override
+	public Set<AccessPathTuple> getAllAccessPaths() {
+		return accessPaths;
+	}
+
+	@Override
+	public IAccessPathBasedSourceSinkDefinition filter(Collection<AccessPathTuple> toFilter) {
+		// Filter the access paths
+		Set<AccessPathTuple> filteredAPs = null;
+		if (accessPaths != null && !accessPaths.isEmpty()) {
+			filteredAPs = new HashSet<>(accessPaths.size());
+			for (AccessPathTuple ap : accessPaths)
+				if (toFilter.contains(ap))
+					filteredAPs.add(ap);
+		}
+		FieldSourceSinkDefinition def = buildNewDefinition(fieldSignature, filteredAPs);
+		def.setCategory(category);
+		return def;
+	}
+
 	@Override
 	public int hashCode() {
 		final int prime = 31;
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/FilteringSourceSinkDefinitionProvider.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/FilteringSourceSinkDefinitionProvider.java
index 126c718..49a5c8d 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/FilteringSourceSinkDefinitionProvider.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/FilteringSourceSinkDefinitionProvider.java
@@ -24,12 +24,11 @@ public class FilteringSourceSinkDefinitionProvider implements ISourceSinkDefinit
 		/**
 		 * Checks whether the filter accepts the given source/sink definition
 		 * 
-		 * @param def
-		 *            The source/sink definition to check
-		 * @return True if the filter accepts the given source/sink definition,
-		 *         false otherwise
+		 * @param def The source/sink definition to check
+		 * @return True if the filter accepts the given source/sink definition, false
+		 *         otherwise
 		 */
-		public boolean accepts(SourceSinkDefinition def);
+		public boolean accepts(ISourceSinkDefinition def);
 
 	}
 
@@ -37,14 +36,13 @@ public class FilteringSourceSinkDefinitionProvider implements ISourceSinkDefinit
 	private final ISourceSinkFilter filter;
 
 	/**
-	 * Creates a new instance of the
-	 * {@link FilteringSourceSinkDefinitionProvider} class
+	 * Creates a new instance of the {@link FilteringSourceSinkDefinitionProvider}
+	 * class
 	 * 
-	 * @param innerProvider
-	 *            The inner provider that creates the source/sink definitions
-	 *            which are then filtered by this provider
-	 * @param filter
-	 *            The filter that defines which sources and sinks to include
+	 * @param innerProvider The inner provider that creates the source/sink
+	 *                      definitions which are then filtered by this provider
+	 * @param filter        The filter that defines which sources and sinks to
+	 *                      include
 	 */
 	public FilteringSourceSinkDefinitionProvider(ISourceSinkDefinitionProvider innerProvider,
 			ISourceSinkFilter filter) {
@@ -55,13 +53,12 @@ public class FilteringSourceSinkDefinitionProvider implements ISourceSinkDefinit
 	/**
 	 * Filters the given set of source/sink definitions
 	 * 
-	 * @param input
-	 *            The input set
+	 * @param input The input set
 	 * @return The filtered set of source/sink definitions
 	 */
-	private Set<SourceSinkDefinition> filter(Set<SourceSinkDefinition> input) {
-		Set<SourceSinkDefinition> filtered = new HashSet<>(input.size());
-		for (SourceSinkDefinition def : input)
+	private Set<ISourceSinkDefinition> filter(Set<? extends ISourceSinkDefinition> input) {
+		Set<ISourceSinkDefinition> filtered = new HashSet<>(input.size());
+		for (ISourceSinkDefinition def : input)
 			if (filter.accepts(def))
 				filtered.add(def);
 		return filtered;
@@ -69,17 +66,17 @@ public class FilteringSourceSinkDefinitionProvider implements ISourceSinkDefinit
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSources() {
+	public Set<ISourceSinkDefinition> getSources() {
 		return filter(this.innerProvider.getSources());
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSinks() {
+	public Set<ISourceSinkDefinition> getSinks() {
 		return filter(this.innerProvider.getSinks());
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getAllMethods() {
+	public Set<ISourceSinkDefinition> getAllMethods() {
 		return filter(this.innerProvider.getAllMethods());
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/IAccessPathBasedSourceSinkDefinition.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/IAccessPathBasedSourceSinkDefinition.java
new file mode 100644
index 0000000..1f70e9a
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/IAccessPathBasedSourceSinkDefinition.java
@@ -0,0 +1,59 @@
+package soot.jimple.infoflow.sourcesSinks.definitions;
+
+import java.util.Collection;
+import java.util.Set;
+
+/**
+ * Common interface for all source/sink definitions based on access paths
+ * 
+ * @author Steven Arzt
+ *
+ */
+public interface IAccessPathBasedSourceSinkDefinition extends ISourceSinkDefinition {
+
+	/**
+	 * Gets all access paths referenced in this source or sink definition,
+	 * regardless of their respective semantics
+	 * 
+	 * @return All access paths referenced in this source or sink definition. The
+	 *         return value can be null if this definition does not reference any
+	 *         access paths.
+	 */
+	public Set<AccessPathTuple> getAllAccessPaths();
+
+	/**
+	 * Filters the source/sink definition to only reference the given access paths
+	 * 
+	 * @param accessPaths The access path to which to limit the scope of this
+	 *                    source/sink definition
+	 * @return A copy of this source/sink definition that only references the given
+	 *         access paths
+	 */
+	public IAccessPathBasedSourceSinkDefinition filter(Collection<AccessPathTuple> accessPaths);
+
+	/**
+	 * Checks whether this source/sink definition is empty, i.e., has no concrete
+	 * access paths
+	 * 
+	 * @return True if this source/sink definition is empty, i.e., has no concrete
+	 *         access paths, otherwise false
+	 */
+	public abstract boolean isEmpty();
+
+	/**
+	 * Creates a definition which is a subset of this definition that only contains
+	 * the sources
+	 * 
+	 * @return The source-only subset of this definition
+	 */
+	public abstract IAccessPathBasedSourceSinkDefinition getSourceOnlyDefinition();
+
+	/**
+	 * Creates a definition which is a subset of this definition that only contains
+	 * the sinks
+	 * 
+	 * @return The sink-only subset of this definition
+	 */
+	public abstract IAccessPathBasedSourceSinkDefinition getSinkOnlyDefinition();
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/ISourceSinkDefinition.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/ISourceSinkDefinition.java
new file mode 100644
index 0000000..6af5020
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/ISourceSinkDefinition.java
@@ -0,0 +1,49 @@
+package soot.jimple.infoflow.sourcesSinks.definitions;
+
+/**
+ * Abstract interface for soure/sink definitions
+ * 
+ * @author Steven Arzt
+ *
+ */
+public interface ISourceSinkDefinition {
+
+	/**
+	 * Sets the category to which this source or sink belonga
+	 * 
+	 * @param category The category to which this source or sink belonga
+	 */
+	public void setCategory(ISourceSinkCategory category);
+
+	/**
+	 * Gets the category to which this source or sink belonga
+	 * 
+	 * @return The category to which this source or sink belonga
+	 */
+	public ISourceSinkCategory getCategory();
+
+	/**
+	 * Creates a definition which is a subset of this definition that only contains
+	 * the sources
+	 * 
+	 * @return The source-only subset of this definition
+	 */
+	public abstract ISourceSinkDefinition getSourceOnlyDefinition();
+
+	/**
+	 * Creates a definition which is a subset of this definition that only contains
+	 * the sinks
+	 * 
+	 * @return The sink-only subset of this definition
+	 */
+	public abstract ISourceSinkDefinition getSinkOnlyDefinition();
+
+	/**
+	 * Merges the source and sink definitions of the given definition object into
+	 * this definition object
+	 * 
+	 * @param other The definition object to merge
+	 */
+	public abstract void merge(ISourceSinkDefinition other);
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/ISourceSinkDefinitionProvider.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/ISourceSinkDefinitionProvider.java
index 608e3cb..46ebac8 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/ISourceSinkDefinitionProvider.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/ISourceSinkDefinitionProvider.java
@@ -10,24 +10,28 @@ import java.util.Set;
  *
  */
 public interface ISourceSinkDefinitionProvider {
-	
+
 	/**
 	 * Gets a set of all sources registered in the provider
+	 * 
 	 * @return A set of all sources registered in the provider
 	 */
-	public Set<SourceSinkDefinition> getSources();
-	
+	public Set<? extends ISourceSinkDefinition> getSources();
+
 	/**
 	 * Gets a set of all sinks registered in the provider
+	 * 
 	 * @return A set of all sinks registered in the provider
 	 */
-	public Set<SourceSinkDefinition> getSinks();
-	
+	public Set<? extends ISourceSinkDefinition> getSinks();
+
 	/**
 	 * Gets all methods for which there are source/sink definitions
+	 * 
 	 * @return A set containing all methods for which there is a source/sink
-	 * definition. This also includes methods explicitly labeled as "neither".
+	 *         definition. This also includes methods explicitly labeled as
+	 *         "neither".
 	 */
-	public Set<SourceSinkDefinition> getAllMethods();
-	
+	public Set<? extends ISourceSinkDefinition> getAllMethods();
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/MethodSourceSinkDefinition.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/MethodSourceSinkDefinition.java
index 732f918..da3a099 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/MethodSourceSinkDefinition.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/MethodSourceSinkDefinition.java
@@ -1,6 +1,7 @@
 package soot.jimple.infoflow.sourcesSinks.definitions;
 
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
@@ -14,7 +15,8 @@ import soot.jimple.infoflow.data.SootMethodAndClass;
  * @author Steven Arzt
  *
  */
-public class MethodSourceSinkDefinition extends SourceSinkDefinition {
+public class MethodSourceSinkDefinition extends AbstractSourceSinkDefinition
+		implements IAccessPathBasedSourceSinkDefinition {
 
 	private static MethodSourceSinkDefinition BASE_OBJ_SOURCE;
 	private static MethodSourceSinkDefinition BASE_OBJ_SINK;
@@ -51,10 +53,10 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 	}
 
 	/**
-	 * Creates a new instance of the {@link SourceSinkDefinition} class without a
-	 * method. This constructor is intended to be used for sources that arise from
-	 * UI elements or other programming constructs that are not directly associated
-	 * with a single method being called.
+	 * Creates a new instance of the {@link MethodSourceSinkDefinition} class
+	 * without a method. This constructor is intended to be used for sources that
+	 * arise from UI elements or other programming constructs that are not directly
+	 * associated with a single method being called.
 	 */
 	public MethodSourceSinkDefinition(Set<AccessPathTuple> baseObjects, Set<AccessPathTuple>[] parameters,
 			Set<AccessPathTuple> returnValues, CallType callType) {
@@ -62,7 +64,7 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 	}
 
 	/**
-	 * Creates a new instance of the {@link SourceSinkDefinition} class
+	 * Creates a new instance of the {@link MethodSourceSinkDefinition} class
 	 */
 	public MethodSourceSinkDefinition(SootMethodAndClass am) {
 		this(am, null, null, null, CallType.MethodCall);
@@ -71,18 +73,15 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 	/**
 	 * Creates a new instance of the MethodSourceSinkDefinition class
 	 * 
-	 * @param am
-	 *            The method for which this object defines sources and sinks
-	 * @param baseObjects
-	 *            The source and sink definitions for the base object on which a
-	 *            method of this class is invoked
-	 * @param parameters
-	 *            The source and sink definitions for parameters of the current
-	 *            method
-	 * @param callType
-	 *            The type of calls to define as sources or sinks
-	 * @param returnValues
-	 *            The source definitions for the return value of the current method
+	 * @param am           The method for which this object defines sources and
+	 *                     sinks
+	 * @param baseObjects  The source and sink definitions for the base object on
+	 *                     which a method of this class is invoked
+	 * @param parameters   The source and sink definitions for parameters of the
+	 *                     current method
+	 * @param callType     The type of calls to define as sources or sinks
+	 * @param returnValues The source definitions for the return value of the
+	 *                     current method
 	 */
 	public MethodSourceSinkDefinition(SootMethodAndClass am, Set<AccessPathTuple> baseObjects,
 			Set<AccessPathTuple>[] parameters, Set<AccessPathTuple> returnValues, CallType callType) {
@@ -195,7 +194,7 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 	}
 
 	@Override
-	public SourceSinkDefinition getSourceOnlyDefinition() {
+	public MethodSourceSinkDefinition getSourceOnlyDefinition() {
 		// Collect all base sources
 		Set<AccessPathTuple> baseSources = null;
 		if (baseObjects != null) {
@@ -231,7 +230,7 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 	}
 
 	@Override
-	public SourceSinkDefinition getSinkOnlyDefinition() {
+	public MethodSourceSinkDefinition getSinkOnlyDefinition() {
 		// Collect all base sinks
 		Set<AccessPathTuple> baseSinks = null;
 		if (baseObjects != null) {
@@ -272,25 +271,28 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 	 * definition. Derived classes can override this method to create instances of
 	 * the correct class.
 	 * 
-	 * @param baseAPTs
-	 *            The access paths rooted in the base object
-	 * @param paramAPTs
-	 *            The access paths rooted in the method's parameters
-	 * @param returnAPTs
-	 *            The access paths rooted in the return value
+	 * @param baseAPTs   The access paths rooted in the base object
+	 * @param paramAPTs  The access paths rooted in the method's parameters
+	 * @param returnAPTs The access paths rooted in the return value
 	 * @return The new source/sink definition object
 	 */
 	protected MethodSourceSinkDefinition buildNewDefinition(Set<AccessPathTuple> baseAPTs,
 			Set<AccessPathTuple>[] paramAPTs, Set<AccessPathTuple> returnAPTs) {
-		MethodSourceSinkDefinition def = new MethodSourceSinkDefinition(method, baseAPTs, paramAPTs, returnAPTs,
-				callType);
+		MethodSourceSinkDefinition def = buildNewDefinition(method, baseAPTs, paramAPTs, returnAPTs, callType);
 		def.setCategory(category);
 		return def;
 	}
 
+	protected MethodSourceSinkDefinition buildNewDefinition(SootMethodAndClass methodAndclass,
+			Set<AccessPathTuple> filteredBaseObjects, Set<AccessPathTuple>[] filteredParameters,
+			Set<AccessPathTuple> filteredReturnValues, CallType callType) {
+		return new MethodSourceSinkDefinition(methodAndclass, filteredBaseObjects, filteredParameters,
+				filteredReturnValues, callType);
+	}
+
 	@Override
 	@SuppressWarnings("unchecked")
-	public void merge(SourceSinkDefinition other) {
+	public void merge(ISourceSinkDefinition other) {
 		if (other instanceof MethodSourceSinkDefinition) {
 			MethodSourceSinkDefinition otherMethod = (MethodSourceSinkDefinition) other;
 
@@ -328,7 +330,7 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 	 * @return The shared blank source definition that is not associated with any
 	 *         method and taints the base object
 	 */
-	public static MethodSourceSinkDefinition getBaseObjectSource() {
+	public MethodSourceSinkDefinition getBaseObjectSource() {
 		if (BASE_OBJ_SOURCE == null)
 			BASE_OBJ_SOURCE = new MethodSourceSinkDefinition(
 					Collections.singleton(AccessPathTuple.getBlankSourceTuple()), null, null, CallType.MethodCall);
@@ -342,7 +344,7 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 	 * @return The shared blank sink definition that is not associated with any
 	 *         method and taints the base object
 	 */
-	public static MethodSourceSinkDefinition getBaseObjectSink() {
+	public MethodSourceSinkDefinition getBaseObjectSink() {
 		if (BASE_OBJ_SINK == null)
 			BASE_OBJ_SINK = new MethodSourceSinkDefinition(Collections.singleton(AccessPathTuple.getBlankSinkTuple()),
 					null, null, CallType.MethodCall);
@@ -401,10 +403,8 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 	/**
 	 * Creates a source definition that considers a parameter as tainted
 	 * 
-	 * @param index
-	 *            The index of the parameter to consider as tainted
-	 * @param callType
-	 *            The type of call
+	 * @param index    The index of the parameter to consider as tainted
+	 * @param callType The type of call
 	 * @return The newly created source definition
 	 */
 	@SuppressWarnings("unchecked")
@@ -428,11 +428,10 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 	/**
 	 * Creates a source definition that considers the return value as tainted
 	 * 
-	 * @param callType
-	 *            The type of call
+	 * @param callType The type of call
 	 * @return The newly created source definition
 	 */
-	public static SourceSinkDefinition createReturnSource(CallType callType) {
+	public static MethodSourceSinkDefinition createReturnSource(CallType callType) {
 		return new MethodSourceSinkDefinition(null, null, Collections.singleton(AccessPathTuple.getBlankSourceTuple()),
 				callType);
 	}
@@ -463,4 +462,61 @@ public class MethodSourceSinkDefinition extends SourceSinkDefinition {
 		}
 	}
 
+	@Override
+	public Set<AccessPathTuple> getAllAccessPaths() {
+		Set<AccessPathTuple> aps = new HashSet<>();
+		if (baseObjects != null && !baseObjects.isEmpty())
+			aps.addAll(baseObjects);
+		if (returnValues != null && !returnValues.isEmpty())
+			aps.addAll(returnValues);
+		if (parameters != null && parameters.length > 0) {
+			for (Set<AccessPathTuple> paramAPs : parameters) {
+				if (paramAPs != null && !paramAPs.isEmpty())
+					aps.addAll(paramAPs);
+			}
+		}
+		return aps;
+	}
+
+	@SuppressWarnings("unchecked")
+	@Override
+	public MethodSourceSinkDefinition filter(Collection<AccessPathTuple> accessPaths) {
+		// Filter the base objects
+		Set<AccessPathTuple> filteredBaseObjects = null;
+		if (baseObjects != null && !baseObjects.isEmpty()) {
+			filteredBaseObjects = new HashSet<>(baseObjects.size());
+			for (AccessPathTuple ap : baseObjects)
+				if (accessPaths.contains(ap))
+					filteredBaseObjects.add(ap);
+		}
+
+		// Filter the return values
+		Set<AccessPathTuple> filteredReturnValues = null;
+		if (returnValues != null && !returnValues.isEmpty()) {
+			filteredReturnValues = new HashSet<>(returnValues.size());
+			for (AccessPathTuple ap : returnValues)
+				if (accessPaths.contains(ap))
+					filteredReturnValues.add(ap);
+		}
+
+		// Filter the parameters
+		Set<AccessPathTuple>[] filteredParameters = null;
+		if (parameters != null && parameters.length > 0) {
+			filteredParameters = new Set[parameters.length];
+			for (int i = 0; i < parameters.length; i++) {
+				if (parameters[i] != null && !parameters[i].isEmpty()) {
+					filteredParameters[i] = new HashSet<>();
+					for (AccessPathTuple ap : parameters[i])
+						if (accessPaths.contains(ap))
+							filteredParameters[i].add(ap);
+				}
+			}
+		}
+
+		MethodSourceSinkDefinition def = buildNewDefinition(method, filteredBaseObjects, filteredParameters,
+				filteredReturnValues, callType);
+		def.setCategory(category);
+		return def;
+	}
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/NullSourceSinkDefinitionProvider.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/NullSourceSinkDefinitionProvider.java
index 84b09b3..ff032ab 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/NullSourceSinkDefinitionProvider.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/NullSourceSinkDefinitionProvider.java
@@ -9,21 +9,20 @@ import java.util.Set;
  * @author Steven Arzt
  *
  */
-public class NullSourceSinkDefinitionProvider implements
-		ISourceSinkDefinitionProvider {
+public class NullSourceSinkDefinitionProvider implements ISourceSinkDefinitionProvider {
 
 	@Override
-	public Set<SourceSinkDefinition> getSources() {
+	public Set<ISourceSinkDefinition> getSources() {
 		return Collections.emptySet();
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getSinks() {
+	public Set<ISourceSinkDefinition> getSinks() {
 		return Collections.emptySet();
 	}
 
 	@Override
-	public Set<SourceSinkDefinition> getAllMethods() {
+	public Set<ISourceSinkDefinition> getAllMethods() {
 		return Collections.emptySet();
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/SourceSinkDefinition.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/SourceSinkDefinition.java
deleted file mode 100644
index e315ae9..0000000
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/SourceSinkDefinition.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package soot.jimple.infoflow.sourcesSinks.definitions;
-
-/**
- * A class to handle all access paths of sources and sinks for a certain method.
- * 
- * @author Daniel Magin
- * @author Steven Arzt
- *
- */
-public abstract class SourceSinkDefinition {
-
-	protected ISourceSinkCategory category;
-
-	/**
-	 * Sets the category to which this source or sink belonga
-	 * 
-	 * @param category
-	 *            The category to which this source or sink belonga
-	 */
-	public void setCategory(ISourceSinkCategory category) {
-		this.category = category;
-	}
-
-	/**
-	 * Gets the category to which this source or sink belonga
-	 * 
-	 * @return The category to which this source or sink belonga
-	 */
-	public ISourceSinkCategory getCategory() {
-		return category;
-	}
-
-	/**
-	 * Creates a definition which is a subset of this definition that only contains
-	 * the sources
-	 * 
-	 * @return The source-only subset of this definition
-	 */
-	public abstract SourceSinkDefinition getSourceOnlyDefinition();
-
-	/**
-	 * Creates a definition which is a subset of this definition that only contains
-	 * the sinks
-	 * 
-	 * @return The sink-only subset of this definition
-	 */
-	public abstract SourceSinkDefinition getSinkOnlyDefinition();
-
-	/**
-	 * Merges the source and sink definitions of the given definition object into
-	 * this definition object
-	 * 
-	 * @param other
-	 *            The definition object to merge
-	 */
-	public abstract void merge(SourceSinkDefinition other);
-
-	/**
-	 * Checks whether this source/sink definition is empty, i.e., has no concrete
-	 * access paths
-	 * 
-	 * @return True if this source/sink definition is empty, i.e., has no concrete
-	 *         access paths, otherwise false
-	 */
-	public abstract boolean isEmpty();
-
-	@Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((category == null) ? 0 : category.hashCode());
-		return result;
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (getClass() != obj.getClass())
-			return false;
-		SourceSinkDefinition other = (SourceSinkDefinition) obj;
-		if (category == null) {
-			if (other.category != null)
-				return false;
-		} else if (!category.equals(other.category))
-			return false;
-		return true;
-	}
-
-}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/StatementSourceSinkDefinition.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/StatementSourceSinkDefinition.java
index 159d451..2144f19 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/StatementSourceSinkDefinition.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/definitions/StatementSourceSinkDefinition.java
@@ -1,5 +1,6 @@
 package soot.jimple.infoflow.sourcesSinks.definitions;
 
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -13,7 +14,8 @@ import soot.jimple.Stmt;
  * @author Steven Arzt
  *
  */
-public class StatementSourceSinkDefinition extends SourceSinkDefinition {
+public class StatementSourceSinkDefinition extends AbstractSourceSinkDefinition
+		implements IAccessPathBasedSourceSinkDefinition {
 
 	private final Stmt stmt;
 	private final Local local;
@@ -26,7 +28,7 @@ public class StatementSourceSinkDefinition extends SourceSinkDefinition {
 	}
 
 	@Override
-	public SourceSinkDefinition getSourceOnlyDefinition() {
+	public StatementSourceSinkDefinition getSourceOnlyDefinition() {
 		Set<AccessPathTuple> newSet = null;
 		if (accessPaths != null) {
 			newSet = new HashSet<>(accessPaths.size());
@@ -40,11 +42,11 @@ public class StatementSourceSinkDefinition extends SourceSinkDefinition {
 				}
 			}
 		}
-		return new StatementSourceSinkDefinition(stmt, local, newSet);
+		return buildNewDefinition(stmt, local, newSet);
 	}
 
 	@Override
-	public SourceSinkDefinition getSinkOnlyDefinition() {
+	public StatementSourceSinkDefinition getSinkOnlyDefinition() {
 		Set<AccessPathTuple> newSet = null;
 		if (accessPaths != null) {
 			newSet = new HashSet<>(accessPaths.size());
@@ -58,7 +60,7 @@ public class StatementSourceSinkDefinition extends SourceSinkDefinition {
 				}
 			}
 		}
-		return new StatementSourceSinkDefinition(stmt, local, newSet);
+		return buildNewDefinition(stmt, local, newSet);
 	}
 
 	public Stmt getStmt() {
@@ -74,7 +76,7 @@ public class StatementSourceSinkDefinition extends SourceSinkDefinition {
 	}
 
 	@Override
-	public void merge(SourceSinkDefinition other) {
+	public void merge(ISourceSinkDefinition other) {
 		if (other instanceof StatementSourceSinkDefinition) {
 			StatementSourceSinkDefinition otherStmt = (StatementSourceSinkDefinition) other;
 
@@ -98,6 +100,31 @@ public class StatementSourceSinkDefinition extends SourceSinkDefinition {
 		return String.format("Local %s at %s", local, stmt);
 	}
 
+	@Override
+	public Set<AccessPathTuple> getAllAccessPaths() {
+		return accessPaths;
+	}
+
+	@Override
+	public IAccessPathBasedSourceSinkDefinition filter(Collection<AccessPathTuple> toFilter) {
+		// Filter the access paths
+		Set<AccessPathTuple> filteredAPs = null;
+		if (accessPaths != null && !accessPaths.isEmpty()) {
+			filteredAPs = new HashSet<>(accessPaths.size());
+			for (AccessPathTuple ap : accessPaths)
+				if (toFilter.contains(ap))
+					filteredAPs.add(ap);
+		}
+		StatementSourceSinkDefinition def = buildNewDefinition(stmt, local, filteredAPs);
+		def.setCategory(category);
+		return def;
+	}
+
+	protected StatementSourceSinkDefinition buildNewDefinition(Stmt stmt, Local local,
+			Set<AccessPathTuple> accessPaths) {
+		return new StatementSourceSinkDefinition(stmt, local, accessPaths);
+	}
+
 	@Override
 	public int hashCode() {
 		final int prime = 31;
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/AbstractSourceSinkInfo.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/AbstractSourceSinkInfo.java
index d06b947..c055398 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/AbstractSourceSinkInfo.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/AbstractSourceSinkInfo.java
@@ -1,6 +1,6 @@
 package soot.jimple.infoflow.sourcesSinks.manager;
 
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 
 /**
  * Abstract base class for source/sink information
@@ -10,28 +10,26 @@ import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
  */
 abstract class AbstractSourceSinkInfo {
 
-	protected final SourceSinkDefinition definition;
+	protected final ISourceSinkDefinition definition;
 	protected final Object userData;
 
 	/**
-	 * Creates a new instance of the {@link AbstractSourceSinkInfo} class
+	 * Creates a new instance of the {@link ISourceSinkInfo} class
 	 * 
-	 * @param definition
-	 *            The original definition of the source or sink
+	 * @param definition The original definition of the source or sink
 	 */
-	public AbstractSourceSinkInfo(SourceSinkDefinition definition) {
+	public AbstractSourceSinkInfo(ISourceSinkDefinition definition) {
 		this(definition, null);
 	}
 
 	/**
-	 * Creates a new instance of the {@link AbstractSourceSinkInfo} class
+	 * Creates a new instance of the {@link ISourceSinkInfo} class
 	 * 
-	 * @param definition
-	 *            The original definition of the source or sink
-	 * @param userData
-	 *            Additional user data to be propagated with the source or sink
+	 * @param definition The original definition of the source or sink
+	 * @param userData   Additional user data to be propagated with the source or
+	 *                   sink
 	 */
-	public AbstractSourceSinkInfo(SourceSinkDefinition definition, Object userData) {
+	public AbstractSourceSinkInfo(ISourceSinkDefinition definition, Object userData) {
 		this.definition = definition;
 		this.userData = userData;
 	}
@@ -79,11 +77,10 @@ abstract class AbstractSourceSinkInfo {
 	/**
 	 * Gets the original definition of this data flow source or sink
 	 * 
-	 * @return The original definition of the source or sink. The return value
-	 *         may be null if this source is not modeled for a specific method
-	 *         or field.
+	 * @return The original definition of the source or sink. The return value may
+	 *         be null if this source is not modeled for a specific method or field.
 	 */
-	public SourceSinkDefinition getDefinition() {
+	public ISourceSinkDefinition getDefinition() {
 		return definition;
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/BaseSourceSinkManager.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/BaseSourceSinkManager.java
new file mode 100644
index 0000000..8af7cb5
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/BaseSourceSinkManager.java
@@ -0,0 +1,762 @@
+package soot.jimple.infoflow.sourcesSinks.manager;
+
+import static soot.SootClass.DANGLING;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+
+import heros.solver.IDESolver;
+import heros.solver.Pair;
+import soot.Scene;
+import soot.SootClass;
+import soot.SootField;
+import soot.SootMethod;
+import soot.VoidType;
+import soot.jimple.AssignStmt;
+import soot.jimple.DefinitionStmt;
+import soot.jimple.FieldRef;
+import soot.jimple.IdentityStmt;
+import soot.jimple.InstanceInvokeExpr;
+import soot.jimple.InvokeExpr;
+import soot.jimple.ParameterRef;
+import soot.jimple.ReturnStmt;
+import soot.jimple.Stmt;
+import soot.jimple.infoflow.InfoflowConfiguration;
+import soot.jimple.infoflow.InfoflowConfiguration.CallbackSourceMode;
+import soot.jimple.infoflow.InfoflowConfiguration.SourceSinkConfiguration;
+import soot.jimple.infoflow.InfoflowManager;
+import soot.jimple.infoflow.callbacks.CallbackDefinition;
+import soot.jimple.infoflow.data.AccessPath;
+import soot.jimple.infoflow.data.AccessPath.ArrayTaintType;
+import soot.jimple.infoflow.data.SootMethodAndClass;
+import soot.jimple.infoflow.solver.cfg.IInfoflowCFG;
+import soot.jimple.infoflow.sourcesSinks.definitions.AccessPathTuple;
+import soot.jimple.infoflow.sourcesSinks.definitions.FieldSourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition.CallType;
+import soot.jimple.infoflow.sourcesSinks.definitions.StatementSourceSinkDefinition;
+import soot.jimple.infoflow.util.SystemClassHandler;
+import soot.jimple.infoflow.values.IValueProvider;
+import soot.jimple.infoflow.values.SimpleConstantValueProvider;
+import soot.jimple.toolkits.ide.icfg.BiDiInterproceduralCFG;
+import soot.util.HashMultiMap;
+import soot.util.MultiMap;
+
+public abstract class BaseSourceSinkManager implements ISourceSinkManager, IOneSourceAtATimeManager {
+	private final static String GLOBAL_SIG = "--GLOBAL--";
+
+	private final Logger logger = LoggerFactory.getLogger(getClass());
+
+	/**
+	 * Types of sources supported by this SourceSinkManager
+	 *
+	 * @author Steven Arzt
+	 */
+	public static enum SourceType {
+		/**
+		 * Not a source
+		 */
+		NoSource,
+		/**
+		 * The data is obtained via a method call
+		 */
+		MethodCall,
+		/**
+		 * The data is retrieved through a callback parameter
+		 */
+		Callback,
+		/**
+		 * The data is read from a UI element
+		 */
+		UISource
+	}
+
+	protected MultiMap<String, ISourceSinkDefinition> sourceDefs;
+	protected MultiMap<String, ISourceSinkDefinition> sinkDefs;
+
+	protected Map<SootMethod, ISourceSinkDefinition> sourceMethods;
+	protected Map<Stmt, ISourceSinkDefinition> sourceStatements;
+	protected Map<SootMethod, ISourceSinkDefinition> sinkMethods;
+	protected Map<SootMethod, ISourceSinkDefinition> sinkReturnMethods;
+	protected Map<SootMethod, CallbackDefinition> callbackMethods;
+	protected Map<SootField, ISourceSinkDefinition> sourceFields;
+	protected Map<SootField, ISourceSinkDefinition> sinkFields;
+	protected Map<Stmt, ISourceSinkDefinition> sinkStatements;
+
+	protected final SourceSinkConfiguration sourceSinkConfig;
+
+	protected final Set<SootMethod> excludedMethods = new HashSet<>();
+
+	protected boolean oneSourceAtATime = false;
+	protected SourceType osaatType = SourceType.MethodCall;
+	protected Iterator<SootMethod> osaatIterator = null;
+	protected SootMethod currentSource = null;
+	protected IValueProvider valueProvider = new SimpleConstantValueProvider();
+
+	protected final LoadingCache<SootClass, Collection<SootClass>> interfacesOf = IDESolver.DEFAULT_CACHE_BUILDER
+			.build(new CacheLoader<SootClass, Collection<SootClass>>() {
+
+				@Override
+				public Collection<SootClass> load(SootClass sc) throws Exception {
+					Set<SootClass> set = new HashSet<SootClass>(sc.getInterfaceCount());
+					for (SootClass i : sc.getInterfaces()) {
+						set.add(i);
+						set.addAll(interfacesOf.getUnchecked(i));
+					}
+					if (sc.hasSuperclass())
+						set.addAll(interfacesOf.getUnchecked(sc.getSuperclass()));
+					return set;
+				}
+
+			});
+
+	/**
+	 * Creates a new instance of the {@link BaseSourceSinkManager} class with either
+	 * strong or weak matching.
+	 *
+	 * @param sources The list of source methods
+	 * @param sinks   The list of sink methods
+	 * @param config  The configuration of the data flow analyzer
+	 */
+	public BaseSourceSinkManager(Set<? extends ISourceSinkDefinition> sources,
+			Set<? extends ISourceSinkDefinition> sinks, InfoflowConfiguration config) {
+		this(sources, sinks, Collections.<CallbackDefinition>emptySet(), config);
+	}
+
+	/**
+	 * Creates a new instance of the {@link BaseSourceSinkManager} class with strong
+	 * matching, i.e. the methods in the code must exactly match those in the list.
+	 *
+	 * @param sources         The list of source methods
+	 * @param sinks           The list of sink methods
+	 * @param callbackMethods The list of callback methods whose parameters are
+	 *                        sources through which the application receives data
+	 *                        from the operating system
+	 * @param weakMatching    True for weak matching: If an entry in the list has no
+	 *                        return type, it matches arbitrary return types if the
+	 *                        rest of the method signature is compatible. False for
+	 *                        strong matching: The method signature in the code
+	 *                        exactly match the one in the list.
+	 * @param config          The configuration of the data flow analyzer
+	 */
+	public BaseSourceSinkManager(Set<? extends ISourceSinkDefinition> sources,
+			Set<? extends ISourceSinkDefinition> sinks, Set<? extends CallbackDefinition> callbackMethods,
+			InfoflowConfiguration config) {
+		this.sourceSinkConfig = config.getSourceSinkConfig();
+
+		this.sourceDefs = new HashMultiMap<>();
+		for (ISourceSinkDefinition am : sources)
+			this.sourceDefs.put(getSignature(am), am);
+
+		this.sinkDefs = new HashMultiMap<>();
+		for (ISourceSinkDefinition am : sinks)
+			this.sinkDefs.put(getSignature(am), am);
+
+		this.callbackMethods = new HashMap<>();
+		for (CallbackDefinition cb : callbackMethods)
+			this.callbackMethods.put(cb.getTargetMethod(), cb);
+
+		logger.info(String.format("Created a SourceSinkManager with %d sources, %d sinks, and %d callback methods.",
+				this.sourceDefs.size(), this.sinkDefs.size(), this.callbackMethods.size()));
+	}
+
+	/**
+	 * Gets the field or method signature of the given source/sink definition
+	 *
+	 * @param am The source/sink definition for which to get a Soot signature
+	 * @return The Soot signature associated with the given source/sink definition
+	 */
+	private String getSignature(ISourceSinkDefinition am) {
+		if (am instanceof MethodSourceSinkDefinition) {
+			MethodSourceSinkDefinition methodSource = (MethodSourceSinkDefinition) am;
+			return methodSource.getMethod().getSignature();
+		} else if (am instanceof FieldSourceSinkDefinition) {
+			FieldSourceSinkDefinition fieldSource = (FieldSourceSinkDefinition) am;
+			return fieldSource.getFieldSignature();
+		} else if (am instanceof StatementSourceSinkDefinition)
+			return GLOBAL_SIG;
+		else
+			throw new RuntimeException(
+					String.format("Invalid type of source/sink definition: %s", am.getClass().getName()));
+	}
+
+	/**
+	 * Gets the sink definition for the given call site and tainted access path
+	 *
+	 * @param sCallSite The call site
+	 * @param manager   The manager object providing access to the configuration and
+	 *                  the interprocedural control flow graph
+	 * @param ap        The incoming tainted access path
+	 * @return The sink definition of the method that is called at the given call
+	 *         site if such a definition exists, otherwise null
+	 */
+	protected ISourceSinkDefinition getSinkDefinition(Stmt sCallSite, InfoflowManager manager, AccessPath ap) {
+		// Do we have a statement-specific definition?
+		{
+			ISourceSinkDefinition def = sinkStatements.get(sCallSite);
+			if (def != null)
+				return def;
+		}
+
+		if (sCallSite.containsInvokeExpr()) {
+			// Check whether the taint is even visible inside the callee
+			final SootMethod callee = sCallSite.getInvokeExpr().getMethod();
+			if (!SystemClassHandler.v().isTaintVisible(ap, callee))
+				return null;
+
+			// Do we have a direct hit?
+			{
+				ISourceSinkDefinition def = this.sinkMethods.get(sCallSite.getInvokeExpr().getMethod());
+				if (def != null)
+					return def;
+			}
+
+			final String subSig = callee.getSubSignature();
+
+			// Check whether we have any of the interfaces on the list
+			for (SootClass i : interfacesOf.getUnchecked(sCallSite.getInvokeExpr().getMethod().getDeclaringClass())) {
+				if (i.declaresMethod(subSig)) {
+					ISourceSinkDefinition def = this.sinkMethods.get(i.getMethod(subSig));
+					if (def != null)
+						return def;
+				}
+			}
+
+			// Ask the CFG in case we don't know any better
+			for (SootMethod sm : manager.getICFG().getCalleesOfCallAt(sCallSite)) {
+				ISourceSinkDefinition def = this.sinkMethods.get(sm);
+				if (def != null)
+					return def;
+			}
+
+			// If the target method is in a phantom class, we scan the hierarchy
+			// upwards to see whether we have a sink definition for a parent
+			// class
+			if (callee.getDeclaringClass().isPhantom()) {
+				ISourceSinkDefinition def = findDefinitionInHierarchy(callee, this.sinkMethods);
+				if (def != null)
+					return def;
+			}
+			return null;
+
+		} else if (sCallSite instanceof AssignStmt) {
+			// Check if the target is a sink field
+			AssignStmt assignStmt = (AssignStmt) sCallSite;
+			if (assignStmt.getLeftOp() instanceof FieldRef) {
+				FieldRef fieldRef = (FieldRef) assignStmt.getLeftOp();
+				ISourceSinkDefinition def = sinkFields.get(fieldRef.getField());
+				if (def != null)
+					return def;
+			}
+		} else if (sCallSite instanceof ReturnStmt) {
+			return sinkReturnMethods.get(manager.getICFG().getMethodOf(sCallSite));
+		}
+
+		return null;
+	}
+
+	/**
+	 * Scans the hierarchy of the class containing the given method to find any
+	 * implementations of the same method further up in the hierarchy for which
+	 * there is a SourceSinkDefinition in the given map
+	 *
+	 * @param callee The method for which to look for a SourceSinkDefinition
+	 * @param map    A map from methods to their corresponding SourceSinkDefinitions
+	 * @return A SourceSinKDefinition for an implementation of the given method
+	 *         somewhere up in the class hiearchy if it exists, otherwise null.
+	 */
+	private static ISourceSinkDefinition findDefinitionInHierarchy(SootMethod callee,
+			Map<SootMethod, ISourceSinkDefinition> map) {
+		final String subSig = callee.getSubSignature();
+		SootClass curClass = callee.getDeclaringClass();
+		while (curClass != null) {
+			// Does the current class declare the requested method?
+			SootMethod curMethod = curClass.getMethodUnsafe(subSig);
+			if (curMethod != null) {
+				ISourceSinkDefinition def = map.get(curMethod);
+				if (def != null) {
+					// Patch the map to contain a direct link
+					map.put(callee, def);
+					return def;
+				}
+			}
+
+			// Try the next class up the hierarchy
+			if (curClass.hasSuperclass() && curClass.isPhantom())
+				curClass = curClass.getSuperclass();
+			else
+				curClass = null;
+		}
+
+		return null;
+	}
+
+	@Override
+	public SinkInfo getSinkInfo(Stmt sCallSite, InfoflowManager manager, AccessPath ap) {
+		ISourceSinkDefinition def = getSinkDefinition(sCallSite, manager, ap);
+		return def == null ? null : new SinkInfo(def);
+	}
+
+	@Override
+	public SourceInfo getSourceInfo(Stmt sCallSite, InfoflowManager manager) {
+		// Do not look for sources in excluded methods
+		if (excludedMethods.contains(manager.getICFG().getMethodOf(sCallSite)))
+			return null;
+
+		ISourceSinkDefinition def = getSource(sCallSite, manager.getICFG());
+		return createSourceInfo(sCallSite, manager, def);
+	}
+
+	protected SourceInfo createSourceInfo(Stmt sCallSite, InfoflowManager manager, ISourceSinkDefinition def) {
+		// Do we have data at all?
+		if (def == null)
+			return null;
+
+		// If we don't have an invocation, we just taint the left side of the
+		// assignment
+		if (!sCallSite.containsInvokeExpr()) {
+			if (sCallSite instanceof DefinitionStmt) {
+				DefinitionStmt defStmt = (DefinitionStmt) sCallSite;
+				return new SourceInfo(def, manager.getAccessPathFactory().createAccessPath(defStmt.getLeftOp(), null,
+						null, null, true, false, true, ArrayTaintType.ContentsAndLength, false));
+			}
+			return null;
+		}
+
+		// If this is a method call and we have a return value, we taint it.
+		// Otherwise, if we have an instance invocation, we taint the base
+		// object
+		final InvokeExpr iexpr = sCallSite.getInvokeExpr();
+		if (sCallSite instanceof DefinitionStmt && iexpr.getMethod().getReturnType() != null) {
+			DefinitionStmt defStmt = (DefinitionStmt) sCallSite;
+			// no immutable aliases, we overwrite the return values as a whole
+			return new SourceInfo(def, manager.getAccessPathFactory().createAccessPath(defStmt.getLeftOp(), null, null,
+					null, true, false, true, ArrayTaintType.ContentsAndLength, false));
+		} else if (iexpr instanceof InstanceInvokeExpr && iexpr.getMethod().getReturnType() == VoidType.v()) {
+			InstanceInvokeExpr iinv = (InstanceInvokeExpr) sCallSite.getInvokeExpr();
+			return new SourceInfo(def, manager.getAccessPathFactory().createAccessPath(iinv.getBase(), true));
+		} else
+			return null;
+	}
+
+	/**
+	 * Checks whether the given method is registered as a source method. If so,
+	 * returns the corresponding definition, otherwise null.
+	 *
+	 * @param method The method to check
+	 * @return The respective source definition if the given method is a source
+	 *         method, otherwise null
+	 */
+	protected ISourceSinkDefinition getSourceMethod(SootMethod method) {
+		if (oneSourceAtATime && (osaatType != SourceType.MethodCall || currentSource != method))
+			return null;
+		return this.sourceMethods.get(method);
+	}
+
+	/**
+	 * Checks whether the given method is registered as a source method
+	 *
+	 * @param method The method to check
+	 * @return True if the given method is a source method, otherwise false
+	 */
+	protected ISourceSinkDefinition getSourceDefinition(SootMethod method) {
+		if (oneSourceAtATime) {
+			if (osaatType == SourceType.MethodCall && currentSource == method)
+				return this.sourceMethods.get(method);
+			else
+				return null;
+		} else
+			return this.sourceMethods.get(method);
+	}
+
+	/**
+	 * Checks whether the given method is registered as a callback method. If so,
+	 * the corresponding source definition is returned, otherwise null is returned.
+	 *
+	 * @param method The method to check
+	 * @return The source definition object if the given method is a callback
+	 *         method, otherwise null
+	 */
+	protected CallbackDefinition getCallbackDefinition(SootMethod method) {
+		if (oneSourceAtATime) {
+			if (osaatType == SourceType.Callback && currentSource == method)
+				return this.callbackMethods.get(method);
+			else
+				return null;
+		} else
+			return this.callbackMethods.get(method);
+	}
+
+	/**
+	 * Checks whether the given statement is a source, i.e. introduces new
+	 * information into the application. If so, the source definition is returned,
+	 * otherwise null
+	 *
+	 * @param sCallSite The statement to check for a source
+	 * @param cfg       An interprocedural CFG containing the statement
+	 * @return The definition of the discovered source if the given statement is a
+	 *         source, null otherwise
+	 */
+	protected ISourceSinkDefinition getSource(Stmt sCallSite, IInfoflowCFG cfg) {
+		assert cfg != null;
+		assert cfg instanceof BiDiInterproceduralCFG;
+
+		// Do we have a statement-specific definition?
+		{
+			ISourceSinkDefinition def = sourceStatements.get(sCallSite);
+			if (def != null)
+				return def;
+		}
+
+		ISourceSinkDefinition def = null;
+		if ((!oneSourceAtATime || osaatType == SourceType.MethodCall) && sCallSite.containsInvokeExpr()) {
+			// This might be a normal source method
+			final SootMethod callee = sCallSite.getInvokeExpr().getMethod();
+			def = getSourceDefinition(callee);
+			if (def != null)
+				return def;
+
+			// Check whether we have any of the interfaces on the list
+			final String subSig = callee.getSubSignature();
+			for (SootClass i : interfacesOf.getUnchecked(callee.getDeclaringClass())) {
+				SootMethod m = i.getMethodUnsafe(subSig);
+				if (m != null) {
+					def = getSourceDefinition(m);
+					if (def != null)
+						return def;
+				}
+			}
+
+			// Ask the CFG in case we don't know any better
+			for (SootMethod sm : cfg.getCalleesOfCallAt(sCallSite)) {
+				def = getSourceDefinition(sm);
+				if (def != null)
+					return def;
+			}
+
+			// If the target method is in a phantom class, we scan the hierarchy
+			// upwards
+			// to see whether we have a sink definition for a parent class
+			if (callee.getDeclaringClass().isPhantom()) {
+				def = findDefinitionInHierarchy(callee, this.sourceMethods);
+				if (def != null)
+					return def;
+			}
+		}
+
+		// This call might read out sensitive data from the UI
+		if ((!oneSourceAtATime || osaatType == SourceType.UISource)) {
+			def = getUISourceDefinition(sCallSite, cfg);
+			if (def != null)
+				return def;
+		}
+
+		// This statement might access a sensitive parameter in a callback
+		// method
+		def = checkCallbackParamSource(sCallSite, cfg);
+		if (def != null)
+			return def;
+
+		// This statement may read sensitive data from a field
+		def = checkFieldSource(sCallSite, cfg);
+		if (def != null)
+			return def;
+
+		return null;
+	}
+
+	/**
+	 * Checks whether the given statement accesses a field that has been marked as a
+	 * source
+	 *
+	 * @param stmt The statement to check
+	 * @param cfg  The interprocedural control flow graph
+	 * @return The source and sink definition that corresponds to the detected field
+	 *         source if the given statement is a source, otherwise null
+	 */
+	private ISourceSinkDefinition checkFieldSource(Stmt stmt, IInfoflowCFG cfg) {
+		if (stmt instanceof AssignStmt) {
+			AssignStmt assignStmt = (AssignStmt) stmt;
+			if (assignStmt.getRightOp() instanceof FieldRef) {
+				FieldRef fieldRef = (FieldRef) assignStmt.getRightOp();
+				return sourceFields.get(fieldRef.getField());
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Checks whether the given statement obtains data from a callback source
+	 *
+	 * @param sCallSite The statement to check
+	 * @param cfg       The interprocedural control flow graph
+	 * @return The source and sink definition that corresponds to the detected
+	 *         callback source if the given statement is a source, otherwise null
+	 */
+	protected ISourceSinkDefinition checkCallbackParamSource(Stmt sCallSite, IInfoflowCFG cfg) {
+		// Do we handle callback sources at all?
+		if (sourceSinkConfig.getCallbackSourceMode() == CallbackSourceMode.NoParametersAsSources)
+			return null;
+		if (oneSourceAtATime && osaatType != SourceType.Callback)
+			return null;
+
+		// Callback sources can only be parameter references
+		if (!(sCallSite instanceof IdentityStmt))
+			return null;
+		IdentityStmt is = (IdentityStmt) sCallSite;
+		if (!(is.getRightOp() instanceof ParameterRef))
+			return null;
+		ParameterRef paramRef = (ParameterRef) is.getRightOp();
+
+		// We do not consider the parameters of lifecycle methods as
+		// sources by default
+		SootMethod parentMethod = cfg.getMethodOf(sCallSite);
+		if (parentMethod == null)
+			return null;
+		if (!sourceSinkConfig.getEnableLifecycleSources() && isEntryPointMethod(parentMethod))
+			return null;
+
+		// Obtain the callback definition for the method in which this parameter
+		// access occurs
+		CallbackDefinition def = getCallbackDefinition(parentMethod);
+		if (def == null)
+			return null;
+
+		// Do we match all callbacks?
+		if (sourceSinkConfig.getCallbackSourceMode() == CallbackSourceMode.AllParametersAsSources)
+			return MethodSourceSinkDefinition.createParameterSource(paramRef.getIndex(), CallType.Callback);
+
+		// Do we only match registered callback methods?
+		ISourceSinkDefinition sourceSinkDef = this.sourceMethods.get(def.getParentMethod());
+		if (sourceSinkDef instanceof MethodSourceSinkDefinition) {
+			MethodSourceSinkDefinition methodDef = (MethodSourceSinkDefinition) sourceSinkDef;
+			if (sourceSinkConfig.getCallbackSourceMode() == CallbackSourceMode.SourceListOnly
+					&& sourceSinkDef != null) {
+				// Check the parameter index
+				Set<AccessPathTuple>[] methodParamDefs = methodDef.getParameters();
+				if (methodParamDefs != null && methodParamDefs.length > paramRef.getIndex()) {
+					Set<AccessPathTuple> apTuples = methodDef.getParameters()[paramRef.getIndex()];
+					if (apTuples != null && !apTuples.isEmpty()) {
+						for (AccessPathTuple curTuple : apTuples)
+							if (curTuple.getSourceSinkType().isSource())
+								return sourceSinkDef;
+					}
+				}
+			}
+		}
+
+		return null;
+	}
+
+	/**
+	 * Checks whether the given method is an entry point, i.e., a lifecycle method
+	 * 
+	 * @param method the method
+	 * @return true if the method is an entry point
+	 */
+	protected abstract boolean isEntryPointMethod(SootMethod method);
+
+	/**
+	 * Checks whether the given call site indicates a UI source, e.g. a password
+	 * input. If so, creates an {@link ISourceSinkDefinition} for it
+	 *
+	 * @param sCallSite The call site that may potentially read data from a
+	 *                  sensitive UI control
+	 * @param cfg       The bidirectional control flow graph
+	 * @return The generated {@link ISourceSinkDefinition} if the given call site
+	 *         reads data from a UI source, null otherwise
+	 */
+	protected ISourceSinkDefinition getUISourceDefinition(Stmt sCallSite, IInfoflowCFG cfg) {
+		return null;
+	}
+
+	@Override
+	public void initialize() {
+		// Get the Soot method or field for the source signatures we have
+		if (sourceDefs != null) {
+			sourceMethods = new HashMap<>();
+			sourceFields = new HashMap<>();
+			sourceStatements = new HashMap<>();
+			for (Pair<String, ISourceSinkDefinition> entry : sourceDefs) {
+				ISourceSinkDefinition sourceSinkDef = entry.getO2();
+				if (sourceSinkDef instanceof MethodSourceSinkDefinition) {
+					SootMethodAndClass method = ((MethodSourceSinkDefinition) sourceSinkDef).getMethod();
+					String returnType = method.getReturnType();
+
+					// We need special handling for methods for which no return type has been
+					// specified, i.e., the signature is incomplete
+					if (returnType == null || returnType.isEmpty()) {
+						String className = method.getClassName();
+
+						String subSignatureWithoutReturnType = (((MethodSourceSinkDefinition) sourceSinkDef).getMethod()
+								.getSubSignature());
+						SootMethod sootMethod = grabMethodWithoutReturn(className, subSignatureWithoutReturnType);
+						if (sootMethod != null)
+							sourceMethods.put(sootMethod, sourceSinkDef);
+					} else {
+						SootMethod sm = Scene.v().grabMethod(entry.getO1());
+						if (sm != null)
+							sourceMethods.put(sm, sourceSinkDef);
+					}
+
+				} else if (sourceSinkDef instanceof FieldSourceSinkDefinition) {
+					SootField sf = Scene.v().grabField(entry.getO1());
+					if (sf != null)
+						sourceFields.put(sf, sourceSinkDef);
+				} else if (sourceSinkDef instanceof StatementSourceSinkDefinition) {
+					StatementSourceSinkDefinition sssd = (StatementSourceSinkDefinition) sourceSinkDef;
+					sourceStatements.put(sssd.getStmt(), sssd);
+				}
+			}
+			sourceDefs = null;
+
+		}
+
+		// Get the Soot method or field for the sink signatures we have
+		if (sinkDefs != null) {
+			sinkMethods = new HashMap<>();
+			sinkFields = new HashMap<>();
+			sinkReturnMethods = new HashMap<>();
+			sinkStatements = new HashMap<>();
+			for (Pair<String, ISourceSinkDefinition> entry : sinkDefs) {
+				ISourceSinkDefinition sourceSinkDef = entry.getO2();
+				if (sourceSinkDef instanceof MethodSourceSinkDefinition) {
+					MethodSourceSinkDefinition methodSourceSinkDef = ((MethodSourceSinkDefinition) sourceSinkDef);
+					if (methodSourceSinkDef.getCallType() == CallType.Return) {
+						SootMethodAndClass method = methodSourceSinkDef.getMethod();
+						SootMethod m = Scene.v().grabMethod(method.getSignature());
+						if (m != null)
+							sinkReturnMethods.put(m, methodSourceSinkDef);
+					} else {
+						SootMethodAndClass method = methodSourceSinkDef.getMethod();
+						String returnType = method.getReturnType();
+						boolean isMethodWithoutReturnType = returnType == null || returnType.isEmpty();
+						if (isMethodWithoutReturnType) {
+							String className = method.getClassName();
+							String subSignatureWithoutReturnType = (((MethodSourceSinkDefinition) sourceSinkDef)
+									.getMethod().getSubSignature());
+							SootMethod sootMethod = grabMethodWithoutReturn(className, subSignatureWithoutReturnType);
+							if (sootMethod != null)
+								sinkMethods.put(sootMethod, sourceSinkDef);
+						} else {
+							SootMethod sm = Scene.v().grabMethod(entry.getO1());
+							if (sm != null)
+								sinkMethods.put(sm, entry.getO2());
+						}
+					}
+
+				} else if (sourceSinkDef instanceof FieldSourceSinkDefinition) {
+					SootField sf = Scene.v().grabField(entry.getO1());
+					if (sf != null)
+						sinkFields.put(sf, sourceSinkDef);
+				} else if (sourceSinkDef instanceof StatementSourceSinkDefinition) {
+					StatementSourceSinkDefinition sssd = (StatementSourceSinkDefinition) sourceSinkDef;
+					sinkStatements.put(sssd.getStmt(), sssd);
+				}
+			}
+			sinkDefs = null;
+		}
+	}
+
+	/**
+	 * Gets a soot method defined by class name and its sub signature from the
+	 * loaded methods in the Scene object
+	 *
+	 * @param sootClassName The class name of the method
+	 * @param subSignature  The sub signature of the method which is the method name
+	 *                      and its parameters
+	 * @return The soot method of the given class and sub signature or null
+	 */
+	private SootMethod grabMethodWithoutReturn(String sootClassName, String subSignature) {
+		SootClass sootClass = Scene.v().getSootClassUnsafe(sootClassName);
+		if (sootClass == null)
+			return null;
+
+		List<SootMethod> sootMethods = null;
+		if (sootClass.resolvingLevel() != DANGLING) {
+			sootMethods = sootClass.getMethods();
+
+			for (SootMethod s : sootMethods) {
+				String[] tempSignature = s.getSubSignature().split(" ");
+
+				if (tempSignature.length == 2) {
+					if (tempSignature[1].equals(subSignature))
+						return s;
+				}
+
+			}
+		}
+
+		return null;
+	}
+
+	@Override
+	public void setOneSourceAtATimeEnabled(boolean enabled) {
+		this.oneSourceAtATime = enabled;
+	}
+
+	@Override
+	public boolean isOneSourceAtATimeEnabled() {
+		return this.oneSourceAtATime;
+	}
+
+	@Override
+	public void resetCurrentSource() {
+		this.osaatIterator = this.sourceMethods.keySet().iterator();
+		this.osaatType = SourceType.MethodCall;
+	}
+
+	@Override
+	public void nextSource() {
+		if (osaatType == SourceType.MethodCall || osaatType == SourceType.Callback)
+			currentSource = this.osaatIterator.next();
+	}
+
+	@Override
+	public boolean hasNextSource() {
+		if (osaatType == SourceType.MethodCall) {
+			if (this.osaatIterator.hasNext())
+				return true;
+			else {
+				this.osaatType = SourceType.Callback;
+				this.osaatIterator = this.callbackMethods.keySet().iterator();
+				return hasNextSource();
+			}
+		} else if (osaatType == SourceType.Callback) {
+			if (this.osaatIterator.hasNext())
+				return true;
+			else {
+				this.osaatType = SourceType.UISource;
+				return true;
+			}
+		} else if (osaatType == SourceType.UISource) {
+			osaatType = SourceType.NoSource;
+			return false;
+		}
+		return false;
+	}
+
+	/**
+	 * Excludes the given method from the source/sink analysis. No sources or sinks
+	 * will be detected in excluded methods.
+	 *
+	 * @param toExclude The method to exclude
+	 */
+	public void excludeMethod(SootMethod toExclude) {
+		this.excludedMethods.add(toExclude);
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/DefaultSourceSinkManager.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/DefaultSourceSinkManager.java
index 22cad90..d4558ff 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/DefaultSourceSinkManager.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/DefaultSourceSinkManager.java
@@ -33,9 +33,9 @@ import soot.jimple.Stmt;
 import soot.jimple.infoflow.InfoflowManager;
 import soot.jimple.infoflow.data.AccessPath;
 import soot.jimple.infoflow.data.SootMethodAndClass;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinitionProvider;
 import soot.jimple.infoflow.sourcesSinks.definitions.MethodSourceSinkDefinition;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
 import soot.jimple.infoflow.util.SystemClassHandler;
 
 /**
@@ -45,8 +45,8 @@ import soot.jimple.infoflow.util.SystemClassHandler;
  */
 public class DefaultSourceSinkManager implements ISourceSinkManager {
 
-	private Collection<String> sourceDefs;
-	private Collection<String> sinkDefs;
+	protected Collection<String> sourceDefs;
+	protected Collection<String> sinkDefs;
 
 	private Collection<SootMethod> sources;
 	private Collection<SootMethod> sinks;
@@ -113,7 +113,7 @@ public class DefaultSourceSinkManager implements ISourceSinkManager {
 		this.sinkDefs = new HashSet<>();
 
 		// Load the sources
-		for (SourceSinkDefinition ssd : sourceSinkProvider.getSources()) {
+		for (ISourceSinkDefinition ssd : sourceSinkProvider.getSources()) {
 			if (ssd instanceof MethodSourceSinkDefinition) {
 				MethodSourceSinkDefinition mssd = (MethodSourceSinkDefinition) ssd;
 				sourceDefs.add(mssd.getMethod().getSignature());
@@ -121,7 +121,7 @@ public class DefaultSourceSinkManager implements ISourceSinkManager {
 		}
 
 		// Load the sinks
-		for (SourceSinkDefinition ssd : sourceSinkProvider.getSinks()) {
+		for (ISourceSinkDefinition ssd : sourceSinkProvider.getSinks()) {
 			if (ssd instanceof MethodSourceSinkDefinition) {
 				MethodSourceSinkDefinition mssd = (MethodSourceSinkDefinition) ssd;
 				sinkDefs.add(mssd.getMethod().getSignature());
@@ -191,7 +191,7 @@ public class DefaultSourceSinkManager implements ISourceSinkManager {
 	 * @param sCallSite The call site to check
 	 * @return True if the given call site invoked a source method, otherwise false
 	 */
-	private boolean isSourceMethod(InfoflowManager manager, Stmt sCallSite) {
+	protected boolean isSourceMethod(InfoflowManager manager, Stmt sCallSite) {
 		// We only support method calls
 		if (!sCallSite.containsInvokeExpr())
 			return false;
@@ -237,7 +237,7 @@ public class DefaultSourceSinkManager implements ISourceSinkManager {
 			SootMethodAndClass smac = isSinkMethod(manager, sCallSite);
 			if (smac != null) {
 				// Check that the incoming taint is visible in the callee at all
-				if (SystemClassHandler.isTaintVisible(ap, iexpr.getMethod())) {
+				if (SystemClassHandler.v().isTaintVisible(ap, iexpr.getMethod())) {
 					// If we don't have an access path, we can only
 					// over-approximate
 					if (ap == null)
@@ -271,7 +271,7 @@ public class DefaultSourceSinkManager implements ISourceSinkManager {
 	 * @return The method that was discovered as a sink, or null if no sink could be
 	 *         found
 	 */
-	private SootMethodAndClass isSinkMethod(InfoflowManager manager, Stmt sCallSite) {
+	protected SootMethodAndClass isSinkMethod(InfoflowManager manager, Stmt sCallSite) {
 		// Is the method directly in the sink set?
 		SootMethod callee = sCallSite.getInvokeExpr().getMethod();
 		if (this.sinks.contains(callee))
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/SinkInfo.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/SinkInfo.java
index f8ef314..d99813e 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/SinkInfo.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/SinkInfo.java
@@ -1,6 +1,6 @@
 package soot.jimple.infoflow.sourcesSinks.manager;
 
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 
 /**
  * Class containing additional information about a sink. Users of FlowDroid can
@@ -14,22 +14,19 @@ public class SinkInfo extends AbstractSourceSinkInfo {
 	/**
 	 * Creates a new instance of the {@link AbstractSourceSinkInfo} class.
 	 * 
-	 * @param definition
-	 *            The original definition of the source or sink
-	 * @param userData
-	 *            Additional user data to be propagated with the source
+	 * @param definition The original definition of the source or sink
+	 * @param userData   Additional user data to be propagated with the source
 	 */
-	public SinkInfo(SourceSinkDefinition definition, Object userData) {
+	public SinkInfo(ISourceSinkDefinition definition, Object userData) {
 		super(definition, userData);
 	}
 
 	/**
 	 * Creates a new instance of the {@link AbstractSourceSinkInfo} class.
 	 * 
-	 * @param definition
-	 *            The original definition of the source or sink
+	 * @param definition The original definition of the source or sink
 	 */
-	public SinkInfo(SourceSinkDefinition definition) {
+	public SinkInfo(ISourceSinkDefinition definition) {
 		super(definition);
 	}
 
diff --git a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/SourceInfo.java b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/SourceInfo.java
index 3a85095..b8f2686 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/SourceInfo.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/sourcesSinks/manager/SourceInfo.java
@@ -4,7 +4,7 @@ import java.util.Collections;
 import java.util.Set;
 
 import soot.jimple.infoflow.data.AccessPath;
-import soot.jimple.infoflow.sourcesSinks.definitions.SourceSinkDefinition;
+import soot.jimple.infoflow.sourcesSinks.definitions.ISourceSinkDefinition;
 
 /**
  * Class containing additional information about a source. Users of FlowDroid
@@ -18,58 +18,47 @@ public class SourceInfo extends AbstractSourceSinkInfo {
 	protected final Set<AccessPath> accessPaths;
 
 	/**
-	 * Creates a new instance of the {@link SourceInfo} class. This is a
-	 * convenience constructor to allow for the simple use of a single access
-	 * path.
+	 * Creates a new instance of the {@link SourceInfo} class. This is a convenience
+	 * constructor to allow for the simple use of a single access path.
 	 * 
 	 * * @param definition The original definition of the source or sink
 	 * 
-	 * @param ap
-	 *            The single access path that shall be tainted at this source
+	 * @param ap The single access path that shall be tainted at this source
 	 */
-	public SourceInfo(SourceSinkDefinition definition, AccessPath ap) {
+	public SourceInfo(ISourceSinkDefinition definition, AccessPath ap) {
 		this(definition, Collections.singleton(ap), null);
 	}
 
 	/**
-	 * Creates a new instance of the {@link AbstractSourceSinkInfo} class. This
-	 * is a convenience constructor to allow for the simple use of a single
-	 * access path.
+	 * Creates a new instance of the {@link AbstractSourceSinkInfo} class. This is a
+	 * convenience constructor to allow for the simple use of a single access path.
 	 * 
-	 * @param definition
-	 *            The original definition of the source or sink
-	 * @param ap
-	 *            The single access path that shall be tainted at this source
-	 * @param userData
-	 *            Additional user data to be propagated with the source
+	 * @param definition The original definition of the source or sink
+	 * @param ap         The single access path that shall be tainted at this source
+	 * @param userData   Additional user data to be propagated with the source
 	 */
-	public SourceInfo(SourceSinkDefinition definition, AccessPath ap, Object userData) {
+	public SourceInfo(ISourceSinkDefinition definition, AccessPath ap, Object userData) {
 		this(definition, Collections.singleton(ap), userData);
 	}
 
 	/**
 	 * Creates a new instance of the {@link SourceInfo} class
 	 * 
-	 * @param definition
-	 *            The original definition of the source or sink
-	 * @param bundle
-	 *            Information about access paths tainted by this source
+	 * @param definition The original definition of the source or sink
+	 * @param bundle     Information about access paths tainted by this source
 	 */
-	public SourceInfo(SourceSinkDefinition definition, Set<AccessPath> bundle) {
+	public SourceInfo(ISourceSinkDefinition definition, Set<AccessPath> bundle) {
 		this(definition, bundle, null);
 	}
 
 	/**
 	 * Creates a new instance of the {@link SourceInfo} class
 	 * 
-	 * @param definition
-	 *            The original definition of the source or sink
-	 * @param bundle
-	 *            Information about access paths tainted by this source
-	 * @param userData
-	 *            Additional user data to be propagated with the source
+	 * @param definition The original definition of the source or sink
+	 * @param bundle     Information about access paths tainted by this source
+	 * @param userData   Additional user data to be propagated with the source
 	 */
-	public SourceInfo(SourceSinkDefinition definition, Set<AccessPath> bundle, Object userData) {
+	public SourceInfo(ISourceSinkDefinition definition, Set<AccessPath> bundle, Object userData) {
 		super(definition, userData);
 		this.accessPaths = bundle;
 	}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/taintWrappers/EasyTaintWrapper.java b/soot-infoflow/src/soot/jimple/infoflow/taintWrappers/EasyTaintWrapper.java
index cb9c28c..dc47bb4 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/taintWrappers/EasyTaintWrapper.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/taintWrappers/EasyTaintWrapper.java
@@ -106,9 +106,8 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 	 * assumes that all classes are included and get wrapped. However, only the
 	 * methods in the given map create new taints
 	 * 
-	 * @param classList
-	 *            The method for which to create new taints. This is a mapping from
-	 *            class names to sets of subsignatures.
+	 * @param classList The method for which to create new taints. This is a mapping
+	 *                  from class names to sets of subsignatures.
 	 */
 	public EasyTaintWrapper(Map<String, Set<String>> classList) {
 		this(classList, new HashMap<String, Set<String>>(), new HashMap<String, Set<String>>(), new HashSet<String>());
@@ -192,8 +191,7 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 		// If the callee is a phantom class or has no body, we pass on the taint
 		if (method.isPhantom() || !method.hasActiveBody()) {
 			// Exception: Tainted value is overwritten
-			if (!(!taintedPath.isStaticFieldRef()
-					&& stmt instanceof DefinitionStmt
+			if (!(!taintedPath.isStaticFieldRef() && stmt instanceof DefinitionStmt
 					&& ((DefinitionStmt) stmt).getLeftOp() == taintedPath.getPlainValue()))
 				taints.add(taintedPath);
 		}
@@ -211,8 +209,7 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 
 		// We need to handle some API calls explicitly as they do not really fit
 		// the model of our rules
-		if (!taintedPath.isEmpty()
-				&& method.getDeclaringClass().getName().equals("java.lang.String")
+		if (!taintedPath.isEmpty() && method.getDeclaringClass().getName().equals("java.lang.String")
 				&& subSig.equals("void getChars(int,int,char[],int)"))
 			return handleStringGetChars(stmt.getInvokeExpr(), taintedPath);
 
@@ -245,7 +242,8 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 					DefinitionStmt def = (DefinitionStmt) stmt;
 
 					// Check for exclusions
-					if (wrapType != MethodWrapType.Exclude && SystemClassHandler.isTaintVisible(taintedPath, method))
+					if (wrapType != MethodWrapType.Exclude
+							&& SystemClassHandler.v().isTaintVisible(taintedPath, method))
 						taints.add(manager.getAccessPathFactory().createAccessPath(def.getLeftOp(), true));
 				}
 
@@ -302,10 +300,8 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 	 * Explicitly handles String.getChars() which does not really fit our
 	 * declarative model
 	 * 
-	 * @param invokeExpr
-	 *            The invocation of String.getChars()
-	 * @param taintedPath
-	 *            The tainted access path
+	 * @param invokeExpr  The invocation of String.getChars()
+	 * @param taintedPath The tainted access path
 	 * @return The set of new taints to pass on in the taint propagation
 	 */
 	private Set<AccessPath> handleStringGetChars(InvokeExpr invokeExpr, AccessPath taintedPath) {
@@ -321,14 +317,10 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 	 * Checks whether at least one method in the given class is registered in the
 	 * taint wrapper
 	 * 
-	 * @param parentClass
-	 *            The class to check
-	 * @param newTaints
-	 *            Check the list for creating new taints
-	 * @param killTaints
-	 *            Check the list for killing taints
-	 * @param excludeTaints
-	 *            Check the list for excluding taints
+	 * @param parentClass   The class to check
+	 * @param newTaints     Check the list for creating new taints
+	 * @param killTaints    Check the list for killing taints
+	 * @param excludeTaints Check the list for excluding taints
 	 * @return True if at least one method of the given class has been registered
 	 *         with the taint wrapper, otherwise
 	 */
@@ -346,10 +338,8 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 	/**
 	 * Gets the type of action the taint wrapper shall perform on a given method
 	 * 
-	 * @param subSig
-	 *            The subsignature of the method to look for
-	 * @param parentClass
-	 *            The parent class in which to start looking
+	 * @param subSig      The subsignature of the method to look for
+	 * @param parentClass The parent class in which to start looking
 	 * @return The type of action to be performed on the given method
 	 */
 	private MethodWrapType getMethodWrapType(String subSig, SootClass parentClass) {
@@ -397,10 +387,8 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 	 * class/interface and method subsignature. This method does not take the
 	 * hierarchy into account.
 	 * 
-	 * @param className
-	 *            The name of the class to look for
-	 * @param subSignature
-	 *            The method subsignature to look for
+	 * @param className    The name of the class to look for
+	 * @param subSignature The method subsignature to look for
 	 * @return The type of wrapping if the taint wrapper has been configured with
 	 *         the given class or interface name and method subsignature, otherwise
 	 *         NotRegistered.
@@ -427,10 +415,8 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 	 * Checks whether the taint wrapper has been configured for the given method in
 	 * the given interface or one of its parent interfaces.
 	 * 
-	 * @param subSig
-	 *            The method subsignature to look for
-	 * @param ifc
-	 *            The interface where to start the search
+	 * @param subSig The method subsignature to look for
+	 * @param ifc    The interface where to start the search
 	 * @return The configured type of wrapping if the given method is implemented in
 	 *         the given interface or one of its super interfaces, otherwise
 	 *         NotRegistered
@@ -439,9 +425,7 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 		if (ifc.isPhantom())
 			return getMethodWrapTypeDirect(ifc.getName(), subSig);
 
-		assert ifc.isInterface() : "Class "
-				+ ifc.getName()
-				+ " is not an interface, though returned "
+		assert ifc.isInterface() : "Class " + ifc.getName() + " is not an interface, though returned "
 				+ "by getInterfaces().";
 		for (SootClass pifc : Scene.v().getActiveHierarchy().getSuperinterfacesOfIncluding(ifc)) {
 			MethodWrapType wt = getMethodWrapTypeDirect(pifc.getName(), subSig);
@@ -476,9 +460,9 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 	 * "a = x.foo()" to be tainted if the base object is tainted, even if the
 	 * respective method is not in the data file.
 	 * 
-	 * @param aggressiveMode
-	 *            True if return values shall always be tainted if the base object
-	 *            on which the method is invoked is tainted, otherwise false
+	 * @param aggressiveMode True if return values shall always be tainted if the
+	 *                       base object on which the method is invoked is tainted,
+	 *                       otherwise false
 	 */
 	public void setAggressiveMode(boolean aggressiveMode) {
 		this.aggressiveMode = aggressiveMode;
@@ -499,9 +483,9 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 	 * Sets whether the equals() and hashCode() methods shall always be modeled,
 	 * regardless of the target type.
 	 * 
-	 * @param alwaysModelEqualsHashCode
-	 *            True if the equals() and hashCode() methods shall always be
-	 *            modeled, regardless of the target type, otherwise false
+	 * @param alwaysModelEqualsHashCode True if the equals() and hashCode() methods
+	 *                                  shall always be modeled, regardless of the
+	 *                                  target type, otherwise false
 	 */
 	public void setAlwaysModelEqualsHashCode(boolean alwaysModelEqualsHashCode) {
 		this.alwaysModelEqualsHashCode = alwaysModelEqualsHashCode;
@@ -522,8 +506,7 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 	 * Registers a prefix of class names to be included when generating taints. All
 	 * classes whose names don't start with a registered prefix will be skipped.
 	 * 
-	 * @param prefix
-	 *            The prefix to register
+	 * @param prefix The prefix to register
 	 */
 	public void addIncludePrefix(String prefix) {
 		this.includeList.add(prefix);
@@ -532,10 +515,8 @@ public class EasyTaintWrapper extends AbstractTaintWrapper implements Cloneable
 	/**
 	 * Adds a method to which the taint wrapping rules shall apply
 	 * 
-	 * @param className
-	 *            The class containing the method to be wrapped
-	 * @param subSignature
-	 *            The subsignature of the method to be wrapped
+	 * @param className    The class containing the method to be wrapped
+	 * @param subSignature The subsignature of the method to be wrapped
 	 */
 	public void addMethodForWrapping(String className, String subSignature) {
 		Set<String> methods = this.classList.get(className);
diff --git a/soot-infoflow/src/soot/jimple/infoflow/util/ExtendedAtomicInteger.java b/soot-infoflow/src/soot/jimple/infoflow/util/ExtendedAtomicInteger.java
new file mode 100644
index 0000000..cb4088e
--- /dev/null
+++ b/soot-infoflow/src/soot/jimple/infoflow/util/ExtendedAtomicInteger.java
@@ -0,0 +1,39 @@
+package soot.jimple.infoflow.util;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Extended version of the {@link AtomicInteger} class
+ * 
+ * @author Steven Arzt
+ *
+ */
+public class ExtendedAtomicInteger extends AtomicInteger {
+
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = -365647246646024478L;
+
+	public ExtendedAtomicInteger() {
+		super();
+	}
+
+	public ExtendedAtomicInteger(int initialValue) {
+		super(initialValue);
+	}
+
+	/**
+	 * Atomically subtracts the given value from the current value
+	 * 
+	 * @param diff The value to subtract from the current value
+	 */
+	public void subtract(int diff) {
+		while (true) {
+			int curValue = get();
+			if (compareAndSet(curValue, curValue - diff))
+				break;
+		}
+	}
+
+}
diff --git a/soot-infoflow/src/soot/jimple/infoflow/util/SystemClassHandler.java b/soot-infoflow/src/soot/jimple/infoflow/util/SystemClassHandler.java
index d9f3fcf..c0733ee 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/util/SystemClassHandler.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/util/SystemClassHandler.java
@@ -1,6 +1,7 @@
 package soot.jimple.infoflow.util;
 
 import soot.RefType;
+import soot.SootClass;
 import soot.SootField;
 import soot.SootMethod;
 import soot.Type;
@@ -13,29 +14,61 @@ import soot.jimple.infoflow.data.AccessPath;
  */
 public class SystemClassHandler {
 
+	private static SystemClassHandler instance;
+
+	private boolean excludeSystemComponents = true;
+
+	/**
+	 * Gets the global system class handler instance
+	 *
+	 * @return The global system class handler instance
+	 */
+	public static SystemClassHandler v() {
+		if (instance == null)
+			instance = new SystemClassHandler();
+		return instance;
+	}
+
+	/**
+	 * Overwrites the global system class handler instance
+	 *
+	 * @param instance The new the global system class handler instance
+	 */
+	public static void setInstance(SystemClassHandler instance) {
+		SystemClassHandler.instance = instance;
+	}
+
+	/**
+	 * Checks whether the given class belongs to a system package
+	 *
+	 * @param clazz The class to check
+	 * @return True if the given class belongs to a system package, otherwise false
+	 */
+	public boolean isClassInSystemPackage(SootClass clazz) {
+		return clazz != null && isClassInSystemPackage(clazz.getName());
+	}
+
 	/**
 	 * Checks whether the given class name belongs to a system package
 	 * 
-	 * @param className
-	 *            The class name to check
+	 * @param className The class name to check
 	 * @return True if the given class name belongs to a system package, otherwise
 	 *         false
 	 */
-	public static boolean isClassInSystemPackage(String className) {
-		return className.startsWith("android.") || className.startsWith("java.") || className.startsWith("javax.")
+	public boolean isClassInSystemPackage(String className) {
+		return (className.startsWith("android.") || className.startsWith("java.") || className.startsWith("javax.")
 				|| className.startsWith("sun.") || className.startsWith("org.omg.")
-				|| className.startsWith("org.w3c.dom.") || className.startsWith("com.google.")
-				|| className.startsWith("com.android.");
+				|| className.startsWith("org.w3c.dom.")) // || className.startsWith("com.google.") || className.startsWith("com.android."))
+				&& this.excludeSystemComponents;
 	}
 
 	/**
 	 * Checks whether the type belongs to a system package
 	 * 
-	 * @param type
-	 *            The type to check
+	 * @param type The type to check
 	 * @return True if the given type belongs to a system package, otherwise false
 	 */
-	public static boolean isClassInSystemPackage(Type type) {
+	public boolean isClassInSystemPackage(Type type) {
 		if (type instanceof RefType)
 			return isClassInSystemPackage(((RefType) type).getSootClass().getName());
 		return false;
@@ -47,13 +80,11 @@ public class SystemClassHandler {
 	 * happens. The system class cannot access or know about user-code fields. This
 	 * leaves reflection aside, but we don't support reflection anyway.
 	 * 
-	 * @param taintedPath
-	 *            The access path of the incoming taint
-	 * @param method
-	 *            The method that gets called
+	 * @param taintedPath The access path of the incoming taint
+	 * @param method      The method that gets called
 	 * @return True if the given taint is visible to the callee, otherwise false
 	 */
-	public static boolean isTaintVisible(AccessPath taintedPath, SootMethod method) {
+	public boolean isTaintVisible(AccessPath taintedPath, SootMethod method) {
 		// If we don't know anything about the tainted access path, we have to
 		// conservatively assume that it's visible in the calllee
 		if (taintedPath == null)
@@ -64,16 +95,15 @@ public class SystemClassHandler {
 			return true;
 
 		// User code can cast objects to arbitrary user and system types
-		if (!SystemClassHandler.isClassInSystemPackage(method.getDeclaringClass().getName()))
+		if (!isClassInSystemPackage(method.getDeclaringClass().getName()))
 			return true;
 
 		// Check whether we have a system-defined field followed by a user-defined field
 		// in our access path
-		boolean hasSystemType = taintedPath.getBaseType() != null
-				&& SystemClassHandler.isClassInSystemPackage(taintedPath.getBaseType());
+		boolean hasSystemType = taintedPath.getBaseType() != null && isClassInSystemPackage(taintedPath.getBaseType());
 		for (SootField fld : taintedPath.getFields()) {
-			boolean curFieldIsSystem = SystemClassHandler.isClassInSystemPackage(fld.getType());
-			if (SystemClassHandler.isClassInSystemPackage(fld.getDeclaringClass().getType()))
+			boolean curFieldIsSystem = isClassInSystemPackage(fld.getType());
+			if (isClassInSystemPackage(fld.getDeclaringClass().getType()))
 				curFieldIsSystem = true;
 
 			if (curFieldIsSystem) {
@@ -89,4 +119,15 @@ public class SystemClassHandler {
 		return true;
 	}
 
+	/**
+	 * Sets whether components in system or framework-related packages shall be
+	 * excluded from the analysis
+	 *
+	 * @param excludeSystemComponents True to exclude components in system packages
+	 *                                from the analysis, false otherwise
+	 */
+	public void setExcludeSystemComponents(boolean excludeSystemComponents) {
+		this.excludeSystemComponents = excludeSystemComponents;
+	}
+
 }
diff --git a/soot-infoflow/src/soot/jimple/infoflow/util/TypeUtils.java b/soot-infoflow/src/soot/jimple/infoflow/util/TypeUtils.java
index 030d1eb..4f7cf98 100644
--- a/soot-infoflow/src/soot/jimple/infoflow/util/TypeUtils.java
+++ b/soot-infoflow/src/soot/jimple/infoflow/util/TypeUtils.java
@@ -5,6 +5,7 @@ import soot.BooleanType;
 import soot.ByteType;
 import soot.CharType;
 import soot.DoubleType;
+import soot.FastHierarchy;
 import soot.FloatType;
 import soot.IntType;
 import soot.LongType;
@@ -34,8 +35,7 @@ public class TypeUtils {
 	/**
 	 * Checks whether the given type is a string
 	 * 
-	 * @param tp
-	 *            The type of check
+	 * @param tp The type of check
 	 * @return True if the given type is a string, otherwise false
 	 */
 	public static boolean isStringType(Type tp) {
@@ -49,8 +49,7 @@ public class TypeUtils {
 	 * Checks whether the given type is java.lang.Object, java.io.Serializable, or
 	 * java.lang.Cloneable.
 	 * 
-	 * @param tp
-	 *            The type to check
+	 * @param tp The type to check
 	 * @return True if the given type is one of the three "object-like" types,
 	 *         otherwise false
 	 */
@@ -59,18 +58,17 @@ public class TypeUtils {
 			return false;
 
 		RefType rt = (RefType) tp;
-		return rt.equals(Scene.v().getObjectType()) || rt.getSootClass().getName().equals("java.io.Serializable")
-				|| rt.getSootClass().getName().equals("java.lang.Cloneable");
+		final String className = rt.getSootClass().getName();
+		return className.equals("java.lang.Object") || className.equals("java.io.Serializable")
+				|| className.equals("java.lang.Cloneable");
 	}
 
 	/**
 	 * Checks whether the given source type can be cast to the given destination
 	 * type
 	 * 
-	 * @param destType
-	 *            The destination type to which to cast
-	 * @param sourceType
-	 *            The source type from which to cast
+	 * @param destType   The destination type to which to cast
+	 * @param sourceType The source type from which to cast
 	 * @return True if the given types are cast-compatible, otherwise false
 	 */
 	public boolean checkCast(Type destType, Type sourceType) {
@@ -111,10 +109,8 @@ public class TypeUtils {
 	 * Checks whether the type of the given taint can be cast to the given target
 	 * type
 	 * 
-	 * @param accessPath
-	 *            The access path of the taint to be cast
-	 * @param type
-	 *            The target type to which to cast the taint
+	 * @param accessPath The access path of the taint to be cast
+	 * @param type       The target type to which to cast the taint
 	 * @return True if the cast is possible, otherwise false
 	 */
 	public boolean checkCast(AccessPath accessPath, Type type) {
@@ -179,13 +175,13 @@ public class TypeUtils {
 	 * Gets the more precise one of the two given types. If there is no ordering
 	 * (i.e., the two types are not cast-compatible) null is returned.
 	 * 
-	 * @param tp1
-	 *            The first type
-	 * @param tp2
-	 *            The second type
+	 * @param tp1 The first type
+	 * @param tp2 The second type
 	 * @return The more precise one of the two given types
 	 */
 	public static Type getMorePreciseType(Type tp1, Type tp2) {
+		final FastHierarchy fastHierarchy = Scene.v().getOrMakeFastHierarchy();
+
 		if (tp1 == null)
 			return tp2;
 		else if (tp2 == null)
@@ -198,9 +194,9 @@ public class TypeUtils {
 			return tp1;
 		else if (tp1 instanceof PrimType && tp2 instanceof PrimType)
 			return tp1; // arbitrary choice
-		else if (Scene.v().getFastHierarchy().canStoreType(tp2, tp1))
+		else if (fastHierarchy.canStoreType(tp2, tp1))
 			return tp2;
-		else if (Scene.v().getFastHierarchy().canStoreType(tp1, tp2))
+		else if (fastHierarchy.canStoreType(tp1, tp2))
 			return tp1;
 		else {
 			// If one type is an array type and the other one is the base type,
@@ -228,10 +224,8 @@ public class TypeUtils {
 	/**
 	 * Gets the more precise one of the two given types
 	 * 
-	 * @param tp1
-	 *            The first type
-	 * @param tp2
-	 *            The second type
+	 * @param tp1 The first type
+	 * @param tp2 The second type
 	 * @return The more precise one of the two given types
 	 */
 	public static String getMorePreciseType(String tp1, String tp2) {
@@ -242,8 +236,7 @@ public class TypeUtils {
 	/**
 	 * Creates a Soot Type from the given string
 	 * 
-	 * @param type
-	 *            A string representing a Soot type
+	 * @param type A string representing a Soot type
 	 * @return The Soot Type corresponding to the given string
 	 */
 	public static Type getTypeFromString(String type) {
@@ -293,10 +286,8 @@ public class TypeUtils {
 	 * Builds a new array of the given type if it is a base type or increments the
 	 * dimensions of the given array by 1 otherwise.
 	 * 
-	 * @param type
-	 *            The base type or incoming array
-	 * @param arrayType
-	 *            The declared type of the array
+	 * @param type      The base type or incoming array
+	 * @param arrayType The declared type of the array
 	 * @return The resulting array
 	 */
 	public static Type buildArrayOrAddDimension(Type type, Type arrayType) {
diff --git a/soot-infoflow/test/soot/jimple/infoflow/test/ExceptionTestCode.java b/soot-infoflow/test/soot/jimple/infoflow/test/ExceptionTestCode.java
index fc069de..833f443 100644
--- a/soot-infoflow/test/soot/jimple/infoflow/test/ExceptionTestCode.java
+++ b/soot-infoflow/test/soot/jimple/infoflow/test/ExceptionTestCode.java
@@ -9,13 +9,12 @@ import soot.jimple.infoflow.test.android.TelephonyManager;
  * @author Steven Arzt
  */
 public class ExceptionTestCode {
-	
+
 	public void exceptionControlFlowTest1() {
 		String tainted = TelephonyManager.getDeviceId();
 		try {
 			doThrowException();
-		}
-		catch (RuntimeException ex) {
+		} catch (RuntimeException ex) {
 			ConnectionManager cm = new ConnectionManager();
 			cm.publish(tainted);
 			System.out.println(ex);
@@ -25,48 +24,45 @@ public class ExceptionTestCode {
 	private void doThrowException() {
 		throw new RuntimeException("foo");
 	}
-	
+
 	public void exceptionControlFlowTest2() {
 		try {
 			String s = getConstantStringAndThrow();
 			System.out.println(s);
-		}
-		catch (Exception ex) {
+		} catch (Exception ex) {
 			ConnectionManager cm = new ConnectionManager();
 			cm.publish(TelephonyManager.getDeviceId());
 			System.out.println(ex);
 		}
 	}
-	
+
 	private String getConstantStringAndThrow() {
 		throw new RuntimeException("foo");
 	}
-	
+
 	public void exceptionControlFlowTest3() {
 		String tainted = TelephonyManager.getDeviceId();
 		try {
 			tainted = doThrowImplicitException();
-		}
-		catch (ArrayIndexOutOfBoundsException ex) {
+		} catch (ArrayIndexOutOfBoundsException ex) {
 			ConnectionManager cm = new ConnectionManager();
 			cm.publish(tainted);
 			System.out.println(ex);
 		}
 		System.out.println(tainted);
 	}
-	
+
 	private String doThrowImplicitException() {
 		String[] foo = new String[2];
 		foo[10] = "Hello World";
 		return "foo";
 	}
-	
+
 	public void exceptionDataFlowTest1() {
 		String tainted = TelephonyManager.getDeviceId();
 		try {
 			throwData(tainted);
-		}
-		catch (Exception ex) {
+		} catch (Exception ex) {
 			ConnectionManager cm = new ConnectionManager();
 			cm.publish(ex.getMessage());
 		}
@@ -75,34 +71,32 @@ public class ExceptionTestCode {
 	private void throwData(String tainted) {
 		throw new RuntimeException(tainted);
 	}
-	
+
 	public void exceptionDataFlowTest2() {
 		String tainted = TelephonyManager.getDeviceId();
 		try {
 			throw new RuntimeException(tainted);
-		}
-		catch (Exception ex) {
+		} catch (Exception ex) {
 			ConnectionManager cm = new ConnectionManager();
 			cm.publish(ex.getMessage());
 		}
 	}
-	
+
 	public void disabledExceptionTest() {
 		String imei = TelephonyManager.getDeviceId();
 		try {
 			throw new RuntimeException();
-		}
-		catch (Exception ex) {
+		} catch (Exception ex) {
 			ex.printStackTrace();
 		}
 		ConnectionManager cm = new ConnectionManager();
-		cm.publish(imei);		
+		cm.publish(imei);
 	}
-	
+
 	private class Data {
 		public String imei;
 	}
-	
+
 	public void callMethodParamReturnTest1() {
 		Data data = new Data();
 		data.imei = TelephonyManager.getDeviceId();
@@ -114,19 +108,18 @@ public class ExceptionTestCode {
 	private Data setAndReturn1(Data data) {
 		String s = data.imei;
 		data.imei = "";
-		
+
 		Data d = new Data();
 		d.imei = s;
 		return d;
 	}
-	
+
 	public void callMethodParamReturnTest2() {
 		Data data = new Data();
 		data.imei = TelephonyManager.getDeviceId();
 		try {
 			data = setAndReturn2(data);
-		}
-		finally {
+		} finally {
 			ConnectionManager cm = new ConnectionManager();
 			cm.publish(data.imei);
 		}
@@ -135,10 +128,10 @@ public class ExceptionTestCode {
 	private Data setAndReturn2(Data data) {
 		String s = data.imei;
 		data.imei = "";
-		
+
 		// cause an exception
 		data.imei.substring(-10, -1);
-		
+
 		Data d = new Data();
 		d.imei = s;
 		return d;
@@ -149,8 +142,7 @@ public class ExceptionTestCode {
 		data.imei = "";
 		try {
 			data = setAndReturn2b(data);
-		}
-		finally {
+		} finally {
 			ConnectionManager cm = new ConnectionManager();
 			cm.publish(data.imei);
 		}
@@ -159,10 +151,10 @@ public class ExceptionTestCode {
 	private Data setAndReturn2b(Data data) {
 		String s = data.imei;
 		data.imei = TelephonyManager.getDeviceId();
-		
+
 		// cause an exception
 		data.imei.substring(-10, -1);
-		
+
 		Data d = new Data();
 		d.imei = s;
 		return d;
@@ -173,8 +165,7 @@ public class ExceptionTestCode {
 		data.imei = TelephonyManager.getDeviceId();
 		try {
 			data = setAndReturn3(data);
-		}
-		finally {
+		} finally {
 			ConnectionManager cm = new ConnectionManager();
 			cm.publish(data.imei);
 		}
@@ -182,15 +173,43 @@ public class ExceptionTestCode {
 
 	private Data setAndReturn3(Data data) {
 		String s = data.imei;
-		
+
 		// cause an exception
 		data.imei.substring(-10, -1);
 
 		data.imei = "";
-				
+
 		Data d = new Data();
 		d.imei = s;
 		return d;
 	}
 
+	public void npeTest1() {
+		String s = TelephonyManager.getDeviceId();
+		Object nnnull = null;
+		try {
+			bar(nnnull);
+		} catch (Throwable t) {
+			ConnectionManager cm = new ConnectionManager();
+			cm.publish(s);
+		}
+	}
+
+	private String targetString;
+
+	public void npeTest2() {
+		Object nnnull = null;
+		try {
+			bar(nnnull);
+		} catch (Throwable t) {
+			ConnectionManager cm = new ConnectionManager();
+			cm.publish(targetString);
+		}
+	}
+
+	private void bar(Object nnnull) {
+		targetString = TelephonyManager.getDeviceId();
+		nnnull.toString(); // will throw NPE
+	}
+
 }
diff --git a/soot-infoflow/test/soot/jimple/infoflow/test/MultiTestCode.java b/soot-infoflow/test/soot/jimple/infoflow/test/MultiTestCode.java
index 89fdd92..c8c2cce 100644
--- a/soot-infoflow/test/soot/jimple/infoflow/test/MultiTestCode.java
+++ b/soot-infoflow/test/soot/jimple/infoflow/test/MultiTestCode.java
@@ -10,33 +10,35 @@
  ******************************************************************************/
 package soot.jimple.infoflow.test;
 
+import java.io.ByteArrayOutputStream;
+
 import soot.jimple.infoflow.test.android.AccountManager;
 import soot.jimple.infoflow.test.android.ConnectionManager;
 import soot.jimple.infoflow.test.android.TelephonyManager;
 
 public class MultiTestCode {
-	
-	public void multiSourceCode(){
+
+	public void multiSourceCode() {
 		String tainted = TelephonyManager.getDeviceId();
 		AccountManager am = new AccountManager();
 		String pwd = am.getPassword();
-				
+
 		ConnectionManager cm = new ConnectionManager();
 		cm.publish(tainted);
 		doSomething(pwd);
 	}
-	
+
 	private void doSomething(String msg) {
 		ConnectionManager cm = new ConnectionManager();
 		cm.publish(msg);
 	}
-	
+
 	private String pwd;
 
-	public void multiSourceCode2(){
+	public void multiSourceCode2() {
 		AccountManager am = new AccountManager();
 		this.pwd = am.getPassword();
-				
+
 		String tainted = TelephonyManager.getDeviceId();
 
 		ConnectionManager cm = new ConnectionManager();
@@ -49,10 +51,10 @@ public class MultiTestCode {
 		cm.publish(this.pwd);
 	}
 
-	public void ifPathTestCode1(){
+	public void ifPathTestCode1() {
 		AccountManager am = new AccountManager();
 		String pwd = am.getPassword();
-		
+
 		String foo = "";
 		String bar = "";
 		if (pwd.length() > 0)
@@ -64,10 +66,10 @@ public class MultiTestCode {
 		cm.publish(bar);
 	}
 
-	public void ifPathTestCode2(){
+	public void ifPathTestCode2() {
 		AccountManager am = new AccountManager();
 		String pwd = am.getPassword();
-		
+
 		String foo = "";
 		if (pwd.length() > 0)
 			foo = pwd;
@@ -75,10 +77,10 @@ public class MultiTestCode {
 		cm.publish(foo);
 	}
 
-	public void ifPathTestCode3(){
+	public void ifPathTestCode3() {
 		AccountManager am = new AccountManager();
 		String pwd = am.getPassword();
-		
+
 		String foo = pwd;
 		if (pwd.length() > 0)
 			foo = "";
@@ -86,11 +88,11 @@ public class MultiTestCode {
 		cm.publish(foo);
 	}
 
-	public void ifPathTestCode4(){
+	public void ifPathTestCode4() {
 		AccountManager am = new AccountManager();
 		String pwd = am.getPassword();
 		String bar = am.getPassword();
-		
+
 		String foo = pwd;
 		if (pwd.length() > 0)
 			foo = bar;
@@ -98,12 +100,12 @@ public class MultiTestCode {
 		cm.publish(foo);
 	}
 
-	public void loopPathTestCode1(){
+	public void loopPathTestCode1() {
 		AccountManager am = new AccountManager();
-		String pwd = am.getPassword();	
+		String pwd = am.getPassword();
 		sendPwd(pwd, 5);
 	}
-	
+
 	private void sendPwd(String pwd, int cnt) {
 		ConnectionManager cm = new ConnectionManager();
 		cm.publish(pwd);
@@ -111,18 +113,18 @@ public class MultiTestCode {
 			sendPwd(pwd, cnt - 1);
 	}
 
-	public void overwriteTestCode1(){
+	public void overwriteTestCode1() {
 		AccountManager am = new AccountManager();
 		String pwd = am.getPassword();
 		System.out.println(pwd);
-		
+
 		pwd = new String("");
-		
+
 		ConnectionManager cm = new ConnectionManager();
 		cm.publish(pwd);
 	}
-	
-	public void hashTestCode1(){
+
+	public void hashTestCode1() {
 		AccountManager am = new AccountManager();
 		int foo = am.getPassword().hashCode();
 
@@ -130,37 +132,37 @@ public class MultiTestCode {
 		cm.publish(foo);
 	}
 
-	public void shiftTestCode1(){
+	public void shiftTestCode1() {
 		AccountManager am = new AccountManager();
 		int foo = am.getPassword().hashCode();
 
 		ConnectionManager cm = new ConnectionManager();
 		cm.publish(foo << 32);
 	}
-	
+
 	public void intMultiTest() {
 		int imei = TelephonyManager.getIMEI();
 		int imsi = TelephonyManager.getIMSI();
-		
+
 		ConnectionManager cm = new ConnectionManager();
 		cm.publish(imei + imsi);
 	}
-	
+
 	int intField = 0;
 
 	public void intMultiTest2() {
 		int imei = TelephonyManager.getIMEI();
 		int imsi = TelephonyManager.getIMSI();
 		intField = imei + imsi;
-		
+
 		ConnectionManager cm = new ConnectionManager();
 		cm.publish(intField);
 	}
-	
+
 	private String id(String s) {
 		return s;
 	}
-	
+
 	public void sameSourceMultiTest1() {
 		String[] data = new String[2];
 		data[0] = id(TelephonyManager.getDeviceId());
@@ -169,4 +171,13 @@ public class MultiTestCode {
 		cm.publish(data[0]);
 	}
 
+	public void multiSinkTest1() {
+		ByteArrayOutputStream outbytes = new ByteArrayOutputStream();
+		byte[] senbytes = outbytes.toByteArray(); // source
+		String senstr = new String(senbytes);
+		ConnectionManager cm = new ConnectionManager();
+		cm.publish("a" + new String(senbytes)); // sink1
+		cm.publish("a" + senstr); // sink2
+	}
+
 }
diff --git a/soot-infoflow/test/soot/jimple/infoflow/test/TypeTestCode.java b/soot-infoflow/test/soot/jimple/infoflow/test/TypeTestCode.java
index 2254b0d..64450a8 100644
--- a/soot-infoflow/test/soot/jimple/infoflow/test/TypeTestCode.java
+++ b/soot-infoflow/test/soot/jimple/infoflow/test/TypeTestCode.java
@@ -430,7 +430,34 @@ public class TypeTestCode {
 		b.arr[1] = new String[] { TelephonyManager.getDeviceId() };
 
 		ConnectionManager cm = new ConnectionManager();
-		cm.publish(((String[]) d.arr)[0]);
+		cm.publish((String) d.arr[0]);
+	}
+
+	public void aliasTypeTest2() {
+		X b = new X();
+		b.arr = new Object[2];
+		X c = new X();
+
+		doAlias(b, c);
+		b.arr[0] = TelephonyManager.getDeviceId();
+
+		ConnectionManager cm = new ConnectionManager();
+		cm.publish((String) c.arr[0]);
+	}
+
+	public void aliasTypeTest3() {
+		X b = new X();
+		b.arr = new Object[2];
+		X c = new X();
+
+		doAlias(b, c);
+		b.arr[0] = TelephonyManager.getDeviceId();
+
+		X d = new X();
+		d.arr = c.arr;
+
+		ConnectionManager cm = new ConnectionManager();
+		cm.publish((String) d.arr[0]);
 	}
 
 	private void doAlias(X b, X c) {
diff --git a/soot-infoflow/test/soot/jimple/infoflow/test/junit/ExceptionTests.java b/soot-infoflow/test/soot/jimple/infoflow/test/junit/ExceptionTests.java
index edca01f..8ef7eaf 100644
--- a/soot-infoflow/test/soot/jimple/infoflow/test/junit/ExceptionTests.java
+++ b/soot-infoflow/test/soot/jimple/infoflow/test/junit/ExceptionTests.java
@@ -148,4 +148,22 @@ public class ExceptionTests extends JUnitTests {
 		checkInfoflow(infoflow, 2);
 	}
 
+	@Test
+	public void npeTest1() {
+		IInfoflow infoflow = initInfoflow();
+		List<String> epoints = new ArrayList<String>();
+		epoints.add("<soot.jimple.infoflow.test.ExceptionTestCode: void npeTest1()>");
+		infoflow.computeInfoflow(appPath, libPath, epoints, sources, sinks);
+		checkInfoflow(infoflow, 1);
+	}
+
+	@Test
+	public void npeTest2() {
+		IInfoflow infoflow = initInfoflow();
+		List<String> epoints = new ArrayList<String>();
+		epoints.add("<soot.jimple.infoflow.test.ExceptionTestCode: void npeTest2()>");
+		infoflow.computeInfoflow(appPath, libPath, epoints, sources, sinks);
+		checkInfoflow(infoflow, 1);
+	}
+
 }
diff --git a/soot-infoflow/test/soot/jimple/infoflow/test/junit/JUnitTests.java b/soot-infoflow/test/soot/jimple/infoflow/test/junit/JUnitTests.java
index 1804821..2b8108c 100644
--- a/soot-infoflow/test/soot/jimple/infoflow/test/junit/JUnitTests.java
+++ b/soot-infoflow/test/soot/jimple/infoflow/test/junit/JUnitTests.java
@@ -132,6 +132,7 @@ public abstract class JUnitTests {
 
 	protected IInfoflow initInfoflow(boolean useTaintWrapper) {
 		Infoflow result = new Infoflow("", false, null);
+		result.setThrowExceptions(true);
 		ConfigForTest testConfig = new ConfigForTest();
 		result.setSootConfig(testConfig);
 		if (useTaintWrapper) {
diff --git a/soot-infoflow/test/soot/jimple/infoflow/test/junit/MemoryWatcherTest.java b/soot-infoflow/test/soot/jimple/infoflow/test/junit/MemoryWatcherTest.java
new file mode 100644
index 0000000..6c60c69
--- /dev/null
+++ b/soot-infoflow/test/soot/jimple/infoflow/test/junit/MemoryWatcherTest.java
@@ -0,0 +1,74 @@
+package soot.jimple.infoflow.test.junit;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import soot.jimple.infoflow.memory.MemoryWarningSystem;
+import soot.jimple.infoflow.memory.MemoryWarningSystem.OnMemoryThresholdReached;
+
+public class MemoryWatcherTest {
+	private static final Logger logger = LoggerFactory.getLogger(MemoryWatcherTest.class);
+
+	private static final int MEMORY_STEP_SMALL = 1024 * 2;
+	private static final int MEMORY_STEP_BIG = 1024 * 1024 * 100;
+	List<byte[]> memoryLeak = new LinkedList<>();
+
+	double[] thresholds = new double[] { 0.1, 0.3, 0.5, 0.8 };
+
+	boolean[] wsReached = new boolean[thresholds.length];
+
+	String fail;
+
+	@Test
+	public void runMemoryWatcherTest() {
+		try {
+			MemoryWarningSystem[] ws = new MemoryWarningSystem[thresholds.length];
+			for (int i = 0; i < thresholds.length; i++) {
+				final int current = i;
+				ws[i] = new MemoryWarningSystem();
+				ws[i].setWarningThreshold(thresholds[i]);
+				ws[i].addListener(new OnMemoryThresholdReached() {
+
+					@Override
+					public void onThresholdReached(long usedMemory, long maxMemory) {
+						logger.info("Threshold reached: " + thresholds[current] + " with " + usedMemory);
+						wsReached[current] = true;
+						for (int i = current + 1; i < wsReached.length; i++) {
+							if (wsReached[i])
+								fail = "Threshold for " + i + " was reached before " + current + ", although threshold "
+										+ thresholds[current] + " < " + thresholds[i];
+						}
+					}
+				});
+			}
+			while (!allHandlersCalled()) {
+				leakMemory();
+			}
+		} finally {
+			memoryLeak.clear();
+			if (fail != null)
+				Assert.fail(fail);
+		}
+	}
+
+	private void leakMemory() {
+		for (long i = 0; i < MEMORY_STEP_BIG; i += MEMORY_STEP_SMALL)
+			memoryLeak.add(new byte[MEMORY_STEP_SMALL]);
+		long used = MemoryWarningSystem.findTenuredGenPool().getUsage().getUsed();
+		logger.info("Leaking " + (memoryLeak.size() * (long) MEMORY_STEP_SMALL / 1024D / 1024D)
+				+ " MiB, in tenured gen pool " + (used / 1024D / 1024D) + " MiB");
+
+	}
+
+	private boolean allHandlersCalled() {
+		for (boolean b : wsReached)
+			if (!b)
+				return false;
+		return true;
+	}
+}
diff --git a/soot-infoflow/test/soot/jimple/infoflow/test/junit/MultiTest.java b/soot-infoflow/test/soot/jimple/infoflow/test/junit/MultiTest.java
index 6580505..2d786de 100644
--- a/soot-infoflow/test/soot/jimple/infoflow/test/junit/MultiTest.java
+++ b/soot-infoflow/test/soot/jimple/infoflow/test/junit/MultiTest.java
@@ -17,6 +17,7 @@ import org.junit.Assert;
 import org.junit.Test;
 
 import soot.jimple.infoflow.IInfoflow;
+import soot.jimple.infoflow.results.InfoflowResults;
 
 /**
  * contain various tests with more than one source, conditional statements,
@@ -189,4 +190,24 @@ public class MultiTest extends JUnitTests {
 		checkInfoflow(infoflow, 1);
 	}
 
+	@Test(timeout = 300000)
+	public void multiSinkTest1() {
+		IInfoflow infoflow = initInfoflow();
+		List<String> epoints = new ArrayList<String>();
+		epoints.add("<soot.jimple.infoflow.test.MultiTestCode: void multiSinkTest1()>");
+
+		final String streamSource = "<java.io.ByteArrayOutputStream: byte[] toByteArray()>";
+		final String publishSink = "<soot.jimple.infoflow.test.android.ConnectionManager: void publish(java.lang.String)>";
+
+		List<String> testSources = new ArrayList<>(sources);
+		testSources.add(streamSource);
+
+		infoflow.computeInfoflow(appPath, libPath, epoints, testSources, sinks);
+		InfoflowResults results = infoflow.getResults();
+
+		Assert.assertNotNull(results);
+		Assert.assertTrue(results.isPathBetweenMethods(publishSink, streamSource));
+		Assert.assertEquals(2, results.numConnections());
+	}
+
 }
diff --git a/soot-infoflow/test/soot/jimple/infoflow/test/junit/StringTests.java b/soot-infoflow/test/soot/jimple/infoflow/test/junit/StringTests.java
index aab1f0c..86e434a 100644
--- a/soot-infoflow/test/soot/jimple/infoflow/test/junit/StringTests.java
+++ b/soot-infoflow/test/soot/jimple/infoflow/test/junit/StringTests.java
@@ -289,7 +289,6 @@ public class StringTests extends JUnitTests {
 		epoints.add("<soot.jimple.infoflow.test.StringTestCode: void methodStringConcat()>");
 		infoflow.computeInfoflow(appPath, libPath, epoints, sources, sinks);
 		checkInfoflow(infoflow, 1);
-		assertTrue(infoflow.getResults().isPathBetweenMethods(sink, sourcePwd));
 		assertTrue(infoflow.getResults().isPathBetweenMethods(sink, sourceDeviceId));
 	}
 
diff --git a/soot-infoflow/test/soot/jimple/infoflow/test/junit/TypeTests.java b/soot-infoflow/test/soot/jimple/infoflow/test/junit/TypeTests.java
index 7e41d38..adfcd3e 100644
--- a/soot-infoflow/test/soot/jimple/infoflow/test/junit/TypeTests.java
+++ b/soot-infoflow/test/soot/jimple/infoflow/test/junit/TypeTests.java
@@ -115,7 +115,7 @@ public class TypeTests extends JUnitTests {
 		checkInfoflow(infoflow, 1);
 	}
 
-	@Test // (timeout=300000)
+	@Test(timeout = 300000)
 	public void arrayObjectCastTest3() {
 		IInfoflow infoflow = initInfoflow();
 		List<String> epoints = new ArrayList<String>();
@@ -271,6 +271,26 @@ public class TypeTests extends JUnitTests {
 		Assert.assertTrue((infoflow.getResults().isPathBetweenMethods(sink, sourceDeviceId)));
 	}
 
+	@Test(timeout = 300000)
+	public void aliasTypeTest2() {
+		IInfoflow infoflow = initInfoflow();
+		List<String> epoints = new ArrayList<String>();
+		epoints.add("<soot.jimple.infoflow.test.TypeTestCode: void aliasTypeTest2()>");
+		infoflow.computeInfoflow(appPath, libPath, epoints, sources, sinks);
+		checkInfoflow(infoflow, 1);
+		Assert.assertTrue((infoflow.getResults().isPathBetweenMethods(sink, sourceDeviceId)));
+	}
+
+	@Test // (timeout = 300000)
+	public void aliasTypeTest3() {
+		IInfoflow infoflow = initInfoflow();
+		List<String> epoints = new ArrayList<String>();
+		epoints.add("<soot.jimple.infoflow.test.TypeTestCode: void aliasTypeTest3()>");
+		infoflow.computeInfoflow(appPath, libPath, epoints, sources, sinks);
+		checkInfoflow(infoflow, 1);
+		Assert.assertTrue((infoflow.getResults().isPathBetweenMethods(sink, sourceDeviceId)));
+	}
+
 	@Test(timeout = 300000)
 	public void aliasReturnTest() {
 		IInfoflow infoflow = initInfoflow();
diff --git a/soot-infoflow/test/soot/jimple/infoflow/test/securibench/supportClasses/DummyHttpRequest.java b/soot-infoflow/test/soot/jimple/infoflow/test/securibench/supportClasses/DummyHttpRequest.java
index 117b2bc..d8d6a91 100644
--- a/soot-infoflow/test/soot/jimple/infoflow/test/securibench/supportClasses/DummyHttpRequest.java
+++ b/soot-infoflow/test/soot/jimple/infoflow/test/securibench/supportClasses/DummyHttpRequest.java
@@ -10,408 +10,420 @@
  ******************************************************************************/
 package soot.jimple.infoflow.test.securibench.supportClasses;
 
-import javax.servlet.*;
-import javax.servlet.http.*;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.security.Principal;
-import java.util.*;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.StringTokenizer;
+
+import javax.servlet.AsyncContext;
+import javax.servlet.DispatcherType;
+import javax.servlet.RequestDispatcher;
+import javax.servlet.ServletContext;
+import javax.servlet.ServletInputStream;
+import javax.servlet.ServletRequest;
+import javax.servlet.ServletResponse;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpSession;
+import javax.servlet.http.Part;
 
 public class DummyHttpRequest implements HttpServletRequest {
-    enum count {ONE, TWO}
-
-    ;
-
-    @Override
-    public Object getAttribute(String arg0) {
-        return "";
-    }
-
-    @Override
-    public AsyncContext getAsyncContext() {
-        return null;
-    }
-
-
-    @Override
-    public ServletContext getServletContext() {
-        return null;
-    }
-
-    @Override
-    public AsyncContext startAsync() {
-        return null;
-    }
-
-    @Override
-    public AsyncContext startAsync(ServletRequest servletRequest,
-                                   ServletResponse servletResponse) {
-        return null;
-    }
-
-    @Override
-    public boolean isAsyncSupported() {
-        return true;
-    }
-
-    @Override
-    public boolean isAsyncStarted() {
-        return true;
-    }
-
-    @Override
-    public boolean authenticate(HttpServletResponse response) {
-        return true;
-    }
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    public Enumeration getAttributeNames() {
-
-        return new StringTokenizer("one two");
-    }
-
-    @Override
-    public String getCharacterEncoding() {
-        return "UTF-8";
-    }
-
-    @Override
-    public int getContentLength() {
-        // TODO Auto-generated method stub
-        return 0;
-    }
-
-    @Override
-    public String getContentType() {
-        // TODO Auto-generated method stub
-        return "contenttype";
-    }
-
-    @Override
-    public ServletInputStream getInputStream() throws IOException {
-        // TODO Auto-generated method stub
-        return new DummyServletInputStream();
-    }
-
-    @Override
-    public Locale getLocale() {
-        // TODO Auto-generated method stub
-        return Locale.ENGLISH;
-    }
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    public Enumeration getLocales() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public String getParameter(String arg0) {
-        // TODO Auto-generated method stub
-        return arg0;
-    }
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    public Map getParameterMap() {
-        HashMap<String, String> map = new HashMap<String, String>();
-        map.put("dummy", "dummy");
-        return map;
-    }
-
-    @Override
-    public Part getPart(String name) {
-        return null;
-    }
-
-    @Override
-    public java.util.Collection<Part> getParts() {
-        return null;
-    }
-
-    @Override
-    public void logout() {
-
-    }
-
-    @Override
-    public void login(String user, String pwd) {
-
-    }
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    public Enumeration getParameterNames() {
-        // TODO Auto-generated method stub
-        return new StringTokenizer("parameter names");
-    }
-
-    @Override
-    public String[] getParameterValues(String arg0) {
-        // TODO Auto-generated method stub
-        return new String[]{arg0};
-    }
-
-
-    @Override
-    public String getProtocol() {
-        // TODO Auto-generated method stub
-        return "";
-    }
-
-    @Override
-    public DispatcherType getDispatcherType() {
-        return null;
-    }
-
-
-    @Override
-    public BufferedReader getReader() throws IOException {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public String getRealPath(String arg0) {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public String getRemoteAddr() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public String getRemoteHost() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public RequestDispatcher getRequestDispatcher(String arg0) {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public String getScheme() {
-        // TODO Auto-generated method stub
-        return "";
-    }
-
-    @Override
-    public String getServerName() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public int getServerPort() {
-        // TODO Auto-generated method stub
-        return 0;
-    }
-
-    @Override
-    public boolean isSecure() {
-        // TODO Auto-generated method stub
-        return false;
-    }
-
-    @Override
-    public void removeAttribute(String arg0) {
-        // TODO Auto-generated method stub
-
-    }
-
-    @Override
-    public void setAttribute(String arg0, Object arg1) {
-        // TODO Auto-generated method stub
-
-    }
-
-    @Override
-    public void setCharacterEncoding(String arg0) throws UnsupportedEncodingException {
-        // TODO Auto-generated method stub
-
-    }
-
-    @Override
-    public String getAuthType() {
-        // TODO Auto-generated method stub
-        return "";
-    }
-
-    @Override
-    public String getContextPath() {
-        // TODO Auto-generated method stub
-        return "";
-    }
-
-    @Override
-    public Cookie[] getCookies() {
-        Cookie c = new Cookie("", "");
-        return new Cookie[]{c};
-    }
-
-    @Override
-    public long getDateHeader(String arg0) {
-        // TODO Auto-generated method stub
-        return 0;
-    }
-
-    @Override
-    public String getHeader(String arg0) {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    public Enumeration getHeaderNames() {
-        return new StringTokenizer("secret1 secret2 secret3");
-    }
-
-    @Override
-    @SuppressWarnings("rawtypes")
-    public Enumeration getHeaders(String arg0) {
-        return new StringTokenizer("secret1 secret2 secret3");
-    }
-
-    @Override
-    public int getIntHeader(String arg0) {
-        // TODO Auto-generated method stub
-        return 0;
-    }
-
-    @Override
-    public String getMethod() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public String getPathInfo() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public String getPathTranslated() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public String getQueryString() {
-        // TODO Auto-generated method stub
-        return "";
-    }
-
-    @Override
-    public String getRemoteUser() {
-        // TODO Auto-generated method stub
-        return "";
-    }
-
-    @Override
-    public String getRequestURI() {
-        // TODO Auto-generated method stub
-        return "";
-    }
-
-    @Override
-    public StringBuffer getRequestURL() {
-        // TODO Auto-generated method stub
-        return new StringBuffer("http://");
-    }
-
-    @Override
-    public String getRequestedSessionId() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public String getServletPath() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public HttpSession getSession() {
-        return new DummyHttpSession();
-    }
-
-    @Override
-    public HttpSession getSession(boolean arg0) {
-        // TODO Auto-generated method stub
-        return new DummyHttpSession();
-    }
-
-    @Override
-    public Principal getUserPrincipal() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public boolean isRequestedSessionIdFromCookie() {
-        // TODO Auto-generated method stub
-        return false;
-    }
-
-    @Override
-    public boolean isRequestedSessionIdFromURL() {
-        // TODO Auto-generated method stub
-        return false;
-    }
-
-    @Override
-    public boolean isRequestedSessionIdFromUrl() {
-        // TODO Auto-generated method stub
-        return false;
-    }
-
-    @Override
-    public boolean isRequestedSessionIdValid() {
-        // TODO Auto-generated method stub
-        return false;
-    }
-
-    @Override
-    public boolean isUserInRole(String arg0) {
-        // TODO Auto-generated method stub
-        return false;
-    }
-
-    @Override
-    public String getLocalAddr() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public String getLocalName() {
-        // TODO Auto-generated method stub
-        return null;
-    }
-
-    @Override
-    public int getLocalPort() {
-        // TODO Auto-generated method stub
-        return 0;
-    }
-
-    @Override
-    public int getRemotePort() {
-        // TODO Auto-generated method stub
-        return 0;
-    }
+	enum count {
+		ONE, TWO
+	}
+
+	;
+
+	@Override
+	public Object getAttribute(String arg0) {
+		return "";
+	}
+
+	@Override
+	public AsyncContext getAsyncContext() {
+		return null;
+	}
+
+	@Override
+	public ServletContext getServletContext() {
+		return null;
+	}
+
+	@Override
+	public AsyncContext startAsync() {
+		return null;
+	}
+
+	@Override
+	public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {
+		return null;
+	}
+
+	@Override
+	public boolean isAsyncSupported() {
+		return true;
+	}
+
+	@Override
+	public boolean isAsyncStarted() {
+		return true;
+	}
+
+	@Override
+	public boolean authenticate(HttpServletResponse response) {
+		return true;
+	}
+
+	@Override
+	@SuppressWarnings("rawtypes")
+	public Enumeration getAttributeNames() {
+
+		return new StringTokenizer("one two");
+	}
+
+	@Override
+	public String getCharacterEncoding() {
+		return "UTF-8";
+	}
+
+	@Override
+	public int getContentLength() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	public String getContentType() {
+		// TODO Auto-generated method stub
+		return "contenttype";
+	}
+
+	@Override
+	public ServletInputStream getInputStream() throws IOException {
+		// TODO Auto-generated method stub
+		return new DummyServletInputStream();
+	}
+
+	@Override
+	public Locale getLocale() {
+		// TODO Auto-generated method stub
+		return Locale.ENGLISH;
+	}
+
+	@Override
+	@SuppressWarnings("rawtypes")
+	public Enumeration getLocales() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getParameter(String arg0) {
+		// TODO Auto-generated method stub
+		return arg0;
+	}
+
+	@Override
+	@SuppressWarnings("rawtypes")
+	public Map getParameterMap() {
+		HashMap<String, String> map = new HashMap<String, String>();
+		map.put("dummy", "dummy");
+		return map;
+	}
+
+	@Override
+	public Part getPart(String name) {
+		return null;
+	}
+
+	@Override
+	public java.util.Collection<Part> getParts() {
+		return null;
+	}
+
+	@Override
+	public void logout() {
+
+	}
+
+	@Override
+	public void login(String user, String pwd) {
+
+	}
+
+	@Override
+	@SuppressWarnings("rawtypes")
+	public Enumeration getParameterNames() {
+		// TODO Auto-generated method stub
+		return new StringTokenizer("parameter names");
+	}
+
+	@Override
+	public String[] getParameterValues(String arg0) {
+		// TODO Auto-generated method stub
+		return new String[] { arg0 };
+	}
+
+	@Override
+	public String getProtocol() {
+		// TODO Auto-generated method stub
+		return "";
+	}
+
+	@Override
+	public DispatcherType getDispatcherType() {
+		return null;
+	}
+
+	@Override
+	public BufferedReader getReader() throws IOException {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getRealPath(String arg0) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getRemoteAddr() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getRemoteHost() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public RequestDispatcher getRequestDispatcher(String arg0) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getScheme() {
+		// TODO Auto-generated method stub
+		return "";
+	}
+
+	@Override
+	public String getServerName() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public int getServerPort() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	public boolean isSecure() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public void removeAttribute(String arg0) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void setAttribute(String arg0, Object arg1) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void setCharacterEncoding(String arg0) throws UnsupportedEncodingException {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public String getAuthType() {
+		// TODO Auto-generated method stub
+		return "";
+	}
+
+	@Override
+	public String getContextPath() {
+		// TODO Auto-generated method stub
+		return "";
+	}
+
+	@Override
+	public Cookie[] getCookies() {
+		Cookie c = new Cookie("", "");
+		return new Cookie[] { c };
+	}
+
+	@Override
+	public long getDateHeader(String arg0) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	public String getHeader(String arg0) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	@SuppressWarnings("rawtypes")
+	public Enumeration getHeaderNames() {
+		return new StringTokenizer("secret1 secret2 secret3");
+	}
+
+	@Override
+	@SuppressWarnings("rawtypes")
+	public Enumeration getHeaders(String arg0) {
+		return new StringTokenizer("secret1 secret2 secret3");
+	}
+
+	@Override
+	public int getIntHeader(String arg0) {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	public String getMethod() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getPathInfo() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getPathTranslated() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getQueryString() {
+		// TODO Auto-generated method stub
+		return "";
+	}
+
+	@Override
+	public String getRemoteUser() {
+		// TODO Auto-generated method stub
+		return "";
+	}
+
+	@Override
+	public String getRequestURI() {
+		// TODO Auto-generated method stub
+		return "";
+	}
+
+	@Override
+	public StringBuffer getRequestURL() {
+		// TODO Auto-generated method stub
+		return new StringBuffer("http://");
+	}
+
+	@Override
+	public String getRequestedSessionId() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getServletPath() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public HttpSession getSession() {
+		return new DummyHttpSession();
+	}
+
+	@Override
+	public HttpSession getSession(boolean arg0) {
+		// TODO Auto-generated method stub
+		return new DummyHttpSession();
+	}
+
+	@Override
+	public Principal getUserPrincipal() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public boolean isRequestedSessionIdFromCookie() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public boolean isRequestedSessionIdFromURL() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public boolean isRequestedSessionIdFromUrl() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public boolean isRequestedSessionIdValid() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public boolean isUserInRole(String arg0) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public String getLocalAddr() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getLocalName() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public int getLocalPort() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	public int getRemotePort() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
 
 }
-
diff --git a/sootOutput/java.net.HttpURLConnection.xml b/sootOutput/java.net.HttpURLConnection.xml
new file mode 100644
index 0000000..ffed8db
--- /dev/null
+++ b/sootOutput/java.net.HttpURLConnection.xml
@@ -0,0 +1,396 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<summary fileFormatVersion="101">
+	<methods>
+		<method id="void &lt;init&gt;(java.net.URL)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.net.URL url]"
+						AccessPathTypes="[java.net.URL]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void addRequestProperty(java.lang.String,java.lang.String)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] requestKeys]"
+						AccessPathTypes="[java.lang.String[]]" />
+				</flow>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="1" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] requestValues]"
+						AccessPathTypes="[java.lang.String[]]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="boolean getAllowUserInteraction()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: boolean allowUserInteraction]"
+						AccessPathTypes="[boolean]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="int getConnectTimeout()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: int connectTimeout]"
+						AccessPathTypes="[int]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="boolean getDefaultUseCaches()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: boolean defaultUseCaches]"
+						AccessPathTypes="[boolean]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="boolean getDoInput()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: boolean doInput]"
+						AccessPathTypes="[boolean]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="boolean getDoOutput()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: boolean doOutput]"
+						AccessPathTypes="[boolean]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.lang.String getHeaderField(int)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] headerValues]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.lang.String getHeaderField(java.lang.String)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] headerValues]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="long getHeaderFieldDate(java.lang.String,long)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] headerValues]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return" />
+				</flow>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="int getHeaderFieldInt(java.lang.String,int)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] headerValues]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return" />
+				</flow>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="int getHeaderFieldKey(int)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] headerKeys]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="long getHeaderFieldLong(java.lang.String,long)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] headerValues]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return" />
+				</flow>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.util.Map getHeaderFields()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] headerKeys]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return"
+						AccessPath="[java.util.Map: java.lang.Object[] keys]"
+						AccessPathTypes="[java.lang.Object[]]" />
+				</flow>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] headerValues]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return"
+						AccessPath="[java.util.Map: java.lang.Object[] values]"
+						AccessPathTypes="[java.lang.Object[]]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="long getIfModifiedSince()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: long ifModifiedSince]"
+						AccessPathTypes="[long]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.io.InputStream getInputStream()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.net.URL url]"
+						AccessPathTypes="[java.net.URL]" />
+					<to sourceSinkType="Return" BaseType="java.io.InputStream"
+						AccessPath="[java.io.InputStream: java.net.URL url]"
+						AccessPathTypes="[java.net.URL]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.io.OutputStream getOutputStream()">
+			<flows>
+				<flow isAlias="true" typeChecking="false">
+					<from sourceSinkType="Field"/>
+					<to sourceSinkType="Return"/>
+				</flow>
+<!--				<flow isAlias="false" typeChecking="false">-->
+<!--					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"-->
+<!--						AccessPath="[java.net.HttpURLConnection: java.net.URL url]"-->
+<!--						AccessPathTypes="[java.net.URL]" />-->
+<!--					<from sourceSinkType="Return" BaseType="java.io.OutputStream"-->
+<!--						AccessPath="[java.io.OutputStream: java.net.URL url]"-->
+<!--						AccessPathTypes="[java.net.URL]" />-->
+<!--				</flow>-->
+			</flows>
+		</method>
+		<method id="int getReadTimeout()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: int readTimeout]"
+						AccessPathTypes="[int]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.util.Map getRequestProperties()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] requestKeys]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return"
+						AccessPath="[java.util.Map: java.lang.Object[] keys]"
+						AccessPathTypes="[java.lang.Object[]]" />
+				</flow>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] requestValues]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return"
+						AccessPath="[java.util.Map: java.lang.Object[] values]"
+						AccessPathTypes="[java.lang.Object[]]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.lang.String getRequestProperty(java.lang.String)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] requestValues]"
+						AccessPathTypes="[java.lang.String[]]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.net.URL getURL()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.net.URL url]"
+						AccessPathTypes="[java.net.URL]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="boolean getUseCaches()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: boolean useCaches]"
+						AccessPathTypes="[boolean]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.lang.String guessContentTypeFromName(java.lang.String)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.lang.String guessContentTypeFromStream(java.io.InputStream)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0"
+						BaseType="java.io.InputStream"
+						AccessPath="[java.io.InputStream: byte[] data]"
+						AccessPathTypes="[byte[]]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void setAllowUserInteraction(boolean)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: boolean allowUserInteraction]"
+						AccessPathTypes="[boolean]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void setConnectTimeout(int)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: int connectTimeout]"
+						AccessPathTypes="[int]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void setDefaultUseCaches(boolean)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: boolean defaultUseCaches]"
+						AccessPathTypes="[boolean]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void setDoInput(boolean)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: boolean doInput]"
+						AccessPathTypes="[boolean]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void setDoOutput(boolean)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: boolean doOutput]"
+						AccessPathTypes="[boolean]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void setIfModifiedSince(long)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: long ifModifiedSince]"
+						AccessPathTypes="[long]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void setReadTimeout(int)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: int readTimeout]"
+						AccessPathTypes="[int]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void setRequestProperty(java.lang.String,java.lang.String)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] requestKeys]"
+						AccessPathTypes="[java.lang.String[]]" />
+				</flow>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="1" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.lang.String[] requestValues]"
+						AccessPathTypes="[java.lang.String[]]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="void setUseCaches(boolean)">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Parameter" ParameterIndex="0" />
+					<to sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: boolean useCaches]"
+						AccessPathTypes="[boolean]" />
+				</flow>
+			</flows>
+		</method>
+		<method id="java.lang.String toString()">
+			<flows>
+				<flow isAlias="false" typeChecking="false">
+					<from sourceSinkType="Field" BaseType="java.net.HttpURLConnection"
+						AccessPath="[java.net.HttpURLConnection: java.net.URL url]"
+						AccessPathTypes="[java.net.URL]" />
+					<to sourceSinkType="Return" />
+				</flow>
+			</flows>
+		</method>
+	</methods>
+</summary>
\ No newline at end of file
